<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Log-Based Stream Processing — Archie Playground</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
<style>
/* ═══════════════ RESET & BASE ═══════════════ */
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
:root {
  --canvas-bg: #0f1117;
  --panel-bg: #1a1d27;
  --surface: #242736;
  --border: #2e3348;
  --text-primary: #e2e4eb;
  --text-secondary: #8b8fa3;
  --accent: #6366f1;
  --accent-hover: #818cf8;
  --green: #22c55e;
  --yellow: #eab308;
  --red: #ef4444;
  --cat-compute: #3b82f6;
  --cat-data: #22c55e;
  --cat-cache: #f97316;
  --cat-messaging: #a855f7;
  --cat-delivery: #06b6d4;
  --cat-realtime: #ec4899;
  --cat-auth: #ef4444;
  --cat-monitoring: #eab308;
  --cat-search: #14b8a6;
  --cat-devops: #8b5cf6;
  --radius: 6px;
  --space: 4px;
  --toolbox-w: 270px;
  --inspector-w: 310px;
  --topbar-h: 44px;
}
html, body { height: 100%; overflow: hidden; }
body {
  font-family: 'Inter', system-ui, -apple-system, sans-serif;
  background: var(--canvas-bg);
  color: var(--text-primary);
  font-size: 13px;
  line-height: 1.4;
}

/* ═══════════════ TOP BAR ═══════════════ */
.top-bar {
  height: var(--topbar-h);
  background: var(--panel-bg);
  border-bottom: 1px solid var(--border);
  display: flex;
  align-items: center;
  padding: 0 12px;
  gap: 12px;
  z-index: 100;
}
.logo {
  font-weight: 700;
  font-size: 15px;
  color: var(--accent);
  letter-spacing: -0.5px;
  display: flex;
  align-items: center;
  gap: 6px;
}
.logo svg { width: 18px; height: 18px; }
.arch-name {
  font-weight: 500;
  color: var(--text-secondary);
  flex: 1;
}
.tier-badge {
  background: var(--accent);
  color: white;
  font-size: 11px;
  font-weight: 600;
  padding: 3px 10px;
  border-radius: 12px;
  cursor: default;
  display: flex;
  align-items: center;
  gap: 4px;
}
.tier-badge svg { width: 12px; height: 12px; }
.tier-badge .tier-hint {
  font-weight: 400;
  opacity: 0.7;
  font-size: 10px;
}
.top-actions { display: flex; gap: 6px; }
.top-btn {
  background: var(--surface);
  border: 1px solid var(--border);
  color: var(--text-secondary);
  padding: 5px 10px;
  border-radius: var(--radius);
  font-size: 11px;
  font-family: inherit;
  cursor: pointer;
  transition: all 0.15s;
  display: flex;
  align-items: center;
  gap: 4px;
}
.top-btn svg { width: 14px; height: 14px; }
.top-btn:hover { color: var(--text-primary); border-color: var(--text-secondary); }
.top-btn.active { background: var(--accent); color: white; border-color: var(--accent); }

/* ═══════════════ MAIN LAYOUT ═══════════════ */
.main-layout {
  display: flex;
  height: calc(100vh - var(--topbar-h));
}

/* ═══════════════ TOOLBOX ═══════════════ */
.toolbox {
  width: var(--toolbox-w);
  min-width: var(--toolbox-w);
  background: var(--panel-bg);
  border-right: 1px solid var(--border);
  display: flex;
  flex-direction: column;
  transition: width 0.2s, min-width 0.2s, opacity 0.2s;
  overflow: hidden;
}
.toolbox.collapsed { width: 0; min-width: 0; opacity: 0; pointer-events: none; }
.toolbox-title {
  padding: 10px 12px;
  border-bottom: 1px solid var(--border);
  font-weight: 600;
  font-size: 12px;
  color: var(--text-secondary);
  text-transform: uppercase;
  letter-spacing: 0.5px;
  display: flex;
  align-items: center;
  gap: 6px;
}
.toolbox-title svg { width: 14px; height: 14px; }
.toolbox-tabs {
  display: flex;
  border-bottom: 1px solid var(--border);
}
.toolbox-tab {
  flex: 1;
  padding: 8px 4px;
  text-align: center;
  font-size: 11px;
  font-weight: 500;
  color: var(--text-secondary);
  cursor: pointer;
  border-bottom: 2px solid transparent;
  transition: all 0.15s;
  background: none;
  border-top: none;
  border-left: none;
  border-right: none;
  font-family: inherit;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 4px;
}
.toolbox-tab svg { width: 14px; height: 14px; }
.toolbox-tab:hover { color: var(--text-primary); }
.toolbox-tab.active { color: var(--accent); border-bottom-color: var(--accent); }
.toolbox-content {
  flex: 1;
  overflow-y: auto;
  padding: 8px;
}
.toolbox-content::-webkit-scrollbar { width: 4px; }
.toolbox-content::-webkit-scrollbar-track { background: transparent; }
.toolbox-content::-webkit-scrollbar-thumb { background: var(--border); border-radius: 2px; }
.component-card {
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 10px;
  margin-bottom: 8px;
  cursor: grab;
  transition: all 0.15s;
  border-left: 3px solid var(--cat-color);
}
.component-card:hover {
  border-color: var(--text-secondary);
  transform: translateY(-1px);
}
.card-header {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 6px;
}
.card-icon {
  width: 20px;
  height: 20px;
  flex-shrink: 0;
  display: flex;
  align-items: center;
  justify-content: center;
}
.card-icon svg { width: 18px; height: 18px; }
.card-name { font-weight: 600; font-size: 12px; }
.card-category { font-size: 10px; color: var(--text-secondary); display: flex; align-items: center; gap: 3px; }
.card-category svg { width: 10px; height: 10px; }
.card-section {
  font-size: 10px;
  margin-top: 4px;
  line-height: 1.5;
}
.card-section-label {
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  font-size: 9px;
  margin-bottom: 1px;
  display: flex;
  align-items: center;
  gap: 3px;
}
.card-section-label svg { width: 10px; height: 10px; }
.card-is { color: var(--text-secondary); }
.card-gain { color: var(--green); }
.card-cost { color: var(--yellow); }
/* ═══════════════ CATALOG CATEGORY GROUPS ═══════════════ */
.cat-group {
  margin-bottom: 4px;
}
.cat-group-header {
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 6px 8px;
  cursor: pointer;
  border-radius: var(--radius);
  transition: background 0.1s;
  user-select: none;
}
.cat-group-header:hover { background: var(--surface); }
.cat-group-header svg { width: 14px; height: 14px; flex-shrink: 0; }
.cat-group-name {
  font-weight: 600;
  font-size: 11px;
  flex: 1;
}
.cat-group-count {
  font-size: 9px;
  color: var(--text-secondary);
  background: var(--surface);
  padding: 1px 6px;
  border-radius: 8px;
}
.cat-group-header .section-chevron svg { width: 10px; height: 10px; }
.cat-group-body {
  padding: 0 0 4px 8px;
}
.cat-group-body.collapsed { display: none; }
.cat-group-desc {
  font-size: 10px;
  color: var(--text-secondary);
  line-height: 1.4;
  padding: 2px 8px 6px 20px;
  font-style: italic;
}
.cat-item {
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 5px 8px;
  border-radius: 4px;
  font-size: 11px;
  cursor: grab;
  transition: background 0.1s;
  position: relative;
}
.cat-item:hover { background: var(--surface); }
.cat-item-dot {
  width: 6px;
  height: 6px;
  border-radius: 50%;
  flex-shrink: 0;
}
.cat-item-name { font-weight: 500; }
.cat-item-sub { font-size: 9px; color: var(--text-secondary); margin-left: auto; }
.cat-item-active {
  font-size: 8px;
  color: var(--accent);
  font-weight: 600;
  margin-left: 4px;
}
/* Catalog item tooltip */
.cat-item-tip {
  display: none;
  position: absolute;
  left: calc(100% + 8px);
  top: 50%;
  transform: translateY(-50%);
  background: var(--panel-bg);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 8px 10px;
  font-size: 10px;
  min-width: 180px;
  z-index: 30;
  box-shadow: 0 4px 16px rgba(0,0,0,0.5);
  pointer-events: none;
  white-space: normal;
  line-height: 1.4;
}
.cat-item:hover .cat-item-tip { display: block; }
.cat-item-tip-label {
  font-size: 9px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  color: var(--text-secondary);
  margin-top: 4px;
}
.cat-item-tip-label:first-child { margin-top: 0; }
.cat-item-tip-list {
  display: flex;
  flex-wrap: wrap;
  gap: 3px;
  margin-top: 2px;
}
.cat-item-tip-tag {
  font-size: 9px;
  padding: 1px 5px;
  border-radius: 3px;
  background: var(--surface);
  border: 1px solid var(--border);
}

/* ═══════════════ CANVAS ═══════════════ */
.canvas {
  flex: 1;
  position: relative;
  background: var(--canvas-bg);
  overflow: hidden;
}
.canvas-svg {
  position: absolute;
  top: 0; left: 0;
  width: 100%; height: 100%;
  pointer-events: none;
  z-index: 1;
}
.canvas-svg .conn-label-group { pointer-events: all; cursor: grab; }
.canvas-svg .conn-label-group:active { cursor: grabbing; }
.canvas-svg .conn-path {
  stroke: var(--border);
  stroke-width: 2;
  fill: none;
  transition: stroke 0.4s, stroke-width 0.3s;
}
.canvas-svg .conn-path.heat-green { stroke: var(--green); stroke-width: 2.5; }
.canvas-svg .conn-path.heat-yellow { stroke: var(--yellow); stroke-width: 2.5; stroke-dasharray: 8 4; }
.canvas-svg .conn-path.heat-red { stroke: var(--red); stroke-width: 3; stroke-dasharray: 6 3; }
.canvas-svg .conn-path.ripple { stroke: var(--accent); stroke-width: 3; }
.canvas-svg .conn-path.conn-selected { stroke: var(--accent); stroke-width: 2.5; }

/* Canvas Legend */
.canvas-legend {
  position: absolute;
  top: 12px;
  right: 12px;
  background: var(--panel-bg);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 8px 10px;
  font-size: 10px;
  z-index: 5;
  opacity: 0.9;
  transition: opacity 0.2s;
}
.canvas-legend:hover { opacity: 1; }
.legend-title {
  font-weight: 600;
  font-size: 9px;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  color: var(--text-secondary);
  margin-bottom: 6px;
  display: flex;
  align-items: center;
  gap: 4px;
}
.legend-title svg { width: 12px; height: 12px; }
.legend-item {
  display: flex;
  align-items: center;
  gap: 6px;
  margin-bottom: 3px;
  color: var(--text-secondary);
}
.legend-item svg { width: 12px; height: 12px; }
.legend-swatch {
  width: 12px;
  height: 3px;
  border-radius: 2px;
  flex-shrink: 0;
}
.legend-dot {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  border: 2px solid;
  flex-shrink: 0;
}
.legend-divider {
  height: 1px;
  background: var(--border);
  margin: 5px 0;
}

/* Canvas Nodes */
.node {
  position: absolute;
  width: 152px;
  background: var(--surface);
  border: 2px solid var(--border);
  padding: 0;
  cursor: pointer;
  z-index: 2;
  transition: all 0.2s;
  user-select: none;
}
/* Shape variations per category */
.node[data-shape="rectangle"] { border-radius: 4px; }
.node[data-shape="cylinder"] { border-radius: 4px 4px 14px 14px; }
.node[data-shape="pill"] { border-radius: 16px; }
.node[data-shape="hexish"] { border-radius: 12px 4px 12px 4px; }
.node[data-shape="stadium"] { border-radius: 20px; }

.node:hover { border-color: var(--text-secondary); z-index: 3; }
.node.selected { border-color: var(--accent); box-shadow: 0 0 0 2px rgba(99,102,241,0.3); z-index: 4; }
.node.dragging { opacity: 0.85; z-index: 10; cursor: grabbing; box-shadow: 0 8px 32px rgba(0,0,0,0.5); transition: none; }

.node-body {
  padding: 8px 10px 10px;
  position: relative;
}
/* Variant button on node (right side) */
.node-variant-btn {
  position: absolute;
  top: 4px;
  right: 4px;
  width: 20px;
  height: 20px;
  background: var(--panel-bg);
  border: 1px solid var(--border);
  border-radius: 4px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  opacity: 0;
  transition: opacity 0.15s, background 0.15s;
  z-index: 5;
}
.node-variant-btn svg { width: 12px; height: 12px; }
.node:hover .node-variant-btn { opacity: 0.7; }
.node-variant-btn:hover { opacity: 1 !important; background: var(--accent); border-color: var(--accent); }
/* Node dropdown overlays (shared) */
.node-dropdown {
  position: absolute;
  margin-top: 4px;
  background: var(--panel-bg);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 4px;
  min-width: 160px;
  z-index: 20;
  box-shadow: 0 8px 24px rgba(0,0,0,0.4);
}
.node-dropdown.left { top: 100%; left: 0; }
.node-dropdown.right { top: 100%; right: 0; }
/* Legacy alias */
.swap-dropdown { position: absolute; top: 100%; right: 0; margin-top: 4px; background: var(--panel-bg); border: 1px solid var(--border); border-radius: var(--radius); padding: 4px; min-width: 160px; z-index: 20; box-shadow: 0 8px 24px rgba(0,0,0,0.4); }
.swap-option {
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 5px 8px;
  border-radius: 3px;
  font-size: 11px;
  cursor: pointer;
  transition: background 0.1s;
  color: var(--text-primary);
}
.swap-option:hover { background: var(--surface); }
.swap-option.current { color: var(--accent); font-weight: 600; }
.swap-option svg { width: 12px; height: 12px; }
.swap-option-sub { font-size: 9px; color: var(--text-secondary); margin-left: auto; }
.node-header {
  display: flex;
  align-items: center;
  gap: 6px;
  margin-bottom: 4px;
}
.node-icon {
  width: 20px;
  height: 20px;
  flex-shrink: 0;
  display: flex;
  align-items: center;
  justify-content: center;
}
.node-icon svg { width: 18px; height: 18px; }
.node-name { font-weight: 600; font-size: 12px; line-height: 1.2; }
.node-variant { font-size: 10px; color: var(--text-secondary); margin-left: 26px; }
.node-mini-metrics {
  display: flex;
  gap: 3px;
  margin-top: 6px;
}
.node-mini-bar {
  flex: 1;
  height: 3px;
  background: var(--border);
  border-radius: 2px;
  overflow: hidden;
}
.node-mini-fill {
  height: 100%;
  border-radius: 2px;
  transition: width 0.4s ease, background-color 0.4s ease;
}

/* Heatmap borders */
.node.heatmap-green { border-color: var(--green); box-shadow: 0 0 10px rgba(34,197,94,0.3); }
.node.heatmap-yellow { border-color: var(--yellow); box-shadow: 0 0 10px rgba(234,179,8,0.3); }
.node.heatmap-red { border-color: var(--red); box-shadow: 0 0 10px rgba(239,68,68,0.3); }
.node.selected.heatmap-green { box-shadow: 0 0 0 2px rgba(34,197,94,0.3), 0 0 10px rgba(34,197,94,0.2); }
.node.selected.heatmap-yellow { box-shadow: 0 0 0 2px rgba(234,179,8,0.3), 0 0 10px rgba(234,179,8,0.2); }
.node.selected.heatmap-red { box-shadow: 0 0 0 2px rgba(239,68,68,0.3), 0 0 10px rgba(239,68,68,0.2); }

/* Tooltip */
.node-tooltip {
  display: none;
  position: absolute;
  bottom: calc(100% + 8px);
  left: 50%;
  transform: translateX(-50%);
  background: var(--panel-bg);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 8px 10px;
  font-size: 11px;
  white-space: nowrap;
  z-index: 10;
  pointer-events: none;
  box-shadow: 0 4px 12px rgba(0,0,0,0.4);
}
.node:hover .node-tooltip { display: block; }
.tooltip-header { display: flex; align-items: center; gap: 5px; margin-bottom: 3px; }
.tooltip-header svg { width: 14px; height: 14px; }
.tooltip-metrics { display: flex; gap: 10px; margin-top: 4px; }
.tooltip-metric { color: var(--text-secondary); }
.tooltip-metric span { color: var(--text-primary); font-weight: 500; }

/* Canvas empty state hint */
.canvas-hint {
  position: absolute;
  bottom: 72px;
  left: 50%;
  transform: translateX(-50%);
  color: var(--text-secondary);
  font-size: 11px;
  opacity: 0.5;
  pointer-events: none;
  display: flex;
  align-items: center;
  gap: 6px;
}
.canvas-hint svg { width: 14px; height: 14px; }

/* ═══════════════ INSPECTOR ═══════════════ */
.inspector {
  width: var(--inspector-w);
  min-width: var(--inspector-w);
  background: var(--panel-bg);
  border-left: 1px solid var(--border);
  display: flex;
  flex-direction: column;
  transition: width 0.2s, min-width 0.2s, opacity 0.2s;
  overflow: hidden;
}
.inspector.collapsed { width: 0; min-width: 0; opacity: 0; pointer-events: none; }
.inspector-header {
  padding: 10px 12px;
  border-bottom: 1px solid var(--border);
  font-weight: 600;
  font-size: 12px;
  color: var(--text-secondary);
  text-transform: uppercase;
  letter-spacing: 0.5px;
  display: flex;
  align-items: center;
  gap: 6px;
}
.inspector-header svg { width: 14px; height: 14px; }
.inspector-content {
  flex: 1;
  overflow-y: auto;
  padding: 12px;
}
.inspector-content::-webkit-scrollbar { width: 4px; }
.inspector-content::-webkit-scrollbar-track { background: transparent; }
.inspector-content::-webkit-scrollbar-thumb { background: var(--border); border-radius: 2px; }
.inspector-empty {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 100%;
  color: var(--text-secondary);
  font-size: 12px;
  text-align: center;
  padding: 20px;
  gap: 8px;
}
.inspector-empty svg { width: 32px; height: 32px; opacity: 0.3; }
.insp-header {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 4px;
}
.insp-header-btn {
  width: 28px;
  height: 28px;
  display: flex;
  align-items: center;
  justify-content: center;
  border: 1px solid var(--border);
  border-radius: var(--radius);
  background: var(--surface);
  cursor: pointer;
  transition: all 0.15s;
  flex-shrink: 0;
}
.insp-header-btn:hover { border-color: var(--text-secondary); }
.insp-header-btn.active { border-color: var(--accent); background: rgba(99, 102, 241, 0.1); }
.insp-header-btn svg { width: 16px; height: 16px; }
.insp-header-center {
  flex: 1;
  min-width: 0;
}
.insp-name { font-size: 16px; font-weight: 700; }
.insp-variant-label { font-size: 11px; color: var(--text-secondary); }
.insp-category { font-size: 11px; color: var(--text-secondary); margin-bottom: 12px; display: flex; align-items: center; gap: 6px; }
.insp-cat-dot { width: 8px; height: 8px; border-radius: 50%; }
/* Inspector header dropdowns */
.insp-header-dropdown {
  display: none;
  position: fixed;
  background: var(--panel-bg);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 6px 0;
  min-width: 240px;
  max-width: 280px;
  z-index: 1000;
  box-shadow: 0 4px 16px rgba(0,0,0,0.4);
  animation: metricExpand 0.15s ease-out;
}
.insp-header-dropdown.visible { display: block; }
.insp-dd-item {
  padding: 8px 12px;
  cursor: pointer;
  transition: background 0.1s;
  border-left: 3px solid transparent;
}
.insp-dd-item:hover { background: var(--surface); }
.insp-dd-item.current {
  border-left-color: var(--accent);
  background: rgba(99, 102, 241, 0.05);
}
.insp-dd-item-header {
  display: flex;
  align-items: center;
  gap: 6px;
  font-size: 12px;
  font-weight: 500;
}
.insp-dd-item-header svg { width: 14px; height: 14px; }
.insp-dd-item-sub {
  font-size: 10px;
  color: var(--text-secondary);
  font-weight: 400;
}
.insp-dd-item-current {
  font-size: 9px;
  color: var(--accent);
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.3px;
}
.insp-dd-metrics {
  display: flex;
  gap: 4px;
  margin-top: 5px;
  flex-wrap: wrap;
}
.insp-dd-metric {
  font-size: 9px;
  padding: 1px 5px;
  border-radius: 3px;
  background: var(--surface);
  border: 1px solid var(--border);
  display: inline-flex;
  align-items: center;
  gap: 2px;
}
.insp-dd-metric svg { width: 10px; height: 10px; flex-shrink: 0; }
.insp-dd-metric.positive { color: var(--green); border-color: rgba(34,197,94,0.3); }
.insp-dd-metric.negative { color: var(--red); border-color: rgba(239,68,68,0.3); }
.insp-dd-metric.neutral { color: var(--text-secondary); }
.insp-dd-rec {
  padding: 6px 12px;
  margin-top: 2px;
  border-top: 1px solid var(--border);
  font-size: 10px;
  color: var(--text-secondary);
  display: flex;
  align-items: center;
  gap: 4px;
}
.insp-dd-rec svg { width: 10px; height: 10px; }
.insp-section { margin-bottom: 14px; }
.insp-section-title {
  font-size: 10px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  color: var(--text-secondary);
  margin-bottom: 6px;
  display: flex;
  align-items: center;
  gap: 5px;
}
.insp-section-title svg { width: 12px; height: 12px; }
.insp-select {
  width: 100%;
  background: var(--surface);
  border: 1px solid var(--border);
  color: var(--text-primary);
  padding: 6px 8px;
  border-radius: var(--radius);
  font-family: inherit;
  font-size: 12px;
  cursor: pointer;
  outline: none;
}
.insp-select:focus { border-color: var(--accent); }

/* Metric bars in inspector */
.metric-row { margin-bottom: 0; }
.metric-label {
  display: flex;
  justify-content: space-between;
  font-size: 11px;
  margin-bottom: 3px;
}
.metric-name { color: var(--text-secondary); display: flex; align-items: center; gap: 4px; }
.metric-name svg { width: 11px; height: 11px; }
.metric-value { font-weight: 600; }
.metric-bar-track {
  height: 6px;
  background: var(--surface);
  border-radius: 3px;
  overflow: hidden;
  position: relative;
}
.metric-bar-fill {
  height: 100%;
  border-radius: 3px;
  transition: width 0.5s cubic-bezier(0.4, 0, 0.2, 1), background-color 0.5s;
}

/* Metric filter dropdown */
.metric-filter-wrap {
  position: relative;
  display: inline-block;
}
.metric-filter-btn {
  background: none;
  border: 1px solid transparent;
  color: var(--text-secondary);
  cursor: pointer;
  padding: 2px 5px;
  border-radius: var(--radius);
  display: flex;
  align-items: center;
  gap: 3px;
  font-size: 10px;
  font-family: inherit;
  transition: all 0.15s;
  margin-left: auto;
}
.metric-filter-btn:hover { color: var(--accent); border-color: var(--border); }
.metric-filter-btn.active { color: var(--accent); background: rgba(99, 102, 241, 0.1); border-color: var(--accent); }
.metric-filter-btn svg { width: 10px; height: 10px; }
.metric-filter-menu {
  display: none;
  position: fixed;
  background: var(--panel-bg);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 6px 0;
  min-width: 200px;
  z-index: 1000;
  box-shadow: 0 4px 16px rgba(0,0,0,0.4);
  animation: metricExpand 0.15s ease-out;
}
.metric-filter-menu.visible { display: block; }
.metric-filter-actions {
  display: flex;
  gap: 4px;
  padding: 0 8px 6px;
  border-bottom: 1px solid var(--border);
  margin-bottom: 4px;
}
.metric-filter-action {
  background: none;
  border: none;
  color: var(--accent);
  font-size: 10px;
  font-family: inherit;
  cursor: pointer;
  padding: 2px 6px;
  border-radius: 3px;
  transition: background 0.15s;
}
.metric-filter-action:hover { background: rgba(99, 102, 241, 0.15); }
.metric-filter-item {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 4px 10px;
  cursor: pointer;
  font-size: 11px;
  color: var(--text-secondary);
  transition: background 0.1s;
}
.metric-filter-item:hover { background: var(--surface); }
.metric-filter-check {
  width: 14px;
  height: 14px;
  border: 1.5px solid var(--border);
  border-radius: 3px;
  display: flex;
  align-items: center;
  justify-content: center;
  flex-shrink: 0;
  transition: all 0.15s;
}
.metric-filter-item.checked .metric-filter-check {
  background: var(--accent);
  border-color: var(--accent);
}
.metric-filter-check svg { width: 10px; height: 10px; }
.metric-filter-name { display: flex; align-items: center; gap: 4px; flex: 1; }
.metric-filter-name svg { width: 11px; height: 11px; }
.metric-filter-val {
  font-size: 10px;
  font-weight: 600;
  margin-left: auto;
}
.metric-section-title-row {
  display: flex;
  align-items: center;
  width: 100%;
}

/* Metric explanation dropdown */
.metric-row-wrap { margin-bottom: 8px; }
.metric-info-btn {
  background: none;
  border: none;
  color: var(--text-secondary);
  cursor: pointer;
  padding: 0;
  width: 14px;
  height: 14px;
  display: flex;
  align-items: center;
  justify-content: center;
  opacity: 0.5;
  transition: opacity 0.15s, color 0.15s;
  flex-shrink: 0;
}
.metric-info-btn:hover { opacity: 1; color: var(--accent); }
.metric-info-btn svg { width: 11px; height: 11px; }
.metric-explanation {
  display: none;
  margin-top: 6px;
  padding: 8px 10px;
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  font-size: 11px;
  line-height: 1.5;
  animation: metricExpand 0.2s ease-out;
}
.metric-explanation.visible { display: block; }
@keyframes metricExpand {
  from { opacity: 0; transform: translateY(-4px); }
  to { opacity: 1; transform: translateY(0); }
}
.metric-expl-reason {
  color: var(--text-primary);
  margin-bottom: 6px;
}
.metric-expl-factors {
  list-style: none;
  padding: 0;
  margin: 0;
  display: flex;
  flex-direction: column;
  gap: 3px;
}
.metric-expl-factors li {
  color: var(--text-secondary);
  font-size: 10px;
  padding-left: 12px;
  position: relative;
}
.metric-expl-factors li::before {
  content: '›';
  position: absolute;
  left: 2px;
  color: var(--accent);
  font-weight: 600;
}

/* Pros/Cons */
.pros-cons { display: flex; flex-direction: column; gap: 4px; }
.pro, .con { font-size: 11px; display: flex; gap: 4px; align-items: flex-start; }
.pro::before { content: '+'; color: var(--green); font-weight: 700; flex-shrink: 0; }
.con::before { content: '−'; color: var(--red); font-weight: 700; flex-shrink: 0; }

/* Data Context */
.data-context-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
}
.data-context-edit {
  font-size: 9px;
  color: var(--accent);
  cursor: pointer;
  opacity: 0.7;
  display: flex;
  align-items: center;
  gap: 3px;
}
.data-context-edit:hover { opacity: 1; }
.data-context-edit svg { width: 10px; height: 10px; }
.data-item {
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: 4px;
  padding: 6px 8px;
  margin-bottom: 6px;
  transition: border-color 0.3s;
}
.data-item.fit-great { border-left: 3px solid var(--green); }
.data-item.fit-good { border-left: 3px solid var(--green); opacity: 0.85; }
.data-item.fit-tradeoff { border-left: 3px solid var(--yellow); }
.data-item.fit-poor { border-left: 3px solid var(--red); }
.data-item.fit-risky { border-left: 3px solid var(--red); }
.data-item-header {
  display: flex;
  align-items: center;
  gap: 5px;
  margin-bottom: 2px;
  font-size: 11px;
  font-weight: 500;
}
.data-item-header svg { width: 11px; height: 11px; }
.fit-badge {
  font-size: 9px;
  font-weight: 600;
  padding: 1px 5px;
  border-radius: 3px;
  margin-left: auto;
  text-transform: uppercase;
  letter-spacing: 0.3px;
}
.fit-badge.great { background: rgba(34,197,94,0.15); color: var(--green); }
.fit-badge.good { background: rgba(34,197,94,0.1); color: var(--green); }
.fit-badge.tradeoff { background: rgba(234,179,8,0.15); color: var(--yellow); }
.fit-badge.poor { background: rgba(239,68,68,0.15); color: var(--red); }
.fit-badge.risky { background: rgba(239,68,68,0.15); color: var(--red); }
.data-item-note {
  font-size: 10px;
  color: var(--text-secondary);
  line-height: 1.4;
  margin-left: 16px;
}

/* Code Pattern */
.code-pattern {
  background: var(--canvas-bg);
  border: 1px solid var(--border);
  border-radius: 4px;
  padding: 8px 10px;
  font-family: 'SF Mono', 'Fira Code', 'Cascadia Code', monospace;
  font-size: 10px;
  line-height: 1.5;
  color: var(--text-secondary);
  overflow-x: auto;
  white-space: pre;
  tab-size: 2;
}
.code-pattern .kw { color: #c084fc; }
.code-pattern .fn { color: #60a5fa; }
.code-pattern .str { color: #4ade80; }
.code-pattern .cm { color: #6b7280; font-style: italic; }
.code-pattern .num { color: #fbbf24; }

/* Connection Labels */
.conn-label-group { cursor: pointer; }
.conn-label-group:hover .conn-label-bg { fill: var(--surface); }
.conn-label-bg {
  fill: var(--panel-bg);
  stroke: var(--border);
  stroke-width: 1;
  rx: 4;
  transition: fill 0.15s;
}
.conn-label-bg.selected { stroke: var(--accent); stroke-width: 1.5; }
.conn-label-text {
  fill: var(--text-secondary);
  font-size: 9px;
  font-family: 'Inter', system-ui, sans-serif;
  font-weight: 500;
  text-anchor: middle;
  dominant-baseline: central;
  pointer-events: none;
}
.conn-label-icon {
  fill: none;
  stroke: var(--text-secondary);
  stroke-width: 1;
}
.conn-label-group.selected .conn-label-text { fill: var(--accent); }

/* Connection detail in inspector */
/* Connection inspector — header with clickable endpoints */
.conn-header {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 10px;
}
.conn-endpoint {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 4px;
  cursor: pointer;
  flex: 1;
  min-width: 0;
  padding: 6px 4px;
  border-radius: var(--radius);
  transition: background 0.15s;
}
.conn-endpoint:hover { background: var(--surface); }
.conn-ep-icon {
  width: 32px;
  height: 32px;
  display: flex;
  align-items: center;
  justify-content: center;
  border: 2px solid var(--border);
  border-radius: 50%;
  background: var(--surface);
}
.conn-ep-icon svg { width: 16px; height: 16px; }
.conn-ep-name {
  font-size: 11px;
  font-weight: 600;
  text-align: center;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  max-width: 100%;
}
.conn-header-arrow { flex-shrink: 0; color: var(--text-secondary); }
.conn-header-arrow svg { width: 14px; height: 14px; }
/* Connection metadata badges */
.conn-meta {
  display: flex;
  align-items: center;
  gap: 6px;
  margin-bottom: 8px;
}
.conn-protocol-badge {
  display: inline-flex;
  align-items: center;
  gap: 3px;
  background: rgba(99, 102, 241, 0.1);
  border: 1px solid rgba(99, 102, 241, 0.3);
  border-radius: 3px;
  padding: 2px 8px;
  font-size: 10px;
  font-weight: 600;
  color: var(--accent);
}
.conn-role-tag {
  font-size: 10px;
  font-weight: 500;
  color: var(--text-secondary);
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: 3px;
  padding: 2px 8px;
}
/* Connection direction text */
.conn-direction-text {
  font-size: 11px;
  color: var(--text-secondary);
  line-height: 1.5;
  margin-bottom: 10px;
  font-style: italic;
  padding-left: 2px;
}
/* Connection property chips */
.conn-props-strip {
  display: flex;
  flex-direction: column;
  gap: 4px;
  margin-bottom: 10px;
}
.conn-prop-chip {
  display: flex;
  align-items: center;
  gap: 6px;
  font-size: 11px;
  padding: 5px 8px;
  background: var(--surface);
  border-radius: 4px;
  border-left: 3px solid var(--border);
}
.conn-prop-chip svg { width: 11px; height: 11px; flex-shrink: 0; }
.conn-prop-chip-label {
  color: var(--text-secondary);
  font-weight: 500;
  min-width: 60px;
  flex-shrink: 0;
}
.conn-prop-chip-val { color: var(--text-primary); }
.conn-prop-chip.positive { border-left-color: var(--green); }
.conn-prop-chip.positive .conn-prop-chip-val { color: var(--green); }
.conn-prop-chip.negative { border-left-color: var(--red); }
.conn-prop-chip.negative .conn-prop-chip-val { color: var(--red); }
/* Code pattern block */
.conn-code-pattern {
  background: var(--canvas-bg);
  border: 1px solid var(--border);
  border-radius: 4px;
  padding: 8px 10px;
  font-family: 'SF Mono', 'Fira Code', 'Cascadia Code', monospace;
  font-size: 10px;
  line-height: 1.5;
  color: var(--text-secondary);
  overflow-x: auto;
  white-space: pre;
  tab-size: 2;
  margin-top: 8px;
}
.conn-code-pattern .kw { color: #c084fc; }
.conn-code-pattern .fn { color: #60a5fa; }
.conn-code-pattern .str { color: #4ade80; }
.conn-code-pattern .cm { color: #6b7280; font-style: italic; }
.conn-code-pattern .num { color: #fbbf24; }
/* Connection footer — quick links to endpoints */
.conn-footer {
  display: flex;
  gap: 6px;
  margin-top: 12px;
  padding-top: 10px;
  border-top: 1px solid var(--border);
}
.conn-footer-link {
  flex: 1;
  display: flex;
  align-items: center;
  gap: 4px;
  font-size: 10px;
  color: var(--text-secondary);
  cursor: pointer;
  padding: 5px 8px;
  border: 1px solid var(--border);
  border-radius: var(--radius);
  transition: all 0.15s;
  justify-content: center;
}
.conn-footer-link:hover { border-color: var(--accent); color: var(--text-primary); }
.conn-footer-link svg { width: 11px; height: 11px; }
.conn-summary {
  font-size: 11px;
  color: var(--text-secondary);
  line-height: 1.6;
  padding: 6px 0;
}


/* ═══════════════ DASHBOARD ═══════════════ */
.dashboard {
  position: absolute;
  bottom: 0;
  left: 0;
  right: 0;
  background: var(--panel-bg);
  border-top: 1px solid var(--border);
  padding: 6px 12px;
  display: flex;
  flex-direction: column;
  z-index: 10;
}
.dashboard-title {
  font-size: 10px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  color: var(--text-secondary);
  margin-bottom: 4px;
  display: flex;
  align-items: center;
  gap: 5px;
}
.dashboard-title svg { width: 13px; height: 13px; }
.dashboard-bars {
  display: flex;
  gap: 6px;
  align-items: center;
}
.dash-bar-group {
  flex: 1;
  display: flex;
  flex-direction: column;
  gap: 2px;
}
.dash-bar-label {
  font-size: 9px;
  color: var(--text-secondary);
  text-align: center;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 3px;
}
.dash-bar-label svg { width: 10px; height: 10px; }
.dash-bar-track {
  height: 16px;
  background: var(--surface);
  border-radius: 3px;
  overflow: hidden;
  position: relative;
}
.dash-bar-fill {
  height: 100%;
  border-radius: 3px;
  transition: width 0.6s cubic-bezier(0.4, 0, 0.2, 1), background-color 0.6s;
  position: relative;
}
.dash-bar-value {
  position: absolute;
  right: 4px;
  top: 50%;
  transform: translateY(-50%);
  font-size: 9px;
  font-weight: 600;
  color: rgba(255,255,255,0.8);
}

/* Dashboard expand toggle */
.dash-expand-btn {
  background: none;
  border: 1px solid var(--border);
  border-radius: 3px;
  cursor: pointer;
  padding: 1px 4px;
  margin-left: auto;
  display: flex;
  align-items: center;
  color: var(--text-secondary);
  transition: all 0.15s;
}
.dash-expand-btn:hover { border-color: var(--text-secondary); color: var(--text-primary); }
.dash-expand-chevron { width: 10px; height: 10px; transition: transform 0.2s; }
.dashboard.expanded .dash-expand-chevron { transform: rotate(180deg); }

/* ═══════════════ DASHBOARD OVERLAY ═══════════════ */
.dash-overlay {
  display: none;
  position: absolute;
  top: 0; left: 0; right: 0; bottom: 0;
  background: rgba(15, 17, 23, 0.97);
  z-index: 20;
  flex-direction: column;
  overflow-y: auto;
  padding: 20px 24px;
}
.dash-overlay.visible { display: flex; }
.dash-overlay::-webkit-scrollbar { width: 4px; }
.dash-overlay::-webkit-scrollbar-track { background: transparent; }
.dash-overlay::-webkit-scrollbar-thumb { background: var(--border); border-radius: 2px; }
.dash-overlay-header {
  font-size: 12px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  color: var(--text-secondary);
  margin-bottom: 16px;
  display: flex;
  align-items: center;
  gap: 6px;
}
.dash-overlay-header svg { width: 14px; height: 14px; }
.dash-overlay-close {
  margin-left: auto;
  background: none;
  border: 1px solid var(--border);
  border-radius: 3px;
  color: var(--text-secondary);
  font-size: 16px;
  cursor: pointer;
  width: 24px;
  height: 24px;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.15s;
}
.dash-overlay-close:hover { border-color: var(--text-primary); color: var(--text-primary); }
.dash-overlay-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
  gap: 16px;
  flex: 1;
}
/* Each category card in the overlay */
.dash-card {
  background: var(--panel-bg);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 12px;
  display: flex;
  flex-direction: column;
  gap: 8px;
}
.dash-card-header {
  display: flex;
  align-items: center;
  gap: 6px;
  font-size: 12px;
  font-weight: 600;
}
.dash-card-header svg { width: 14px; height: 14px; }
.dash-card-score {
  font-size: 20px;
  font-weight: 700;
  margin-left: auto;
}
.dash-card-bar {
  height: 8px;
  background: var(--surface);
  border-radius: 4px;
  overflow: hidden;
}
.dash-card-fill {
  height: 100%;
  border-radius: 4px;
  transition: width 0.6s cubic-bezier(0.4, 0, 0.2, 1);
}
.dash-card-desc {
  font-size: 10px;
  color: var(--text-secondary);
  line-height: 1.4;
}
.dash-card-factors {
  display: flex;
  flex-direction: column;
  gap: 4px;
  margin-top: 4px;
}
.dash-card-factor {
  display: flex;
  align-items: center;
  gap: 6px;
  font-size: 10px;
  color: var(--text-secondary);
  position: relative;
}
.dash-card-factor-comp {
  width: 72px;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  flex-shrink: 0;
}
.dash-card-factor-icon {
  width: 14px;
  flex-shrink: 0;
  display: flex;
  align-items: center;
}
.dash-card-factor-icon svg { width: 11px; height: 11px; }
.dash-card-factor-bar {
  flex: 1;
  height: 6px;
  background: var(--surface);
  border-radius: 3px;
  overflow: hidden;
  min-width: 30px;
  display: block;
}
.dash-card-factor-fill {
  display: block;
  height: 100%;
  border-radius: 3px;
  transition: width 0.4s;
}
.dash-card-factor-val {
  width: 22px;
  text-align: right;
  font-weight: 600;
  font-size: 10px;
  flex-shrink: 0;
}
/* Factor tooltip */
.dash-card-factor-tip {
  display: none;
  position: absolute;
  bottom: calc(100% + 4px);
  left: 0;
  background: var(--panel-bg);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 6px 10px;
  font-size: 10px;
  color: var(--text-primary);
  white-space: nowrap;
  z-index: 5;
  box-shadow: 0 2px 8px rgba(0,0,0,0.3);
  pointer-events: none;
}
.dash-card-factor:hover .dash-card-factor-tip { display: block; }

/* ═══════════════ PROMPT OUTPUT ═══════════════ */
.prompt-section {
  position: fixed;
  bottom: 0;
  left: 0;
  right: 0;
  z-index: 200;
  transform: translateY(calc(100% - 32px));
  transition: transform 0.3s;
}
.prompt-section.open { transform: translateY(0); }
.prompt-toggle {
  background: var(--accent);
  color: white;
  border: none;
  padding: 6px 16px;
  font-size: 11px;
  font-weight: 600;
  font-family: inherit;
  cursor: pointer;
  border-radius: var(--radius) var(--radius) 0 0;
  margin-left: 16px;
  display: flex;
  align-items: center;
  gap: 5px;
}
.prompt-toggle svg { width: 14px; height: 14px; }
.prompt-body {
  background: var(--panel-bg);
  border-top: 1px solid var(--accent);
  padding: 12px 16px;
  max-height: 180px;
  display: flex;
  gap: 12px;
}
.prompt-text {
  flex: 1;
  font-size: 12px;
  color: var(--text-secondary);
  line-height: 1.6;
  overflow-y: auto;
  font-family: 'Inter', system-ui, sans-serif;
}
.prompt-copy-btn {
  background: var(--accent);
  color: white;
  border: none;
  padding: 6px 14px;
  border-radius: var(--radius);
  font-size: 11px;
  font-weight: 600;
  font-family: inherit;
  cursor: pointer;
  align-self: flex-start;
  white-space: nowrap;
  transition: background 0.15s;
  display: flex;
  align-items: center;
  gap: 4px;
}
.prompt-copy-btn svg { width: 12px; height: 12px; }
.prompt-copy-btn:hover { background: var(--accent-hover); }

/* ═══════════════ RIPPLE ANIMATION ═══════════════ */
@keyframes ripplePulse {
  0% { box-shadow: 0 0 0 0 rgba(99,102,241,0.4); }
  70% { box-shadow: 0 0 0 10px rgba(99,102,241,0); }
  100% { box-shadow: 0 0 0 0 rgba(99,102,241,0); }
}
.node.rippling { animation: ripplePulse 0.4s ease-out; }

/* ═══════════════ INFO POPUP ═══════════════ */
.info-popup-overlay {
  display: none;
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  background: rgba(0,0,0,0.5);
  z-index: 300;
  align-items: center;
  justify-content: center;
}
.info-popup-overlay.visible { display: flex; }
.info-popup {
  background: var(--panel-bg);
  border: 1px solid var(--border);
  border-radius: 8px;
  padding: 20px;
  max-width: 420px;
  width: 90%;
  box-shadow: 0 16px 48px rgba(0,0,0,0.5);
}
.info-popup-header {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 12px;
  font-size: 15px;
  font-weight: 700;
}
.info-popup-header svg { width: 22px; height: 22px; }
.info-popup-close {
  margin-left: auto;
  background: none;
  border: none;
  color: var(--text-secondary);
  cursor: pointer;
  font-size: 18px;
  padding: 2px 6px;
  border-radius: 4px;
  display: flex;
  align-items: center;
  transition: color 0.15s, background 0.15s;
}
.info-popup-close:hover { color: var(--text-primary); background: var(--surface); }
.info-popup-close svg { width: 14px; height: 14px; }
.info-popup-body {
  font-size: 12px;
  line-height: 1.6;
  color: var(--text-secondary);
}
.info-popup-body strong { color: var(--text-primary); font-weight: 600; }
.info-popup-body p { margin: 0 0 8px; }
.info-popup-section {
  margin-bottom: 10px;
}
.info-popup-section-title {
  font-size: 10px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  color: var(--text-secondary);
  margin-bottom: 4px;
}
.info-popup-list {
  margin: 0;
  padding-left: 16px;
}
.info-popup-list li { margin-bottom: 3px; }

/* Dashboard info icon */
.dash-info-btn {
  background: none;
  border: none;
  color: var(--text-secondary);
  cursor: pointer;
  padding: 0;
  display: inline-flex;
  align-items: center;
  opacity: 0.4;
  transition: opacity 0.15s, color 0.15s;
}
.dash-info-btn:hover { opacity: 1; color: var(--accent); }
.dash-info-btn svg { width: 9px; height: 9px; }

/* Clickable category icon on nodes */
.node-icon.clickable { cursor: pointer; transition: transform 0.15s; z-index: 6; position: relative; }
.node-icon.clickable:hover { transform: scale(1.2); }
.legend-item.clickable { cursor: pointer; transition: color 0.15s; }
.legend-item.clickable:hover { color: var(--text-primary) !important; }

/* Connection Health Indicator */
.conn-health-indicator { margin-top: 4px; }
.conn-health-badge {
  display: inline-flex;
  align-items: center;
  gap: 6px;
  padding: 4px 10px;
  border-radius: 4px;
  font-size: 11px;
  font-weight: 600;
  margin-bottom: 6px;
}
.conn-health-dot {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  flex-shrink: 0;
}
.conn-health-desc {
  font-size: 11px;
  color: var(--text-secondary);
  line-height: 1.5;
  margin-bottom: 8px;
}
.conn-health-endpoints {
  display: flex;
  flex-direction: column;
  gap: 4px;
  margin-bottom: 6px;
}
.conn-health-ep {
  display: flex;
  align-items: center;
  gap: 6px;
  font-size: 11px;
  color: var(--text-primary);
  background: var(--surface);
  padding: 4px 8px;
  border-radius: 4px;
}
.conn-health-rule {
  font-size: 9px;
  color: var(--text-secondary);
  font-style: italic;
  opacity: 0.7;
}
/* ═══════════════ CONNECTION HEALTH DETAIL ═══════════════ */
.conn-health-info-btn {
  width: 18px; height: 18px;
  border: none; background: none; cursor: pointer;
  color: var(--text-secondary); padding: 0; margin-left: 4px;
  border-radius: 50%; display: flex; align-items: center; justify-content: center;
  flex-shrink: 0; transition: color 0.15s, background 0.15s;
}
.conn-health-info-btn:hover { color: var(--accent); background: var(--accent)15; }
.conn-health-info-btn svg { width: 14px; height: 14px; }
.conn-health-metrics {
  display: none; padding: 6px 8px; margin-top: 4px;
  background: var(--canvas-bg); border-radius: 4px;
  border: 1px solid var(--border);
}
.conn-health-metrics.visible { display: block; }
.conn-health-metric-row {
  display: flex; align-items: center; gap: 6px;
  font-size: 10px; padding: 2px 0;
}
.conn-health-metric-name {
  width: 90px; color: var(--text-secondary); flex-shrink: 0;
}
.conn-health-metric-bar {
  flex: 1; height: 4px; background: var(--surface);
  border-radius: 2px; overflow: hidden; position: relative;
}
.conn-health-metric-fill {
  height: 100%; border-radius: 2px; transition: width 0.3s ease;
}
.conn-health-metric-val {
  width: 28px; text-align: right; font-weight: 600; font-size: 10px; flex-shrink: 0;
}
.conn-health-metric-flag {
  font-size: 9px; font-weight: 600; width: 12px; text-align: center; flex-shrink: 0;
}
.conn-health-metrics-label {
  font-size: 9px; color: var(--text-secondary); margin-bottom: 4px;
  text-transform: uppercase; letter-spacing: 0.5px; font-weight: 600;
}

/* ═══════════════ COLLAPSIBLE SECTIONS ═══════════════ */
.insp-section-title.collapsible {
  cursor: pointer;
  user-select: none;
  transition: color 0.15s;
}
.insp-section-title.collapsible:hover { color: var(--text-primary); }
.section-chevron {
  margin-left: auto;
  display: inline-flex;
  transition: transform 0.2s ease;
}
.section-chevron svg { width: 10px; height: 10px; }
.section-chevron.open { transform: rotate(90deg); }
.insp-section-body.collapsed { display: none; }
/* Collapsible toolbox cards */
.card-header.collapsible {
  cursor: pointer;
  user-select: none;
  transition: opacity 0.15s;
}
.card-header.collapsible:hover { opacity: 1; }
.card-header.collapsible .section-chevron { margin-left: auto; }
.card-details.collapsed { display: none; }

/* ═══════════════ METRIC DELTAS ═══════════════ */
.metric-delta {
  font-size: 10px;
  font-weight: 600;
  margin-left: 4px;
  display: inline-block;
  animation: deltaFadeIn 0.3s ease;
}
@keyframes deltaFadeIn {
  from { opacity: 0; transform: translateY(-4px); }
  to { opacity: 1; transform: translateY(0); }
}
.metric-delta.positive { color: var(--green); }
.metric-delta.negative { color: var(--red); }
.metric-delta.neutral { color: var(--text-secondary); }

/* ═══════════════ ISSUES SUMMARY ═══════════════ */
.issues-badge {
  position: absolute;
  top: -4px;
  right: -4px;
  background: var(--red);
  color: white;
  font-size: 9px;
  font-weight: 700;
  width: 16px;
  height: 16px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  pointer-events: none;
  line-height: 1;
}
.issues-badge.warning { background: var(--yellow); color: #000; }
.issues-badge.hidden { display: none; }
.issues-dropdown {
  position: fixed;
  background: var(--panel-bg);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 4px;
  min-width: 300px;
  z-index: 150;
  box-shadow: 0 8px 24px rgba(0,0,0,0.4);
  display: none;
}
.issues-dropdown.visible { display: block; }
.issues-dropdown-title {
  font-size: 10px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  color: var(--text-secondary);
  padding: 6px 8px 4px;
  display: flex;
  align-items: center;
  gap: 4px;
}
.issues-dropdown-title svg { width: 12px; height: 12px; }
.issues-item {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 6px 8px;
  border-radius: 4px;
  cursor: pointer;
  transition: background 0.1s;
  font-size: 11px;
}
.issues-item:hover { background: var(--surface); }
.issues-item svg { width: 14px; height: 14px; }
.issues-item-dot {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  flex-shrink: 0;
}
.issues-item-name { font-weight: 500; flex: 1; }
.issues-item-detail { color: var(--text-secondary); font-size: 10px; }
.issues-none {
  padding: 12px 8px;
  text-align: center;
  color: var(--text-secondary);
  font-size: 11px;
}

/* ═══════════════ VARIANT HINT ═══════════════ */
.variant-hint {
  background: var(--surface);
  border: 1px solid var(--border);
  border-left: 3px solid var(--accent);
  border-radius: var(--radius);
  padding: 6px 8px;
  margin-top: 6px;
  font-size: 10px;
  color: var(--text-secondary);
  line-height: 1.4;
  display: flex;
  align-items: flex-start;
  gap: 4px;
}
.variant-hint svg { width: 12px; height: 12px; flex-shrink: 0; margin-top: 1px; }
.variant-hint strong { color: var(--accent); font-weight: 600; }
.variant-hint .delta-positive { color: var(--green); font-weight: 600; }
.variant-hint .delta-negative { color: var(--red); font-weight: 600; }

/* ═══════════════ METRIC THRESHOLD ═══════════════ */
.metric-threshold {
  position: absolute;
  top: -1px;
  bottom: -1px;
  width: 1px;
  background: var(--text-secondary);
  opacity: 0.25;
  z-index: 1;
}

/* ═══════════════ DASHBOARD CLICKABLE ═══════════════ */
.dash-bar-track.clickable { cursor: pointer; transition: opacity 0.15s; }
.dash-bar-track.clickable:hover { opacity: 0.85; }
.node.flash-highlight { animation: nodeFlash 0.8s ease; }
@keyframes nodeFlash {
  0%, 100% { box-shadow: 0 0 0 0 rgba(99,102,241,0); }
  50% { box-shadow: 0 0 20px 4px rgba(99,102,241,0.5); }
}
</style>
</head>
<body>

<!-- ═══════════════ TOP BAR ═══════════════ -->
<div class="top-bar">
  <div class="logo">
    <svg viewBox="0 0 18 18" fill="none" stroke="currentColor" stroke-width="1.5"><rect x="2" y="2" width="14" height="14" rx="3"/><circle cx="6" cy="7" r="1.5" fill="currentColor" stroke="none"/><circle cx="12" cy="7" r="1.5" fill="currentColor" stroke="none"/><path d="M6 7h6M9 7v5"/></svg>
    Archie
  </div>
  <div class="arch-name">Log-Based Stream Processing Architecture</div>
  <div class="tier-badge" onclick="showTierInfo()" style="cursor:pointer" title="Click for tier details">
    <svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M8 1l2.5 4.5L16 6.5l-4 3.5 1 5.5L8 13l-5 2.5 1-5.5-4-3.5 5.5-1z"/></svg>
    Tier 2 <span class="tier-hint">/ 3</span>
  </div>
  <div class="top-actions">
    <button class="top-btn" id="heatmapToggle" onclick="toggleHeatmap()">
      <svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><circle cx="8" cy="8" r="6"/><circle cx="8" cy="8" r="3" opacity="0.5"/><circle cx="8" cy="8" r="1" fill="currentColor" stroke="none"/></svg>
      Heatmap
    </button>
    <button class="top-btn" id="issuesBtn" onclick="toggleIssues()" style="position:relative">
      <svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M8 2L1 14h14z"/><path d="M8 6v4M8 12v.5"/></svg>
      Issues
      <span class="issues-badge hidden" id="issuesBadge">0</span>
    </button>
    <button class="top-btn" onclick="togglePanel('toolbox')">
      <svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><rect x="2" y="2" width="5" height="12" rx="1"/><rect x="9" y="2" width="5" height="5" rx="1"/><rect x="9" y="9" width="5" height="5" rx="1"/></svg>
      Toolbox
    </button>
    <button class="top-btn" onclick="togglePanel('inspector')">
      <svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><rect x="2" y="2" width="12" height="12" rx="1"/><line x1="8" y1="2" x2="8" y2="14"/><line x1="8" y1="6" x2="14" y2="6"/><line x1="8" y1="10" x2="14" y2="10"/></svg>
      Inspector
    </button>
    <button class="top-btn">
      <svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M3 14V9l5-7 5 7v5"/><path d="M6 14v-3h4v3"/></svg>
      Import
    </button>
    <button class="top-btn">
      <svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M4 2h8l2 3v9H2V5z"/><path d="M5 2v3h6V2"/><circle cx="8" cy="10" r="2"/></svg>
      Export
    </button>
  </div>
</div>

<!-- ═══════════════ MAIN LAYOUT ═══════════════ -->
<div class="main-layout">
  <!-- TOOLBOX -->
  <aside class="toolbox" id="toolbox">
    <div class="toolbox-title">
      <svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><rect x="2" y="2" width="5" height="12" rx="1"/><rect x="9" y="2" width="5" height="5" rx="1"/><rect x="9" y="9" width="5" height="5" rx="1"/></svg>
      Toolbox
    </div>
    <div class="toolbox-tabs">
      <button class="toolbox-tab active" onclick="switchTab(this,'components')">
        <svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><rect x="2" y="2" width="5" height="5" rx="1"/><rect x="9" y="2" width="5" height="5" rx="1"/><rect x="2" y="9" width="5" height="5" rx="1"/><rect x="9" y="9" width="5" height="5" rx="1"/></svg>
        Components
      </button>
      <button class="toolbox-tab" onclick="switchTab(this,'stacks')">
        <svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><rect x="3" y="2" width="10" height="3" rx="1"/><rect x="3" y="7" width="10" height="3" rx="1"/><rect x="3" y="12" width="10" height="3" rx="1"/></svg>
        Stacks
      </button>
      <button class="toolbox-tab" onclick="switchTab(this,'blueprints')">
        <svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 2h12v12H2z"/><path d="M5 5h6M5 8h6M5 11h3"/><circle cx="12" cy="11" r="1" fill="currentColor" stroke="none"/></svg>
        Blueprints
      </button>
    </div>
    <div class="toolbox-content" id="toolboxContent"></div>
  </aside>

  <!-- CANVAS -->
  <main class="canvas" id="canvas">
    <svg class="canvas-svg" id="flowSvg" style="z-index:0"></svg>
    <svg class="canvas-svg" id="canvasSvg"></svg>
    <div id="nodesContainer"></div>
    <!-- Legend -->
    <div class="canvas-legend" id="canvasLegend"></div>
    <div class="canvas-hint">
      <svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><circle cx="8" cy="8" r="6"/><path d="M8 5v3M8 10v1"/></svg>
      Click a component to inspect &middot; Toggle heatmap to see health overlay
    </div>
    <!-- DASHBOARD — inside canvas, at bottom -->
    <div class="dashboard" id="dashboard">
      <div class="dashboard-title">
        <svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><rect x="1" y="8" width="3" height="6" rx="0.5"/><rect x="5.5" y="5" width="3" height="9" rx="0.5"/><rect x="10" y="2" width="3" height="12" rx="0.5"/></svg>
        Architecture Health
        <button class="dash-expand-btn" onclick="toggleDashboardExpand()" title="Show contributing factors">
          <svg class="dash-expand-chevron" viewBox="0 0 10 10" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2.5 4L5 6.5L7.5 4"/></svg>
        </button>
      </div>
      <div class="dashboard-bars" id="dashboardBars"></div>
    </div>
    <!-- DASHBOARD EXPANDED OVERLAY -->
    <div class="dash-overlay" id="dashOverlay">
      <div class="dash-overlay-header">
        <svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><rect x="1" y="8" width="3" height="6" rx="0.5"/><rect x="5.5" y="5" width="3" height="9" rx="0.5"/><rect x="10" y="2" width="3" height="12" rx="0.5"/></svg>
        Architecture Health — 7 Metric Categories
        <button class="dash-overlay-close" onclick="toggleDashboardExpand()" title="Close details">&times;</button>
      </div>
      <div class="dash-overlay-grid" id="dashOverlayGrid"></div>
    </div>
  </main>

  <!-- INSPECTOR -->
  <aside class="inspector" id="inspector">
    <div class="inspector-header">
      <svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><rect x="2" y="2" width="12" height="12" rx="1"/><line x1="8" y1="2" x2="8" y2="14"/><line x1="8" y1="6" x2="14" y2="6"/><line x1="8" y1="10" x2="14" y2="10"/></svg>
      Inspector
    </div>
    <div class="inspector-content" id="inspectorContent">
      <div class="inspector-empty">
        <svg viewBox="0 0 32 32" fill="none" stroke="currentColor" stroke-width="1"><circle cx="16" cy="16" r="12"/><path d="M16 10v6M16 20v1"/></svg>
        Click a component on the canvas to see its details, metrics, and configuration variants.
      </div>
    </div>
  </aside>
</div>

<!-- ═══════════════ PROMPT OUTPUT ═══════════════ -->
<div class="prompt-section" id="promptSection">
  <button class="prompt-toggle" onclick="document.getElementById('promptSection').classList.toggle('open')">
    <svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><rect x="2" y="2" width="12" height="12" rx="2"/><path d="M5 6h6M5 8h6M5 10h4"/></svg>
    Prompt Output
  </button>
  <div class="prompt-body">
    <div class="prompt-text" id="promptText"></div>
    <button class="prompt-copy-btn" onclick="copyPrompt()">
      <svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><rect x="5" y="5" width="9" height="9" rx="1"/><path d="M5 11H3a1 1 0 01-1-1V3a1 1 0 011-1h7a1 1 0 011 1v2"/></svg>
      Copy Prompt
    </button>
  </div>
</div>

<!-- ═══════════════ INFO POPUP ═══════════════ -->
<div class="info-popup-overlay" id="infoPopupOverlay" onclick="if(event.target===this)hideInfoPopup()">
  <div class="info-popup">
    <div class="info-popup-header" id="infoPopupHeader"></div>
    <div class="info-popup-body" id="infoPopupBody"></div>
  </div>
</div>

<!-- Issues Dropdown (fixed position, placed by JS) -->
<div class="issues-dropdown" id="issuesDropdown"></div>

<script>
// ═══════════════ SVG ICONS ═══════════════
const ICONS = {
  // Category icons
  'Compute': '<svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><rect x="4" y="4" width="8" height="8" rx="1"/><line x1="6" y1="2" x2="6" y2="4"/><line x1="10" y1="2" x2="10" y2="4"/><line x1="6" y1="12" x2="6" y2="14"/><line x1="10" y1="12" x2="10" y2="14"/><line x1="2" y1="6" x2="4" y2="6"/><line x1="2" y1="10" x2="4" y2="10"/><line x1="12" y1="6" x2="14" y2="6"/><line x1="12" y1="10" x2="14" y2="10"/></svg>',
  'Data Storage': '<svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><ellipse cx="8" cy="4" rx="5" ry="2"/><path d="M3 4v8c0 1.1 2.24 2 5 2s5-.9 5-2V4"/><path d="M3 8c0 1.1 2.24 2 5 2s5-.9 5-2" opacity="0.5"/></svg>',
  'Caching': '<svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M9 1L4 9h4l-1 6 5-8H8l1-6z" stroke-linejoin="round"/></svg>',
  'Messaging': '<svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 3h12v8H6l-4 3V3z" stroke-linejoin="round"/></svg>',
  'Delivery/Network': '<svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><circle cx="8" cy="8" r="6"/><ellipse cx="8" cy="8" rx="3" ry="6"/><line x1="2" y1="8" x2="14" y2="8"/></svg>',
  'Real-Time': '<svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 8h2l2-4 2 8 2-5 2 3h2"/></svg>',
  'Auth/Security': '<svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M8 1L2 4v4c0 4 2.5 6 6 7 3.5-1 6-3 6-7V4L8 1z"/></svg>',
  'Monitoring': '<svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><rect x="2" y="2" width="12" height="12" rx="1"/><path d="M4 10l3-4 2 2 3-4"/></svg>',
  'Search': '<svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><circle cx="7" cy="7" r="4"/><line x1="10" y1="10" x2="14" y2="14"/></svg>',
  'DevOps': '<svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><circle cx="8" cy="8" r="2"/><path d="M8 2v2M8 12v2M2 8h2M12 8h2M3.8 3.8l1.4 1.4M10.8 10.8l1.4 1.4M3.8 12.2l1.4-1.4M10.8 5.2l1.4-1.4"/></svg>',
  // UI icons
  'is': '<svg viewBox="0 0 10 10" fill="none" stroke="currentColor" stroke-width="1.5"><circle cx="5" cy="5" r="3.5"/></svg>',
  'gain': '<svg viewBox="0 0 10 10" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M5 2v6M2 5l3-3 3 3"/></svg>',
  'cost': '<svg viewBox="0 0 10 10" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M5 8V2M2 5l3 3 3-3"/></svg>',
  'config': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.5"><circle cx="6" cy="6" r="2"/><path d="M6 1v2M6 9v2M1 6h2M9 6h2"/></svg>',
  'metrics': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.5"><rect x="1" y="6" width="2" height="5" rx="0.5"/><rect x="5" y="3" width="2" height="8" rx="0.5"/><rect x="9" y="1" width="2" height="10" rx="0.5"/></svg>',
  'pros': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.5"><circle cx="6" cy="6" r="4.5"/><path d="M4 6h4M6 4v4"/></svg>',
  'cons': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.5"><circle cx="6" cy="6" r="4.5"/><path d="M4 6h4"/></svg>',
  // Dashboard category icons
  'perf': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M2 10l3-5 2 2 3-5"/><path d="M9 2h2v2"/></svg>',
  'cost_dash': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><circle cx="6" cy="6" r="4"/><path d="M6 3v6M4.5 4.5h3M4.5 7.5h3"/></svg>',
  'rel': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M6 1L1.5 4v3.5c0 2.5 1.8 4 4.5 4.5 2.7-.5 4.5-2 4.5-4.5V4L6 1z"/></svg>',
  'ops': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><circle cx="6" cy="6" r="2"/><path d="M6 1v1.5M6 9.5V11M1 6h1.5M9.5 6H11M2.8 2.8l1 1M8.2 8.2l1 1M2.8 9.2l1-1M8.2 3.8l1-1"/></svg>',
  'scale': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M2 10V6l4-4 4 4v4"/></svg>',
  'strat': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><circle cx="6" cy="4" r="2"/><path d="M6 6v4M3 8h6"/></svg>',
  'dev_dash': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M4 3L1 6l3 3M8 3l3 3-3 3"/></svg>',
  // Data context icons
  'data_ctx': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><rect x="1" y="1" width="10" height="10" rx="1"/><path d="M4 4h4M4 6h4M4 8h2"/></svg>',
  'edit': '<svg viewBox="0 0 10 10" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M1 9l6-6 1 1-6 6z"/><path d="M6 3l1-1 2 2-1 1"/></svg>',
  'session': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><circle cx="6" cy="4" r="2.5"/><path d="M2 10c0-2.2 1.8-4 4-4s4 1.8 4 4"/></svg>',
  'counter': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M2 10V5l2-3 2 4 2-2 2 3v3"/></svg>',
  'cache_item': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><rect x="2" y="2" width="8" height="8" rx="1"/><path d="M5 4v4M4 7l1 1 1-1"/></svg>',
  'table': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><rect x="1" y="1" width="10" height="10" rx="1"/><line x1="1" y1="4" x2="11" y2="4"/><line x1="5" y1="4" x2="5" y2="11"/></svg>',
  'message': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M2 2h8v6H5l-3 2V2z"/></svg>',
  'endpoint': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M1 6h4M7 6h4"/><circle cx="6" cy="6" r="2"/></svg>',
  'route': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M2 2l8 8M2 5h3M7 9h3"/></svg>',
  'event': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M7 1L3 7h3l-1 4 4-6H6l1-4z"/></svg>',
  'receipt': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M2 6l3 3 5-5"/></svg>',
  'presence': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><circle cx="6" cy="6" r="3"/><circle cx="6" cy="6" r="1" fill="currentColor" stroke="none"/></svg>',
  'ssl': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><rect x="3" y="5" width="6" height="5" rx="1"/><path d="M4 5V4a2 2 0 014 0v1"/></svg>',
  'ratelimit': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><circle cx="6" cy="6" r="4.5"/><path d="M6 3v3l2 1"/></svg>',
  // Metric-specific icons
  'latency': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><circle cx="6" cy="6" r="4.5"/><path d="M6 3.5v3l2 1.5"/></svg>',
  'throughput': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M1 6h10M8 3l3 3-3 3"/></svg>',
  'cost_eff': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><circle cx="6" cy="6" r="4"/><path d="M6 3v6M4.5 4.5h3M4.5 7.5h3"/></svg>',
  'simplicity': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M3 4h6M3 6h6M3 8h4"/></svg>',
  'read_perf': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><circle cx="6" cy="5" r="3"/><path d="M1 5c2-3 8-3 10 0M1 5c2 3 8 3 10 0"/></svg>',
  'write_perf': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M2 10l7-7 1 1-7 7z"/><path d="M8 3l1-1 2 2-1 1"/></svg>',
  'scalability': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M2 10V6l4-4 4 4v4"/></svg>',
  'consistency': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M2 6h8M4 3h4M4 9h4"/></svg>',
  'ordering': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M3 3h6M3 6h4M3 9h2"/></svg>',
  'code': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M4 3L1 6l3 3"/><path d="M8 3l3 3-3 3"/><line x1="7" y1="2" x2="5" y2="10"/></svg>',
  // Connection property icons
  'protocol': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M2 6h8"/><circle cx="2" cy="6" r="1.5"/><circle cx="10" cy="6" r="1.5"/></svg>',
  'pattern': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M2 6h2l1-3 2 6 1-3h2"/></svg>',
  'speed': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><circle cx="6" cy="7" r="4"/><path d="M6 7l2-3"/><path d="M3 7h1M8 7h1"/></svg>',
  'coloc': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><rect x="1" y="3" width="10" height="6" rx="1"/><line x1="6" y1="3" x2="6" y2="9"/></svg>',
  'conn': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M1 6h3M8 6h3"/><rect x="4" y="3" width="4" height="6" rx="1"/></svg>',
  'arrow_right': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M2 6h8M7 3l3 3-3 3"/></svg>',
  'arrow_bidir': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M2 6h8M4 3L1 6l3 3M8 3l3 3-3 3"/></svg>',
  'info': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><circle cx="6" cy="6" r="5"/><path d="M6 5.5v3"/><circle cx="6" cy="3.5" r="0.5" fill="currentColor" stroke="none"/></svg>',
  'close': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M3 3l6 6M9 3l-6 6"/></svg>',
  'chevron': '<svg viewBox="0 0 10 10" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M3 2l4 3-4 3"/></svg>',
  // New metric icons
  'reliability': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M6 1L1.5 4v3.5c0 2.5 1.8 4 4.5 4.5 2.7-.5 4.5-2 4.5-4.5V4L6 1z"/></svg>',
  'portability': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M6 1v10M1 6h10"/><circle cx="6" cy="6" r="4.5"/><path d="M2.5 4h7M2.5 8h7"/></svg>',
  'learning': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M1 4.5l5-2.5 5 2.5-5 2.5z"/><path d="M2.5 5.5v3c0 1 1.5 1.5 3.5 1.5s3.5-.5 3.5-1.5v-3"/></svg>',
  'filter': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M1.5 2h9L7.5 6v3.5L4.5 11V6z"/></svg>'
};

// Map metric names to icon keys
const METRIC_ICON_MAP = {
  'Latency': 'latency', 'Throughput': 'throughput', 'Cost Efficiency': 'cost_eff',
  'Op. Simplicity': 'simplicity', 'Read Perf': 'read_perf', 'Write Perf': 'write_perf',
  'Scalability': 'scalability', 'Consistency': 'consistency', 'Ordering': 'ordering',
  'Reliability': 'reliability', 'Portability': 'portability', 'Learning Curve': 'learning'
};

// Metric explanations — why each component+variant scores the way it does
const METRIC_EXPLANATIONS = {
  'producer-api': {
    'express': {
      'Latency': { reason: 'Middleware chain is sequential with minimal overhead, but JSON serialization is not optimized.', factors: ['Each middleware adds ~0.1ms', 'Standard JSON.stringify on every response', 'Simple routing with acceptable lookup speed'] },
      'Throughput': { reason: 'Single-threaded event loop handles high concurrency, but lacks schema validation and serialization optimization.', factors: ['No compiled schema validators', 'JSON.stringify not optimized for repeated structures', 'Middleware overhead accumulates on hot paths'] },
      'Write Perf': { reason: 'Event publishing adds async overhead, but Express itself is not a bottleneck for writes to event log.', factors: ['Async HTTP response after event publish', 'Kafka producer batching helps throughput', 'No built-in backpressure handling'] },
      'Cost Efficiency': { reason: 'Minimal footprint, runs anywhere Node.js runs. Open source with no runtime license cost.', factors: ['Tiny package (~200KB installed)', 'Low memory baseline (~30MB idle)', 'No vendor lock-in or per-request pricing'] },
      'Op. Simplicity': { reason: 'Minimal un-opinionated framework. Easy to start but requires manual structuring and monitoring at scale.', factors: ['5 lines to a working server', 'Massive ecosystem of middleware', 'No enforced error handling or observability patterns'] },
      'Portability': { reason: 'Standard Node.js with MIT license. Runs anywhere Node.js runs, no proprietary APIs.', factors: ['MIT license, fully open source', 'Standard Node.js HTTP — no vendor extensions', 'Middleware patterns are widely understood'] },
      'Learning Curve': { reason: 'Minimal API surface. Most JavaScript developers can be productive within hours.', factors: ['Familiar JavaScript/Node.js patterns', 'Massive community with millions of tutorials', 'Simple middleware chain model'] }
    },
    'fastify': {
      'Latency': { reason: 'Compiles JSON schemas into optimized serializers at startup, reducing per-request overhead by 30-40%.', factors: ['fast-json-stringify compiles schemas ahead of time', 'Radix-tree router is faster than Express regex matching', 'Schema-based validation runs at native speed'] },
      'Throughput': { reason: 'Purpose-built for speed: 2-3x faster than Express in benchmarks due to schema compilation and routing.', factors: ['Compiled serialization avoids JSON.stringify overhead', 'Efficient routing via find-my-way radix tree', 'Lower per-request overhead in plugin system'] },
      'Write Perf': { reason: 'Schema validation catches malformed events before publish, reducing downstream error handling and retries.', factors: ['Schema validation rejects bad payloads early', 'Compiled serialization improves event encoding speed', 'Plugin hooks can add retry logic for event log writes'] },
      'Cost Efficiency': { reason: 'Higher throughput per instance means fewer servers needed for the same event ingestion load.', factors: ['2-3x throughput per instance = fewer instances', 'Comparable memory usage to Express', 'Open-source, no license cost'] },
      'Op. Simplicity': { reason: 'Plugin system and schema-first approach require upfront design but enforce consistency across API.', factors: ['Encapsulated plugin system has a learning curve', 'Schema-first requires upfront event schema design', 'Smaller community means fewer Stack Overflow answers'] },
      'Portability': { reason: 'Open-source, runs on standard Node.js. Plugin API is Fastify-specific but code is portable.', factors: ['MIT license, fully open source', 'Standard Node.js — no proprietary runtime', 'Plugin patterns differ from Express but are portable'] },
      'Learning Curve': { reason: 'Plugin system and schema-first approach require shifting from Express mental model, but patterns are well-documented.', factors: ['Plugin encapsulation model differs from middleware', 'Schema-first design requires upfront JSON Schema knowledge', 'Smaller community but high-quality official docs'] }
    },
    'go-api': {
      'Latency': { reason: 'Compiled binary with native concurrency (goroutines) delivers sub-millisecond overhead per request.', factors: ['Compiled to native code (no JIT or interpreter)', 'Goroutines handle concurrency without OS thread overhead', 'Standard library HTTP server is optimized'] },
      'Throughput': { reason: 'Go\'s lightweight goroutines handle tens of thousands of concurrent connections with minimal memory.', factors: ['Goroutines use ~2KB stack vs 1-2MB per OS thread', 'Native HTTP/2 multiplexing', 'Efficient channel-based event publishing'] },
      'Write Perf': { reason: 'Goroutines enable true parallel event publishing without blocking HTTP responses, maximizing throughput.', factors: ['Non-blocking event publish via goroutine channels', 'Kafka producer can batch across goroutines', 'Backpressure can be handled explicitly with buffered channels'] },
      'Cost Efficiency': { reason: 'Single compiled binary with low memory footprint. Fewer instances needed vs Node.js for same load.', factors: ['Lower memory per connection (~2KB goroutine stack)', 'Single binary deployment (no runtime dependencies)', 'Open-source, no license or runtime cost'] },
      'Op. Simplicity': { reason: 'Single binary deployment is simple, but error handling and concurrency bugs require Go expertise.', factors: ['Single binary with no runtime dependencies', 'Concurrency bugs (race conditions, deadlocks) are harder to debug', 'Fewer third-party libraries vs Node.js ecosystem'] },
      'Portability': { reason: 'Compiles to native binaries for any platform. BSD-licensed standard library, no vendor lock-in.', factors: ['Cross-compile for any OS/arch from single codebase', 'BSD license, fully open source', 'Standard library is platform-agnostic'] },
      'Learning Curve': { reason: 'Go syntax is simple, but concurrency patterns (goroutines, channels) and error handling require dedicated learning.', factors: ['Simple syntax, but different from JS/Python', 'Goroutine/channel patterns require new mental model', 'Explicit error handling (no exceptions) is verbose'] }
    }
  },
  'event-log': {
    'kafka': {
      'Throughput': { reason: 'Distributed append-only log with parallel writes across partitions delivers millions of events per second.', factors: ['Partition-level parallelism scales linearly', 'Batch compression reduces network overhead', 'Zero-copy I/O from disk to network socket'] },
      'Ordering': { reason: 'Strict ordering within each partition. Cross-partition ordering requires application-level coordination.', factors: ['Per-partition append-only log guarantees order', 'Partition key determines message placement', 'Global ordering requires single partition (sacrifices throughput)'] },
      'Reliability': { reason: 'Replication factor and ISR (in-sync replicas) ensure data survives broker failures with configurable durability.', factors: ['Replication factor (typically 3) protects against broker loss', 'In-sync replicas (ISR) ensure committed data is durable', 'Automatic leader election on broker failure'] },
      'Scalability': { reason: 'Add partitions and brokers to scale horizontally. Proven to handle trillions of events per day.', factors: ['Partition count drives consumer parallelism', 'Broker cluster distributes partitions across nodes', 'Rebalancing distributes load automatically'] },
      'Cost Efficiency': { reason: 'Open-source with low per-event cost, but requires operational expertise to run efficiently at scale.', factors: ['Apache 2.0 license, no per-event cost', 'Disk is cheaper than memory (vs in-memory queues)', 'Operational overhead for self-hosted clusters'] },
      'Op. Simplicity': { reason: 'Complex distributed system: ZooKeeper (or KRaft), broker tuning, partition management, and consumer group coordination.', factors: ['ZooKeeper dependency (KRaft mode simplifies but is newer)', 'Partition key design affects data distribution', 'Consumer group rebalancing causes processing pauses'] },
      'Portability': { reason: 'Open-source with wire protocol support from multiple providers (Confluent, MSK, Redpanda). Moderate portability.', factors: ['Apache 2.0 license, multiple providers', 'Kafka protocol is standardized', 'Managed services add proprietary features (Schema Registry, Connectors)'] },
      'Learning Curve': { reason: 'Steep learning curve: partitions, consumer groups, offsets, replication, ISR, and exactly-once semantics.', factors: ['Partition key design requires understanding data access patterns', 'Consumer group rebalancing behavior is complex', 'Exactly-once semantics require deep understanding of transactions'] }
    },
    'aws-kinesis': {
      'Throughput': { reason: 'Shard-based throughput with hard limits: 1MB/sec write per shard, requires manual resharding to scale.', factors: ['1MB/sec write limit per shard', 'Manual or on-demand resharding adds complexity', 'No automatic partition rebalancing like Kafka'] },
      'Ordering': { reason: 'Strict ordering within each shard via partition key. Cross-shard ordering is not guaranteed.', factors: ['Per-shard ordering via partition key hash', 'SequenceNumber provides total order within shard', 'Cross-shard ordering requires application logic'] },
      'Reliability': { reason: 'AWS-managed with 99.9% SLA, automatic replication across three AZs. No operator intervention needed.', factors: ['99.9% uptime SLA backed by AWS', 'Automatic 3-AZ replication', 'No manual failover or replica management'] },
      'Scalability': { reason: 'Scale by adding shards, but manual resharding or on-demand mode adds cost and latency during splits/merges.', factors: ['Provisioned mode requires manual resharding', 'On-demand mode auto-scales but costs 2-4x more', 'Resharding causes temporary read/write throttling'] },
      'Cost Efficiency': { reason: 'Pay-per-shard-hour plus data transfer. More expensive than self-hosted Kafka at high throughput.', factors: ['$0.015/shard-hour + $0.014/million PUT records', 'Data transfer charges add up quickly', 'On-demand mode is 2-4x more expensive than provisioned'] },
      'Op. Simplicity': { reason: 'Fully managed: no servers, auto-scaling (on-demand), built-in monitoring. Zero infrastructure ops.', factors: ['Zero server management', 'Built-in CloudWatch metrics and dashboards', 'Auto-scaling with on-demand mode'] },
      'Portability': { reason: 'Proprietary AWS service. Migration requires rewriting producer/consumer code and losing AWS integrations.', factors: ['Proprietary API (not Kafka-compatible)', 'Deep AWS integration (Lambda, Firehose, Analytics)', 'CloudWatch/X-Ray monitoring only works in AWS'] },
      'Learning Curve': { reason: 'Simpler than Kafka: no broker management, fewer tuning knobs, but shard-based model requires understanding.', factors: ['AWS Console provides guided setup', 'Shard-based model is simpler than partitions + consumer groups', 'IAM permissions model has its own learning curve'] }
    },
    'redpanda': {
      'Throughput': { reason: 'Kafka-compatible but rewritten in C++ with thread-per-core architecture, delivering 10x higher throughput per node.', factors: ['Thread-per-core (no context switching) maximizes CPU', 'C++ binary is faster than JVM-based Kafka', 'Inline raft consensus (no ZooKeeper) reduces latency'] },
      'Ordering': { reason: 'Kafka wire protocol compatible, so ordering semantics are identical: per-partition ordering only.', factors: ['Per-partition append-only log (same as Kafka)', 'Partition key determines message placement', 'Cross-partition ordering requires application logic'] },
      'Reliability': { reason: 'Built-in Raft consensus for metadata (no ZooKeeper), but replication semantics match Kafka (ISR model).', factors: ['Raft consensus for metadata (simpler than ZooKeeper)', 'ISR-based replication matches Kafka durability', 'Automatic leader election on node failure'] },
      'Scalability': { reason: 'Thread-per-core architecture scales better vertically (10x per node), reducing cluster size for same throughput.', factors: ['Fewer nodes needed vs Kafka for same load', 'Partition-level parallelism same as Kafka', 'Smaller clusters are easier to operate'] },
      'Cost Efficiency': { reason: 'Higher throughput per node means smaller clusters, but per-node hardware costs are higher (more CPU cores).', factors: ['10x throughput per node = smaller cluster', 'Requires high-core-count instances (thread-per-core)', 'Open-source (Apache 2.0) with managed cloud offering'] },
      'Op. Simplicity': { reason: 'No ZooKeeper dependency simplifies deployment, but partition tuning and Kafka compatibility require expertise.', factors: ['No ZooKeeper/KRaft — inline Raft consensus', 'Kafka-compatible API means Kafka knowledge applies', 'Smaller community vs Kafka'] },
      'Portability': { reason: 'Kafka wire protocol compatible, so clients can switch between Kafka and Redpanda with no code changes.', factors: ['Kafka wire protocol compatibility', 'Apache 2.0 license, open source', 'Managed Redpanda Cloud adds proprietary features'] },
      'Learning Curve': { reason: 'If you know Kafka, you know Redpanda. Kafka-compatible API means same concepts (partitions, consumer groups).', factors: ['Kafka knowledge transfers directly', 'No ZooKeeper simplifies mental model', 'C++ internals are opaque vs Kafka\'s JVM (harder to debug)'] }
    }
  },
  'stream-processor': {
    'simple-consumer': {
      'Latency': { reason: 'Direct Kafka consumer API with minimal abstraction. Latency is as low as your code allows.', factors: ['No framework overhead — raw consumer API', 'Processing latency depends on your code', 'No windowing or aggregation overhead'] },
      'Throughput': { reason: 'Single-threaded or manually parallelized. High throughput requires careful partition assignment and threading.', factors: ['Manual partition assignment and threading', 'No automatic parallelization or backpressure', 'Throughput limited by your code efficiency'] },
      'Scalability': { reason: 'Scales horizontally via consumer group, but state management and coordination are entirely manual.', factors: ['Consumer group provides partition rebalancing', 'No built-in state management (you use external DB)', 'Manual handling of rebalancing and offset commits'] },
      'Op. Simplicity': { reason: 'Simplest operational model: just a consumer process. No cluster, no state backend, no complex dependencies.', factors: ['Single process or manually managed fleet', 'No complex state backend or checkpointing', 'Easy to debug — it\'s just your code'] },
      'Reliability': { reason: 'Reliability depends entirely on your code. No built-in fault tolerance, exactly-once, or state recovery.', factors: ['Manual offset management (at-least-once or at-most-once)', 'No automatic failover or state recovery', 'Crash = restart from last committed offset (potential data loss)'] },
      'Portability': { reason: 'Standard Kafka consumer API. Runs anywhere, no framework lock-in. Easiest to port to other event logs.', factors: ['Standard Kafka consumer protocol', 'No framework-specific dependencies', 'Code is just consume-process-commit loop'] },
      'Learning Curve': { reason: 'Lowest learning curve: standard Kafka consumer API. No framework concepts, just read-process-commit.', factors: ['Kafka consumer API is straightforward', 'No windowing, aggregation, or state management abstractions', 'Full control but full responsibility for logic'] }
    },
    'kafka-streams': {
      'Latency': { reason: 'Library overhead adds latency: DSL/ProcessorAPI adds abstraction layers, windowing adds buffering time.', factors: ['DSL/ProcessorAPI adds processing overhead', 'Windowing introduces buffering delays (tumbling/hopping/session)', 'State store lookups add per-record latency'] },
      'Throughput': { reason: 'Higher-level DSL reduces boilerplate but adds overhead. Throughput is good but lower than raw consumer code.', factors: ['DSL abstraction layers reduce raw throughput', 'State store I/O (RocksDB) can bottleneck', 'Automatic parallelization helps but has overhead'] },
      'Scalability': { reason: 'Scales horizontally via consumer group with built-in state partitioning. No external cluster needed.', factors: ['Consumer group rebalancing distributes state partitions', 'Local state stores (RocksDB) scale with partitions', 'No external coordination cluster (vs Flink)'] },
      'Op. Simplicity': { reason: 'Library (not cluster) simplifies deployment, but state store management and rebalancing add complexity.', factors: ['Just a library — deploy as part of your app', 'State store recovery on rebalance adds startup time', 'Monitoring state store size and lag requires custom metrics'] },
      'Reliability': { reason: 'Exactly-once semantics via transactional writes to Kafka. State stores are fault-tolerant via changelog topics.', factors: ['Exactly-once processing (EOS) with idempotent producers', 'State stores backed by changelog topics (auto-recovery)', 'Rebalancing can cause processing pauses'] },
      'Portability': { reason: 'Kafka-specific library. Deep integration with Kafka topics, consumer groups, and transactions. Hard to port.', factors: ['Tightly coupled to Kafka (not portable to Kinesis/Redpanda)', 'DSL concepts (KTable, KStream) are Kafka Streams-specific', 'State stores use RocksDB + Kafka changelog topics'] },
      'Learning Curve': { reason: 'Moderate learning curve: DSL concepts (KStream, KTable, windowing) and exactly-once semantics require study.', factors: ['DSL abstractions (KStream, KTable, GlobalKTable) are new concepts', 'Windowing (tumbling, hopping, session) requires understanding', 'Exactly-once semantics and state store management are advanced'] }
    },
    'apache-flink': {
      'Latency': { reason: 'Low-latency stream processing (milliseconds) with event-time semantics, but operator overhead and checkpointing add delays.', factors: ['Event-time processing with watermarks adds buffering', 'Operator chain adds processing overhead', 'Checkpointing (for fault tolerance) adds periodic pauses'] },
      'Throughput': { reason: 'Massively parallel execution with automatic backpressure. Highest throughput of the three for complex pipelines.', factors: ['Distributed execution across task managers', 'Automatic backpressure prevents overload', 'Operator chaining and network buffers optimize throughput'] },
      'Scalability': { reason: 'Horizontally scalable with automatic state partitioning and redistribution. Proven at trillion-event scale.', factors: ['Task parallelism scales with available slots', 'State backend (RocksDB or in-memory) scales with cluster size', 'Automatic state redistribution on rescaling'] },
      'Op. Simplicity': { reason: 'Complex distributed system: JobManager, TaskManagers, state backend, checkpointing, and savepoints require deep expertise.', factors: ['Requires running Flink cluster (JobManager + TaskManagers)', 'State backend tuning (RocksDB vs in-memory) is complex', 'Checkpoint and savepoint management adds operational burden'] },
      'Reliability': { reason: 'Industry-leading exactly-once guarantees with checkpointing and state snapshots. Automatic failover and recovery.', factors: ['Exactly-once end-to-end with checkpointing', 'State snapshots (savepoints) enable versioned recovery', 'Automatic TaskManager failover with state recovery'] },
      'Portability': { reason: 'Open-source but complex deployment. Managed Flink (AWS Kinesis Analytics, Confluent Cloud) adds vendor lock-in.', factors: ['Apache 2.0 license, open source', 'Managed Flink services (AWS, Confluent) add proprietary features', 'DataStream API is Flink-specific (not portable)'] },
      'Learning Curve': { reason: 'Steepest learning curve: windowing, watermarks, event-time, state management, checkpointing, and cluster operations.', factors: ['Event-time semantics and watermarks are complex', 'Windowing (tumbling, sliding, session, custom) requires deep understanding', 'State backend tuning and checkpoint configuration are advanced topics'] }
    }
  },
  'primary-db': {
    'postgresql': {
      'Read Perf': { reason: 'B-tree indexes provide fast lookups, but join-heavy queries add overhead for complex materialized views.', factors: ['B-tree indexes are fast for key lookups', 'JOINs for complex views add query planning overhead', 'Index-only scans avoid heap lookups'] },
      'Write Perf': { reason: 'Single writes are fast with ACID guarantees, but bulk inserts from stream processors can bottleneck.', factors: ['WAL (Write-Ahead Log) ensures durability per write', 'Bulk inserts via COPY are faster than individual INSERTs', 'Index maintenance adds write overhead'] },
      'Consistency': { reason: 'Full ACID compliance with serializable isolation. Strongest consistency guarantees.', factors: ['ACID transactions prevent dirty reads/writes', 'Serializable isolation eliminates anomalies', 'Multi-version concurrency control (MVCC) reduces locking'] },
      'Scalability': { reason: 'Vertical scaling is strong, but horizontal write scaling requires sharding (Citus) or read replicas (read-only).', factors: ['Single-node writes scale vertically only', 'Read replicas scale read-heavy workloads', 'Sharding (Citus, manual) adds operational complexity'] },
      'Cost Efficiency': { reason: 'Open-source with no licensing cost. Runs on commodity hardware, but requires DBA expertise at scale.', factors: ['PostgreSQL License (MIT-style), no vendor cost', 'Lower hardware cost vs commercial RDBMS', 'Operational DBA expertise adds labor cost'] },
      'Op. Simplicity': { reason: 'Well-understood relational model, but vacuum, index tuning, and replication require PostgreSQL expertise.', factors: ['Standard SQL, widely understood', 'Vacuum and autovacuum tuning can be tricky', 'Replication setup (streaming, logical) requires experience'] },
      'Portability': { reason: 'Open-source with standard SQL. Runs on any platform. Schema and queries are highly portable.', factors: ['PostgreSQL License, fully open source', 'Standard SQL is portable to other RDBMS', 'PostgreSQL-specific features (JSONB, extensions) reduce portability'] },
      'Learning Curve': { reason: 'SQL is widely taught. PostgreSQL has excellent documentation and a massive community.', factors: ['SQL is the most widely-known query language', 'PostgreSQL docs are comprehensive', 'Tuning (vacuum, indexes, replication) requires deeper learning'] }
    },
    'mongodb': {
      'Read Perf': { reason: 'Document model eliminates JOINs for embedded data. Queries on nested fields can be slower without proper indexes.', factors: ['No JOINs needed for embedded documents', 'Index on nested fields requires compound indexes', 'Aggregation pipeline can be slower than SQL JOINs'] },
      'Write Perf': { reason: 'Schema-less writes are fast, but document updates rewrite the full document (write amplification for large docs).', factors: ['No schema validation on write (fast)', 'Full document rewrites even for small field changes', 'Embedded arrays can cause document growth and relocation'] },
      'Consistency': { reason: 'Single-document ACID since v4.0, but multi-document transactions have performance overhead.', factors: ['Single-document operations are atomic', 'Multi-document transactions add latency and complexity', 'Eventual consistency for replica set reads (unless read concern majority)'] },
      'Scalability': { reason: 'Horizontal sharding built-in. Scales writes by distributing documents across shard key ranges.', factors: ['Shard key distributes writes across cluster', 'Automatic balancing moves chunks between shards', 'Shard key choice is critical and hard to change'] },
      'Cost Efficiency': { reason: 'Open-source core (SSPL) with no licensing cost, but Atlas (managed) adds cost. Higher storage use vs normalized SQL.', factors: ['SSPL license (source-available, not OSI-approved)', 'Embedded documents use more storage than normalized SQL', 'Atlas managed service is expensive at scale'] },
      'Op. Simplicity': { reason: 'Flexible schema simplifies development, but shard key design and balancing require deep expertise.', factors: ['No schema migrations for flexible fields', 'Shard key design is hard to get right and hard to change', 'Monitoring chunk distribution and balancer activity adds complexity'] },
      'Portability': { reason: 'SSPL license limits hosting options. MongoDB query language is proprietary (not SQL). Hard to migrate away.', factors: ['SSPL license prevents cloud providers from offering managed MongoDB', 'MongoDB Query Language (MQL) is not SQL (portability barrier)', 'Document model schemas are application-specific'] },
      'Learning Curve': { reason: 'Document model is intuitive for developers, but aggregation pipeline and sharding have steep learning curves.', factors: ['Document model maps to application objects (easy)', 'Aggregation pipeline is powerful but complex', 'Shard key design and balancing require deep understanding'] }
    },
    'cockroachdb': {
      'Read Perf': { reason: 'Distributed SQL with multi-region reads. Locality-aware routing is fast, but cross-region reads add latency.', factors: ['Locality-aware routing minimizes cross-region hops', 'Follower reads reduce latency for read-heavy workloads', 'Cross-region queries add network overhead'] },
      'Write Perf': { reason: 'Distributed consensus (Raft) requires majority acknowledgment. Writes are slower than single-node PostgreSQL.', factors: ['Raft consensus requires majority quorum (2 of 3 replicas)', 'Cross-region writes add network round-trip latency', 'Write latency increases with geographic distribution'] },
      'Consistency': { reason: 'Serializable isolation by default across the entire cluster. Strongest distributed consistency guarantees.', factors: ['Serializable isolation via MVCC + clock synchronization', 'No dirty reads, no write skew anomalies', 'Globally consistent snapshots across regions'] },
      'Scalability': { reason: 'Horizontally scalable via automatic range-based sharding. Add nodes to scale reads and writes linearly.', factors: ['Automatic range splitting and rebalancing', 'Add nodes to scale throughput linearly', 'Multi-region replication distributes load geographically'] },
      'Cost Efficiency': { reason: 'Open-source core (Apache 2.0), but self-hosting requires expertise. CockroachDB Cloud is expensive.', factors: ['Apache 2.0 license, fully open source', 'Self-hosting requires distributed systems expertise', 'CockroachDB Cloud pricing is higher than RDS PostgreSQL'] },
      'Op. Simplicity': { reason: 'Automated operations (rebalancing, failover, backups), but multi-region setup and tuning are complex.', factors: ['Automatic rebalancing and failover', 'Multi-region topology requires careful planning', 'Clock synchronization (NTP) is critical for correctness'] },
      'Portability': { reason: 'PostgreSQL wire protocol compatible, but CockroachDB-specific features (multi-region, geo-partitioning) lock you in.', factors: ['PostgreSQL wire protocol (can use psql, ORMs)', 'CockroachDB-specific SQL extensions for multi-region', 'Migration from CockroachDB to PostgreSQL requires schema rewriting'] },
      'Learning Curve': { reason: 'PostgreSQL-compatible SQL, but distributed concepts (ranges, leases, multi-region) require deep learning.', factors: ['SQL syntax is PostgreSQL-compatible', 'Understanding ranges, leases, and replication requires study', 'Multi-region topology design is advanced'] }
    }
  },
  'search-index': {
    'elasticsearch': {
      'Read Perf': { reason: 'Inverted indexes provide sub-second full-text search across millions of documents with scoring and ranking.', factors: ['Inverted index structure optimized for text search', 'Cached filters and aggregations speed up repeated queries', 'Distributed shards enable parallel query execution'] },
      'Write Perf': { reason: 'Near-real-time indexing with configurable refresh interval (default 1s). Bulk API speeds up batch inserts.', factors: ['1-second refresh interval delays visibility', 'Bulk API batches writes for efficiency', 'Lucene segment merging adds background I/O overhead'] },
      'Scalability': { reason: 'Horizontally scalable via sharding. Add nodes to distribute index load and query parallelism.', factors: ['Shard-level parallelism for queries and indexing', 'Add nodes to scale both storage and compute', 'Replica shards provide read scalability'] },
      'Cost Efficiency': { reason: 'Open-source core (Apache 2.0), but resource-intensive: high memory and disk usage for index storage.', factors: ['Apache 2.0 license (Elastic Stack is SSPL now)', 'High memory requirements for caches and aggregations', 'SSD storage recommended for performance (adds cost)'] },
      'Op. Simplicity': { reason: 'Complex distributed system: cluster state, shard allocation, index tuning, and JVM heap management require expertise.', factors: ['Cluster health monitoring (green/yellow/red) is critical', 'Shard allocation and rebalancing require tuning', 'JVM heap size and GC tuning are advanced topics'] },
      'Portability': { reason: 'Proprietary REST API and query DSL. Migration away requires rewriting queries and index mappings.', factors: ['Query DSL is Elasticsearch-specific', 'Index mappings are not portable to other search engines', 'Elastic Stack integrations (Kibana, Logstash) create ecosystem lock-in'] },
      'Learning Curve': { reason: 'Steep learning curve: query DSL, index mappings, analyzers, aggregations, and cluster operations.', factors: ['Query DSL is complex and different from SQL', 'Index mapping design requires understanding analyzers and tokenizers', 'Cluster operations (sharding, replication, recovery) are advanced'] }
    },
    'meilisearch': {
      'Read Perf': { reason: 'Fast typo-tolerant search with ranking, but less sophisticated scoring than Elasticsearch.', factors: ['Typo tolerance and prefix matching out-of-the-box', 'In-memory index structures for fast queries', 'Simpler ranking algorithm than Elasticsearch (faster but less flexible)'] },
      'Write Perf': { reason: 'Near-instant indexing with incremental updates. Optimized for small to medium datasets.', factors: ['Incremental indexing updates in real-time', 'Smaller memory footprint than Elasticsearch', 'Performance degrades with very large datasets (>10M documents)'] },
      'Scalability': { reason: 'Single-node design with vertical scaling. No built-in clustering or sharding for horizontal scale.', factors: ['Single-node architecture limits horizontal scaling', 'Vertical scaling (more RAM) is primary approach', 'Performance optimized for datasets under 10M documents'] },
      'Cost Efficiency': { reason: 'Open-source (MIT) with low resource footprint. Runs on smaller instances than Elasticsearch.', factors: ['MIT license, fully open source', 'Lower memory requirements than Elasticsearch', 'Single binary deployment (no JVM overhead)'] },
      'Op. Simplicity': { reason: 'Simplest search engine to deploy: single binary, no cluster management, minimal configuration.', factors: ['Single binary with no dependencies', 'No cluster state or shard management', 'RESTful API with sensible defaults'] },
      'Portability': { reason: 'Open-source with simple REST API, but query syntax and ranking are Meilisearch-specific.', factors: ['MIT license, fully open source', 'REST API is straightforward but not standard', 'Ranking rules and filters are Meilisearch-specific'] },
      'Learning Curve': { reason: 'Lowest learning curve: simple REST API, sensible defaults, and excellent documentation for getting started.', factors: ['REST API is intuitive', 'Defaults work well out-of-the-box', 'Smaller feature set means less to learn'] }
    },
    'pg-fts': {
      'Read Perf': { reason: 'GIN indexes provide fast full-text search, but slower than dedicated search engines for large corpora.', factors: ['GIN indexes are optimized for text search', 'Slower than Elasticsearch for complex ranking and aggregations', 'Query planning overhead for complex ts_query expressions'] },
      'Write Perf': { reason: 'MVCC and WAL provide ACID guarantees, but full-text index updates add overhead to every write.', factors: ['GIN index maintenance adds write overhead', 'WAL ensures durability per write', 'Bulk inserts via COPY are faster than individual INSERTs'] },
      'Scalability': { reason: 'Vertical scaling only (unless using Citus/sharding). Read replicas help but don\'t scale writes.', factors: ['Single-node writes limit horizontal scaling', 'Read replicas scale read-heavy search workloads', 'Sharding (Citus) adds operational complexity'] },
      'Cost Efficiency': { reason: 'No additional cost if already using PostgreSQL. Eliminates separate search infrastructure.', factors: ['No additional licensing or infrastructure', 'Same operational cost as PostgreSQL', 'GIN indexes use more storage than B-tree'] },
      'Op. Simplicity': { reason: 'Simplest if already using PostgreSQL: no additional infrastructure, just SQL queries and GIN indexes.', factors: ['Standard SQL with tsvector and tsquery', 'No separate search cluster to manage', 'PostgreSQL expertise transfers directly'] },
      'Portability': { reason: 'PostgreSQL-specific (tsvector, tsquery, GIN indexes). Migration to other RDBMS requires rewriting.', factors: ['tsvector and tsquery are PostgreSQL-only', 'GIN indexes are PostgreSQL-specific', 'Full-text search syntax is not standard SQL'] },
      'Learning Curve': { reason: 'Moderate learning curve: tsvector, tsquery, GIN indexes, and text search configuration (dictionaries, parsers).', factors: ['tsvector/tsquery syntax is different from standard SQL', 'Text search configuration (dictionaries, parsers) requires learning', 'GIN index tuning is PostgreSQL-specific'] }
    }
  },
  'analytics-store': {
    'clickhouse': {
      'Read Perf': { reason: 'Columnar storage and vectorized query execution deliver sub-second analytics on billions of rows.', factors: ['Columnar format scans only needed columns', 'Vectorized execution processes data in batches (SIMD)', 'Compression reduces I/O (typical 10:1 compression ratio)'] },
      'Write Perf': { reason: 'Optimized for batch inserts. Small individual writes are inefficient (use batching or Buffer table).', factors: ['Bulk inserts create immutable parts (fast)', 'Small writes create many small parts (slow merge overhead)', 'Background merges consolidate parts (adds I/O load)'] },
      'Scalability': { reason: 'Horizontally scalable via sharding and replication. Linear scaling for analytics queries.', factors: ['Distributed tables shard data across nodes', 'Parallel query execution across shards', 'Replication provides HA and read scaling'] },
      'Cost Efficiency': { reason: 'Open-source (Apache 2.0) with extreme compression (10:1). Lower storage cost than row-based databases.', factors: ['Apache 2.0 license, fully open source', 'Columnar compression reduces storage by 10x', 'Efficient queries use less compute per result'] },
      'Op. Simplicity': { reason: 'Complex distributed system: ZooKeeper, table engines (MergeTree family), sharding, and replication require expertise.', factors: ['ZooKeeper dependency for distributed DDL', 'MergeTree engine family has many variants (ReplicatedMergeTree, etc.)', 'Shard key design is critical and hard to change'] },
      'Portability': { reason: 'Proprietary SQL dialect and table engines. Migration away requires rewriting schemas and queries.', factors: ['ClickHouse SQL dialect differs from standard SQL', 'MergeTree table engines are ClickHouse-specific', 'No standard JDBC/ODBC compatibility layer'] },
      'Learning Curve': { reason: 'Steep learning curve: MergeTree engines, distributed tables, ZooKeeper, and query optimization.', factors: ['MergeTree engine family has many variants and options', 'Distributed table setup requires understanding sharding and replication', 'Query optimization requires understanding columnar storage'] }
    },
    'bigquery': {
      'Read Perf': { reason: 'Serverless columnar engine with petabyte-scale parallelism. Sub-second queries on terabytes of data.', factors: ['Massively parallel execution across thousands of nodes', 'Columnar storage with automatic partitioning', 'In-memory shuffle for fast joins and aggregations'] },
      'Write Perf': { reason: 'Streaming inserts provide near-real-time availability. Batch loads via Cloud Storage are faster and cheaper.', factors: ['Streaming inserts available in ~1 second', 'Batch loads (CSV/JSON/Parquet) are more cost-effective', 'No index maintenance overhead (serverless)'] },
      'Scalability': { reason: 'Fully serverless: automatic scaling to petabyte-scale without manual configuration.', factors: ['Automatic scaling based on query complexity', 'No cluster sizing or shard management', 'Proven at petabyte scale (Google internal workloads)'] },
      'Cost Efficiency': { reason: 'Pay-per-query pricing ($5/TB scanned). Expensive for frequent queries or full-table scans without partitioning.', factors: ['$5 per TB scanned (no idle cost)', 'Partitioning and clustering reduce scan cost', 'Storage cost: $0.02/GB active, $0.01/GB long-term'] },
      'Op. Simplicity': { reason: 'Simplest analytics database: zero infrastructure, auto-scaling, built-in monitoring. Fully managed.', factors: ['Zero server or cluster management', 'Built-in monitoring and query profiling', 'Automatic partitioning and clustering'] },
      'Portability': { reason: 'Proprietary Google service. Standard SQL but GCP-locked. Migration requires rewriting pipelines and storage.', factors: ['Proprietary Google service (no self-hosted option)', 'Standard SQL but GCP integrations create lock-in', 'Data must live in Google Cloud Storage'] },
      'Learning Curve': { reason: 'Low learning curve: standard SQL with excellent documentation. Query optimization via partitioning is straightforward.', factors: ['Standard SQL (no proprietary extensions)', 'Excellent Google documentation and tutorials', 'Partitioning and clustering are simple to configure'] }
    },
    'timescaledb': {
      'Read Perf': { reason: 'Hypertables with automatic partitioning provide fast time-range queries, but slower than ClickHouse for wide scans.', factors: ['Time-based partitioning (chunks) speeds up range queries', 'Continuous aggregates pre-compute rollups', 'Column-oriented compression (via TimescaleDB extension)'] },
      'Write Perf': { reason: 'PostgreSQL MVCC with WAL provides ACID guarantees, but slower than ClickHouse for bulk inserts.', factors: ['ACID writes with WAL overhead', 'Automatic chunk creation on time boundaries', 'Bulk inserts via COPY are optimized'] },
      'Scalability': { reason: 'Single-node or distributed (multi-node). Distributed mode requires TimescaleDB Cloud or manual setup.', factors: ['Single-node scales vertically', 'Multi-node (distributed hypertables) requires enterprise/cloud', 'Read replicas scale read-heavy workloads'] },
      'Cost Efficiency': { reason: 'Open-source core (Apache 2.0), but distributed features require paid license or TimescaleDB Cloud.', factors: ['Apache 2.0 license for single-node', 'Distributed hypertables require Timescale Cloud or enterprise license', 'Lower storage cost than row-based PostgreSQL (compression)'] },
      'Op. Simplicity': { reason: 'PostgreSQL extension simplifies operations if already using PostgreSQL, but hypertable tuning is required.', factors: ['Installs as PostgreSQL extension (familiar ops)', 'Hypertable chunk sizing and retention policies require tuning', 'Continuous aggregates need maintenance policies'] },
      'Portability': { reason: 'PostgreSQL-based with standard SQL. Hypertables and continuous aggregates are TimescaleDB-specific.', factors: ['Standard SQL with PostgreSQL wire protocol', 'Hypertables and continuous aggregates are TimescaleDB-only', 'Migration to vanilla PostgreSQL requires schema rewriting'] },
      'Learning Curve': { reason: 'Moderate learning curve if you know PostgreSQL: hypertables, chunks, and continuous aggregates are new concepts.', factors: ['PostgreSQL knowledge transfers directly', 'Hypertable chunking and retention policies require learning', 'Continuous aggregates are powerful but complex to configure'] }
    }
  },
  'cache-layer': {
    'redis': {
      'Read Perf': { reason: 'In-memory storage delivers sub-millisecond reads (<1ms) for cached data. All data is RAM-resident.', factors: ['All data in RAM (no disk I/O)', 'Single-threaded request handling (no lock contention)', 'Optimized C codebase with minimal overhead'] },
      'Write Perf': { reason: 'In-memory writes are extremely fast, but persistence (AOF/RDB) adds durability overhead.', factors: ['In-memory writes complete in microseconds', 'AOF (Append-Only File) adds per-write disk I/O', 'RDB snapshots are periodic (background process)'] },
      'Scalability': { reason: 'Single-threaded limits vertical scaling. Redis Cluster provides horizontal sharding for multi-node scale.', factors: ['Single-threaded core (scales to one CPU core)', 'Redis Cluster shards keys across nodes', 'Read replicas scale read-heavy workloads'] },
      'Cost Efficiency': { reason: 'Open-source (BSD) with low overhead, but all data in RAM drives high memory cost at scale.', factors: ['BSD license, fully open source', 'RAM is more expensive than disk (vs disk-backed caches)', 'Managed Redis (ElastiCache, Redis Cloud) adds cost'] },
      'Op. Simplicity': { reason: 'Simple single-node deployment, but Redis Cluster and persistence configs add operational complexity.', factors: ['Single-node deployment is trivial (one binary)', 'Redis Cluster requires understanding hash slots and resharding', 'Persistence (AOF/RDB) tuning requires balancing durability vs performance'] },
      'Portability': { reason: 'Open-source with RESP protocol. Runs on any platform. Compatible with Memcached clients via protocol adapters.', factors: ['BSD license, fully open source', 'RESP protocol is widely supported', 'Runs on bare metal, VMs, containers, any cloud'] },
      'Learning Curve': { reason: 'Simple data structures (strings, lists, sets, hashes) with straightforward commands. Low learning curve.', factors: ['Simple key-value model with familiar data structures', 'Command documentation is excellent', 'Persistence and clustering add complexity'] }
    },
    'memcached': {
      'Read Perf': { reason: 'In-memory storage with multi-threaded request handling. Sub-millisecond reads with better concurrency than Redis.', factors: ['All data in RAM (no disk I/O)', 'Multi-threaded request handling (scales to multiple cores)', 'Optimized C codebase with minimal overhead'] },
      'Write Perf': { reason: 'Fastest cache writes: no persistence overhead, multi-threaded, pure in-memory.', factors: ['No persistence layer (ephemeral only)', 'Multi-threaded writes scale across cores', 'Simple LRU eviction (no complex data structures)'] },
      'Scalability': { reason: 'Multi-threaded core scales vertically better than Redis. Horizontal scaling via client-side consistent hashing.', factors: ['Multi-threaded core uses all CPU cores', 'Client-side consistent hashing distributes keys', 'No built-in clustering (clients manage sharding)'] },
      'Cost Efficiency': { reason: 'Open-source (BSD) with lowest overhead of the three. All data in RAM, but simpler than Redis.', factors: ['BSD license, fully open source', 'Lower memory overhead than Redis (simpler data structures)', 'RAM cost still high vs disk-backed caches'] },
      'Op. Simplicity': { reason: 'Simplest cache: no persistence, no clustering, no data structures. Just key-value with LRU eviction.', factors: ['Single binary with minimal config', 'No persistence configuration', 'Client-side sharding is simpler than Redis Cluster'] },
      'Portability': { reason: 'Open-source with simple ASCII protocol. Runs anywhere, widely supported by client libraries.', factors: ['BSD license, fully open source', 'ASCII protocol is simple and widely supported', 'Runs on bare metal, VMs, containers, any cloud'] },
      'Learning Curve': { reason: 'Lowest learning curve: simple key-value store with GET/SET/DELETE. No complex data structures.', factors: ['Simple key-value API (GET, SET, DELETE)', 'No data structures (just byte arrays)', 'LRU eviction is automatic and transparent'] }
    },
    'keydb': {
      'Read Perf': { reason: 'Multi-threaded Redis fork delivers 5x higher throughput than Redis on multi-core machines.', factors: ['Multi-threaded core uses all CPU cores', 'Redis-compatible commands and data structures', 'Same in-memory architecture as Redis'] },
      'Write Perf': { reason: 'Multi-threaded writes scale across cores. Persistence (AOF/RDB) overhead same as Redis.', factors: ['Multi-threaded writes outperform Redis 5x', 'AOF and RDB persistence options same as Redis', 'Active-replica writes enable multi-master replication'] },
      'Scalability': { reason: 'Multi-threaded core scales vertically better than Redis. Active-replica mode enables multi-master writes.', factors: ['Multi-threaded core scales to all CPU cores', 'Active-replica mode allows writes to all replicas', 'Clustering via Redis Cluster protocol'] },
      'Cost Efficiency': { reason: 'Open-source (BSD) with better CPU utilization than Redis. Fewer instances needed for same throughput.', factors: ['BSD license, fully open source', '5x throughput per instance = fewer instances needed', 'All data in RAM (same memory cost as Redis)'] },
      'Op. Simplicity': { reason: 'Drop-in Redis replacement with same config and commands. Active-replica adds complexity vs Redis.', factors: ['Redis-compatible (same config files and commands)', 'Active-replica mode requires understanding multi-master conflicts', 'Persistence and clustering same as Redis'] },
      'Portability': { reason: 'Redis-compatible fork with RESP protocol. Drop-in replacement for Redis with no code changes.', factors: ['BSD license, fully open source', 'RESP protocol compatible with Redis clients', 'Active-replica mode is KeyDB-specific'] },
      'Learning Curve': { reason: 'Same as Redis: if you know Redis, you know KeyDB. Active-replica adds new concepts.', factors: ['Redis-compatible API and data structures', 'Same command set and client libraries', 'Active-replica mode requires understanding multi-master writes'] }
    }
  },
};

// Component catalog — full list of available components grouped by category
const COMPONENT_CATALOG = {
  'Delivery/Network': [
    { name: 'Nginx', sub: 'Reverse proxy', connectsFrom: ['Clients', 'CDN'], connectsTo: ['Compute'] },
    { name: 'AWS API Gateway', sub: 'Managed gateway', connectsFrom: ['Clients'], connectsTo: ['Compute', 'Auth/Security'] },
    { name: 'Kong', sub: 'Plugin ecosystem', connectsFrom: ['Clients'], connectsTo: ['Compute', 'Auth/Security'] },
    { name: 'Traefik', sub: 'Cloud-native', connectsFrom: ['Clients', 'DevOps'], connectsTo: ['Compute'] },
    { name: 'HAProxy', sub: 'TCP/HTTP LB', connectsFrom: ['Clients'], connectsTo: ['Compute'] },
    { name: 'Envoy', sub: 'Service mesh', connectsFrom: ['Compute'], connectsTo: ['Compute'] },
    { name: 'CloudFront', sub: 'CDN + edge', connectsFrom: ['Clients'], connectsTo: ['Delivery/Network', 'Compute'] }
  ],
  'Compute': [
    { name: 'Node.js', sub: 'Event-driven I/O', connectsFrom: ['Delivery/Network'], connectsTo: ['Data Storage', 'Caching', 'Messaging', 'Search'] },
    { name: 'Go', sub: 'Concurrency', connectsFrom: ['Delivery/Network'], connectsTo: ['Data Storage', 'Caching', 'Messaging'] },
    { name: 'Python FastAPI', sub: 'ML-friendly', connectsFrom: ['Delivery/Network'], connectsTo: ['Data Storage', 'Caching', 'Messaging'] },
    { name: 'Rust Actix', sub: 'Max performance', connectsFrom: ['Delivery/Network'], connectsTo: ['Data Storage', 'Caching', 'Messaging'] },
    { name: 'Java Spring', sub: 'Enterprise', connectsFrom: ['Delivery/Network'], connectsTo: ['Data Storage', 'Caching', 'Messaging'] },
    { name: '.NET / C#', sub: 'Microsoft stack', connectsFrom: ['Delivery/Network'], connectsTo: ['Data Storage', 'Caching', 'Messaging'] }
  ],
  'Data Storage': [
    { name: 'PostgreSQL', sub: 'Relational ACID', connectsFrom: ['Compute'], connectsTo: ['Search', 'Monitoring'] },
    { name: 'MongoDB', sub: 'Document DB', connectsFrom: ['Compute'], connectsTo: ['Search'] },
    { name: 'MySQL', sub: 'Web standard', connectsFrom: ['Compute'], connectsTo: ['Search'] },
    { name: 'CockroachDB', sub: 'Distributed SQL', connectsFrom: ['Compute'], connectsTo: [] },
    { name: 'DynamoDB', sub: 'Serverless NoSQL', connectsFrom: ['Compute'], connectsTo: [] },
    { name: 'Cassandra', sub: 'Wide-column', connectsFrom: ['Compute'], connectsTo: [] }
  ],
  'Caching': [
    { name: 'Redis', sub: 'Data structures', connectsFrom: ['Compute'], connectsTo: ['Real-Time'] },
    { name: 'Memcached', sub: 'Simple cache', connectsFrom: ['Compute'], connectsTo: [] },
    { name: 'KeyDB', sub: 'Multi-thread Redis', connectsFrom: ['Compute'], connectsTo: [] },
    { name: 'Dragonfly', sub: 'Modern cache', connectsFrom: ['Compute'], connectsTo: [] },
    { name: 'Varnish', sub: 'HTTP cache', connectsFrom: ['Delivery/Network'], connectsTo: ['Compute'] }
  ],
  'Messaging': [
    { name: 'Kafka', sub: 'Event streaming', connectsFrom: ['Compute'], connectsTo: ['Compute', 'Data Storage', 'Real-Time'] },
    { name: 'RabbitMQ', sub: 'Classic MQ', connectsFrom: ['Compute'], connectsTo: ['Compute'] },
    { name: 'AWS SQS', sub: 'Managed queue', connectsFrom: ['Compute'], connectsTo: ['Compute'] },
    { name: 'Apache Pulsar', sub: 'Multi-tenant', connectsFrom: ['Compute'], connectsTo: ['Compute', 'Data Storage'] },
    { name: 'NATS', sub: 'Lightweight', connectsFrom: ['Compute'], connectsTo: ['Compute'] }
  ],
  'Real-Time': [
    { name: 'Socket.io', sub: 'WebSocket + fallback', connectsFrom: ['Compute', 'Caching'], connectsTo: ['Clients'] },
    { name: 'Pusher', sub: 'Managed realtime', connectsFrom: ['Compute'], connectsTo: ['Clients'] },
    { name: 'Ably', sub: 'Global pub/sub', connectsFrom: ['Compute'], connectsTo: ['Clients'] },
    { name: 'Centrifugo', sub: 'Self-hosted', connectsFrom: ['Compute', 'Messaging'], connectsTo: ['Clients'] },
    { name: 'SSE Endpoint', sub: 'Server-sent events', connectsFrom: ['Compute'], connectsTo: ['Clients'] }
  ],
  'Auth/Security': [
    { name: 'Auth0', sub: 'Managed auth', connectsFrom: ['Delivery/Network', 'Compute'], connectsTo: ['Data Storage'] },
    { name: 'Keycloak', sub: 'Self-hosted IAM', connectsFrom: ['Delivery/Network'], connectsTo: ['Data Storage'] },
    { name: 'AWS Cognito', sub: 'AWS auth', connectsFrom: ['Delivery/Network'], connectsTo: [] },
    { name: 'Custom JWT', sub: 'In-house', connectsFrom: ['Compute'], connectsTo: ['Caching', 'Data Storage'] },
    { name: 'OAuth2 Proxy', sub: 'Gateway auth', connectsFrom: ['Delivery/Network'], connectsTo: ['Compute'] }
  ],
  'Monitoring': [
    { name: 'Datadog', sub: 'Full observability', connectsFrom: ['All components'], connectsTo: ['Alerting'] },
    { name: 'Grafana + Prometheus', sub: 'OSS metrics', connectsFrom: ['Compute', 'Data Storage'], connectsTo: ['Alerting'] },
    { name: 'ELK Stack', sub: 'Log analytics', connectsFrom: ['All components'], connectsTo: [] },
    { name: 'Jaeger', sub: 'Distributed tracing', connectsFrom: ['Compute'], connectsTo: [] },
    { name: 'Sentry', sub: 'Error tracking', connectsFrom: ['Compute'], connectsTo: ['Alerting'] }
  ],
  'Search': [
    { name: 'Elasticsearch', sub: 'Full-text + analytics', connectsFrom: ['Data Storage', 'Compute'], connectsTo: ['Compute'] },
    { name: 'Algolia', sub: 'Managed search', connectsFrom: ['Compute'], connectsTo: [] },
    { name: 'Meilisearch', sub: 'Fast + simple', connectsFrom: ['Compute'], connectsTo: [] },
    { name: 'Typesense', sub: 'Typo-tolerant', connectsFrom: ['Compute'], connectsTo: [] }
  ],
  'DevOps': [
    { name: 'Docker', sub: 'Containers', connectsFrom: [], connectsTo: ['All components'] },
    { name: 'Kubernetes', sub: 'Orchestration', connectsFrom: ['DevOps'], connectsTo: ['All components'] },
    { name: 'Terraform', sub: 'IaC', connectsFrom: [], connectsTo: ['All components'] },
    { name: 'GitHub Actions', sub: 'CI/CD', connectsFrom: [], connectsTo: ['DevOps'] },
    { name: 'ArgoCD', sub: 'GitOps', connectsFrom: ['DevOps'], connectsTo: ['Compute'] }
  ]
};

// Swap icon SVG
const SWAP_ICON = '<svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M4 6l-2 2 2 2"/><path d="M2 8h10"/><path d="M12 10l2-2-2-2"/><path d="M14 8H4"/></svg>';

// Alternative components per category (for swap feature)
const ALTERNATIVES = {
  'producer-api': [
    { id: 'producer-api', name: 'Producer API', sub: 'Current' },
    { id: 'go-api', name: 'Go API', sub: 'Concurrency' },
    { id: 'python-api', name: 'Python FastAPI', sub: 'ML-friendly' },
    { id: 'rust-api', name: 'Rust Actix', sub: 'Max perf' }
  ],
  'event-log': [
    { id: 'event-log', name: 'Event Log', sub: 'Current' },
    { id: 'rabbitmq', name: 'RabbitMQ', sub: 'Classic MQ' },
    { id: 'aws-sqs', name: 'AWS SQS', sub: 'Managed queue' },
    { id: 'pulsar', name: 'Apache Pulsar', sub: 'Multi-tenant' }
  ],
  'stream-processor': [
    { id: 'stream-processor', name: 'Stream Processor', sub: 'Current' },
    { id: 'spark-streaming', name: 'Spark Streaming', sub: 'Batch-micro' },
    { id: 'aws-kinesis-analytics', name: 'AWS Kinesis Analytics', sub: 'Managed' },
    { id: 'apache-beam', name: 'Apache Beam', sub: 'Portable' }
  ],
  'primary-db': [
    { id: 'primary-db', name: 'Primary Database', sub: 'Current' },
    { id: 'mongodb', name: 'MongoDB', sub: 'Document DB' },
    { id: 'mysql', name: 'MySQL', sub: 'Web standard' },
    { id: 'cockroachdb', name: 'CockroachDB', sub: 'Distributed SQL' }
  ],
  'search-index': [
    { id: 'search-index', name: 'Search Index', sub: 'Current' },
    { id: 'algolia', name: 'Algolia', sub: 'Managed search' },
    { id: 'typesense', name: 'Typesense', sub: 'OSS fast' },
    { id: 'solr', name: 'Apache Solr', sub: 'Enterprise' }
  ],
  'analytics-store': [
    { id: 'analytics-store', name: 'Analytics Store', sub: 'Current' },
    { id: 'druid', name: 'Apache Druid', sub: 'Real-time' },
    { id: 'snowflake', name: 'Snowflake', sub: 'Cloud DW' },
    { id: 'redshift', name: 'AWS Redshift', sub: 'AWS DW' }
  ],
  'cache-layer': [
    { id: 'cache-layer', name: 'Cache Layer', sub: 'Current' },
    { id: 'memcached', name: 'Memcached', sub: 'Simple cache' },
    { id: 'keydb', name: 'KeyDB', sub: 'Multi-thread Redis' },
    { id: 'dragonfly', name: 'Dragonfly', sub: 'Modern cache' }
  ]
};

// Connection type icons (SVG path data for canvas labels, viewBox 0 0 10 10)
const CONN_TYPE_DEFS = {
  http: { color: '#06b6d4', name: 'HTTP/REST',
    path: 'M1,5H9M7,3l2,2-2,2M3,7L1,5l2-2' },
  database: { color: '#22c55e', name: 'Database',
    path: 'M3,2.5C3,1.5,7,1.5,7,2.5V7.5C7,8.5,3,8.5,3,7.5ZM3,5C3,6,7,6,7,5' },
  cache: { color: '#f97316', name: 'Cache',
    path: 'M6,1L3,5.5H5.2L4,9L7.5,4.5H5.3Z' },
  queue: { color: '#a855f7', name: 'Message Queue',
    path: 'M1,3H6L4.5,1.5M6,3L4.5,4.5M1,7H6L4.5,5.5M6,7L4.5,8.5' }
};

// Category info for info popups
const CATEGORY_INFO = {
  'Compute': {
    desc: 'Application servers that handle business logic, request processing, and service orchestration.',
    role: 'The brain of your architecture — processes requests, runs business rules, and coordinates between services.',
    examples: 'Node.js, Go, Python FastAPI, Java Spring, Rust Actix',
    key: 'Choose based on I/O patterns (event-driven vs thread-per-request), ecosystem needs, and team expertise.'
  },
  'Data Storage': {
    desc: 'Persistent databases for structured data with ACID guarantees and complex query support.',
    role: 'The long-term memory — stores everything that needs to survive restarts: users, messages, settings.',
    examples: 'PostgreSQL, MongoDB, MySQL, CockroachDB, DynamoDB',
    key: 'Choose based on data model (relational vs document), consistency needs, and scaling requirements.'
  },
  'Caching': {
    desc: 'In-memory stores for fast data access, session management, and reducing database load.',
    role: 'The short-term memory — holds frequently accessed data close to compute for sub-millisecond reads.',
    examples: 'Redis, Memcached, KeyDB, Dragonfly',
    key: 'Choose based on data structure needs, persistence requirements, and cache invalidation strategy.'
  },
  'Messaging': {
    desc: 'Event streaming and message queue platforms for asynchronous, decoupled communication.',
    role: 'The nervous system — carries events between services without requiring them to be online simultaneously.',
    examples: 'Kafka, RabbitMQ, AWS SQS, Apache Pulsar, NATS',
    key: 'Choose based on ordering guarantees, throughput needs, and whether you need replay capability.'
  },
  'Delivery/Network': {
    desc: 'API gateways, load balancers, CDNs, and reverse proxies that route and manage network traffic.',
    role: 'The front door — manages how traffic enters your system, applies security policies, and distributes load.',
    examples: 'Nginx, AWS API Gateway, Kong, Traefik, CloudFront',
    key: 'Choose based on routing complexity, auth integration, and whether you need managed vs self-hosted.'
  },
  'Real-Time': {
    desc: 'WebSocket servers, SSE endpoints, and pub/sub systems for live data delivery to clients.',
    role: 'The live wire — pushes updates to clients instantly without polling, enabling chat and live dashboards.',
    examples: 'Socket.io, Pusher, Ably, Centrifugo, Phoenix Channels',
    key: 'Choose based on connection scale, message fanout patterns, and client platform requirements.'
  },
  'Auth/Security': {
    desc: 'Authentication providers, authorization engines, and security infrastructure.',
    role: 'The gatekeeper — verifies identity, enforces permissions, and protects data at rest and in transit.',
    examples: 'Auth0, Keycloak, AWS Cognito, custom JWT, OAuth2',
    key: 'Choose based on auth flow complexity (SSO, MFA), compliance requirements, and team capacity.'
  },
  'Monitoring': {
    desc: 'Observability platforms for metrics, logging, tracing, and alerting across your infrastructure.',
    role: 'The eyes and ears — shows what is happening, what broke, and why, before users report it.',
    examples: 'Datadog, Grafana, Prometheus, ELK Stack, Jaeger',
    key: 'Choose based on data volume, retention needs, and whether you need metrics, logs, traces, or all three.'
  },
  'Search': {
    desc: 'Full-text search engines and indexing systems for fast, relevance-ranked content retrieval.',
    role: 'The librarian — indexes your data for fast, fuzzy, and relevance-ranked search experiences.',
    examples: 'Elasticsearch, Algolia, Meilisearch, Typesense',
    key: 'Choose based on index size, query complexity, and whether you need analytics alongside search.'
  },
  'DevOps': {
    desc: 'CI/CD pipelines, container orchestration, infrastructure-as-code, and deployment automation.',
    role: 'The assembly line — automates building, testing, deploying, and scaling your applications.',
    examples: 'Docker, Kubernetes, Terraform, GitHub Actions, ArgoCD',
    key: 'Choose based on deployment frequency, infrastructure complexity, and team DevOps maturity.'
  }
};

// Dashboard metric category info
const DASHBOARD_INFO = {
  perf: {
    name: 'Performance',
    desc: 'How fast your architecture responds to requests and processes data.',
    metrics: 'Latency (p50/p95/p99), throughput (req/s), response time, TTFB',
    impact: 'Directly affects user experience. Every 100ms of added latency reduces conversion by ~1%. Bottlenecks cascade through connected components.',
    improve: 'Cache hot paths, reduce network hops, use connection pooling, optimize queries, consider async processing.'
  },
  cost: {
    name: 'Cost',
    desc: 'Total cost of ownership including infrastructure, licensing, operations, and engineering time.',
    metrics: 'Monthly infra cost, cost per request, license fees, maintenance hours',
    impact: 'Determines sustainability. Over-provisioning wastes money; under-provisioning causes outages.',
    improve: 'Right-size instances, use spot instances, optimize queries, consider serverless for bursty workloads.'
  },
  rel: {
    name: 'Reliability',
    desc: 'How well your architecture handles failures, maintains uptime, and recovers from incidents.',
    metrics: 'Uptime (99.9% = 8.7h/yr downtime), MTTR, error rates, failover success rate',
    impact: 'Trust and reputation. Every minute of downtime erodes user confidence. Requires redundancy.',
    improve: 'Add redundancy, circuit breakers, health checks, graceful degradation, chaos engineering.'
  },
  ops: {
    name: 'Operational Complexity',
    desc: 'How easy your architecture is to deploy, monitor, debug, and maintain day-to-day.',
    metrics: 'Deploy frequency, change failure rate, MTTR, on-call burden, runbook coverage',
    impact: 'Team productivity and morale. Complex ops mean slower shipping and more incidents.',
    improve: 'Automate deployments, improve observability, reduce moving parts, use managed services.'
  },
  scale: {
    name: 'Scalability',
    desc: 'How well your architecture grows with increasing users, data, and traffic.',
    metrics: 'Max concurrent users, horizontal scale factor, auto-scaling responsiveness',
    impact: 'Growth readiness. Non-scalable architectures force expensive rewrites.',
    improve: 'Stateless services, horizontal scaling, data partitioning, caching layers, queue decoupling.'
  },
  strat: {
    name: 'Strategic Flexibility',
    desc: 'Long-term flexibility including vendor independence, technology currency, and hiring.',
    metrics: 'Vendor lock-in score, technology freshness, community size, migration effort',
    impact: 'Future-proofing. Strategic debt accumulates silently until you need to pivot or hire.',
    improve: 'Use open standards, abstract vendor APIs, keep dependencies current, invest in documentation.'
  },
  dev: {
    name: 'Developer Experience',
    desc: 'How productive and happy developers are when building features and fixing bugs.',
    metrics: 'New dev setup time, build time, test feedback loop, debugging ease, docs quality',
    impact: 'Velocity and retention. Good DX means faster shipping. Bad DX means slow onboarding and turnover.',
    improve: 'Fast local setup, comprehensive tests, good docs, consistent patterns, fast CI/CD feedback.'
  }
};

// Code patterns per component + variant — shows WHAT changes at implementation level
const CODE_PATTERNS = {
  'producer-api': {
    'express': `<span class="cm">// Express: simple event publishing</span>
app.<span class="fn">post</span>(<span class="str">'/events'</span>, <span class="kw">async</span> (req, res) => {
  <span class="kw">await</span> kafka.<span class="fn">send</span>({
    topic: <span class="str">'user-events'</span>,
    messages: [{ value: <span class="fn">JSON.stringify</span>(req.body) }]
  })
  res.<span class="fn">json</span>({ ok: <span class="num">true</span> })
})`,
    'fastify': `<span class="cm">// Fastify: schema validation before Kafka</span>
fastify.<span class="fn">post</span>(<span class="str">'/events'</span>, {
  schema: { body: eventSchema }
}, <span class="kw">async</span> (req) => {
  <span class="kw">await</span> kafka.<span class="fn">send</span>({
    topic: <span class="str">'user-events'</span>,
    messages: [{ value: <span class="fn">JSON.stringify</span>(req.body) }]
  })
  <span class="kw">return</span> { ok: <span class="num">true</span> }
})`,
    'go-api': `<span class="cm">// Go: concurrent event ingestion</span>
<span class="kw">func</span> <span class="fn">handleEvent</span>(w http.ResponseWriter, r *http.Request) {
  <span class="kw">var</span> event Event
  json.<span class="fn">NewDecoder</span>(r.Body).<span class="fn">Decode</span>(&event)
  producer.<span class="fn">Produce</span>(&kafka.Message{
    TopicPartition: kafka.TopicPartition{Topic: &topic},
    Value: jsonBytes,
  }, <span class="num">nil</span>)
}`
  },
  'event-log': {
    'kafka': `<span class="cm">// Kafka: distributed event log</span>
<span class="kw">const</span> producer = kafka.<span class="fn">producer</span>()
<span class="kw">await</span> producer.<span class="fn">send</span>({
  topic: <span class="str">'events'</span>,
  messages: [
    { key: userId, value: eventData }
  ],
  acks: <span class="num">-1</span>  <span class="cm">// wait for all replicas</span>
})`,
    'aws-kinesis': `<span class="cm">// Kinesis: managed streaming</span>
<span class="kw">await</span> kinesis.<span class="fn">putRecord</span>({
  StreamName: <span class="str">'events'</span>,
  Data: <span class="fn">Buffer.from</span>(<span class="fn">JSON.stringify</span>(event)),
  PartitionKey: userId
})
<span class="cm">// Auto-scaling, no ops</span>
<span class="cm">// But AWS-only, higher cost</span>`,
    'redpanda': `<span class="cm">// Redpanda: Kafka-compatible, faster</span>
<span class="kw">const</span> producer = kafka.<span class="fn">producer</span>()
<span class="kw">await</span> producer.<span class="fn">send</span>({
  topic: <span class="str">'events'</span>,
  messages: [{ key: userId, value: data }]
})
<span class="cm">// Same API, better perf, simpler ops</span>`
  },
  'stream-processor': {
    'simple-consumer': `<span class="cm">// Simple Consumer: manual loop</span>
<span class="kw">await</span> consumer.<span class="fn">run</span>({
  <span class="fn">eachMessage</span>: <span class="kw">async</span> ({ message }) => {
    <span class="kw">const</span> event = <span class="fn">JSON.parse</span>(message.value)
    <span class="kw">await</span> db.<span class="fn">insert</span>(event)
    <span class="kw">await</span> search.<span class="fn">index</span>(event)
  }
})
<span class="cm">// Simple but limited transforms</span>`,
    'kafka-streams': `<span class="cm">// Kafka Streams: stateful processing</span>
<span class="kw">const</span> builder = <span class="kw">new</span> <span class="fn">StreamsBuilder</span>()
builder.<span class="fn">stream</span>(<span class="str">'events'</span>)
  .<span class="fn">groupByKey</span>()
  .<span class="fn">windowedBy</span>(<span class="fn">TimeWindows.of</span>(<span class="num">60000</span>))
  .<span class="fn">aggregate</span>(() => <span class="num">0</span>, (k, v, agg) => agg + <span class="num">1</span>)
  .<span class="fn">toStream</span>().<span class="fn">to</span>(<span class="str">'counts'</span>)`,
    'apache-flink': `<span class="cm">// Flink: full-featured stream processing</span>
env.<span class="fn">addSource</span>(<span class="kw">new</span> <span class="fn">FlinkKafkaConsumer</span>(<span class="str">'events'</span>, schema, props))
  .<span class="fn">keyBy</span>(event -> event.userId)
  .<span class="fn">window</span>(<span class="fn">TumblingEventTimeWindows.of</span>(<span class="fn">Time.minutes</span>(<span class="num">5</span>)))
  .<span class="fn">aggregate</span>(<span class="kw">new</span> <span class="fn">CountAggregator</span>())
  .<span class="fn">addSink</span>(<span class="kw">new</span> <span class="fn">JdbcSink</span>(sql))`
  },
  'primary-db': {
    'postgresql': `<span class="cm">-- PostgreSQL: relational integrity</span>
<span class="kw">INSERT INTO</span> processed_events
  (event_id, user_id, event_type, payload, processed_at)
<span class="kw">VALUES</span> (<span class="num">$1</span>, <span class="num">$2</span>, <span class="num">$3</span>, <span class="num">$4</span>, <span class="fn">NOW</span>())
<span class="kw">ON CONFLICT</span> (event_id) <span class="kw">DO NOTHING</span>
<span class="cm">-- Idempotent upsert for exactly-once</span>`,
    'mongodb': `<span class="cm">// MongoDB: document-oriented events</span>
<span class="kw">await</span> db.events.<span class="fn">insertOne</span>({
  eventId: event.id,
  userId: event.userId,
  type: event.type,
  payload: event.data,
  processedAt: <span class="kw">new</span> <span class="fn">Date</span>()
})
<span class="cm">// Flexible schema, fast writes</span>`,
    'cockroachdb': `<span class="cm">-- CockroachDB: distributed SQL</span>
<span class="kw">INSERT INTO</span> events
  (event_id, user_id, event_type, payload)
<span class="kw">VALUES</span> (<span class="num">$1</span>, <span class="num">$2</span>, <span class="num">$3</span>, <span class="num">$4</span>)
<span class="kw">ON CONFLICT</span> (event_id) <span class="kw">DO NOTHING</span>
<span class="cm">-- Global distribution, strong consistency</span>`
  },
  'search-index': {
    'elasticsearch': `<span class="cm">// Elasticsearch: full-text + analytics</span>
<span class="kw">await</span> esClient.<span class="fn">index</span>({
  index: <span class="str">'events'</span>,
  id: event.id,
  body: {
    userId: event.userId,
    text: event.text,
    timestamp: event.ts
  }
})`,
    'meilisearch': `<span class="cm">// Meilisearch: typo-tolerant search</span>
<span class="kw">await</span> meili.index(<span class="str">'events'</span>).<span class="fn">addDocuments</span>([{
  id: event.id,
  userId: event.userId,
  text: event.text,
  timestamp: event.ts
}])
<span class="cm">// Simpler ops, faster indexing</span>`,
    'pg-fts': `<span class="cm">-- PostgreSQL FTS: built-in search</span>
<span class="kw">UPDATE</span> events
<span class="kw">SET</span> search_vector = <span class="fn">to_tsvector</span>(<span class="str">'english'</span>, text)
<span class="kw">WHERE</span> event_id = <span class="num">$1</span>;
<span class="cm">-- No extra service, good-enough search</span>`
  },
  'analytics-store': {
    'clickhouse': `<span class="cm">-- ClickHouse: columnar analytics</span>
<span class="kw">INSERT INTO</span> event_metrics
  (timestamp, user_id, event_type, count)
<span class="kw">VALUES</span>
  (<span class="fn">now</span>(), <span class="num">$1</span>, <span class="num">$2</span>, <span class="num">1</span>)
<span class="cm">-- Blazing fast aggregations</span>`,
    'bigquery': `<span class="cm">-- BigQuery: serverless analytics</span>
<span class="kw">INSERT INTO</span> <span class="str">\`project.dataset.events\`</span>
  (timestamp, user_id, event_type, payload)
<span class="kw">VALUES</span>
  (<span class="fn">CURRENT_TIMESTAMP</span>(), @userId, @type, @payload)
<span class="cm">-- Managed, scales to petabytes</span>`,
    'timescaledb': `<span class="cm">-- TimescaleDB: time-series PostgreSQL</span>
<span class="kw">INSERT INTO</span> event_timeseries
  (timestamp, user_id, event_type, value)
<span class="kw">VALUES</span> (<span class="fn">NOW</span>(), <span class="num">$1</span>, <span class="num">$2</span>, <span class="num">$3</span>)
<span class="cm">-- Hypertables auto-partition by time</span>`
  },
  'cache-layer': {
    'redis': `<span class="cm">// Redis: cache derived views</span>
<span class="kw">await</span> redis.<span class="fn">set</span>(
  <span class="str">\`user:\${userId}:summary\`</span>,
  <span class="fn">JSON.stringify</span>(summary),
  <span class="str">'EX'</span>, <span class="num">300</span>
)
<span class="cm">// Fast reads for aggregated data</span>`,
    'memcached': `<span class="cm">// Memcached: simple KV cache</span>
<span class="kw">await</span> memcached.<span class="fn">set</span>(
  <span class="str">\`user:\${userId}:summary\`</span>,
  summary,
  <span class="num">300</span>
)
<span class="cm">// Simpler, lower memory overhead</span>`,
    'keydb': `<span class="cm">// KeyDB: multi-threaded Redis</span>
<span class="kw">await</span> keydb.<span class="fn">set</span>(
  <span class="str">\`user:\${userId}:summary\`</span>,
  <span class="fn">JSON.stringify</span>(summary),
  <span class="str">'EX'</span>, <span class="num">300</span>
)
<span class="cm">// Higher throughput, Redis-compatible</span>`
  }
};

// ═══════════════ DATA ═══════════════
const CATEGORIES = {
  'Compute':          { color: '#3b82f6', shape: 'rectangle' },
  'Data Storage':     { color: '#22c55e', shape: 'cylinder' },
  'Caching':          { color: '#f97316', shape: 'pill' },
  'Messaging':        { color: '#a855f7', shape: 'hexish' },
  'Delivery/Network': { color: '#06b6d4', shape: 'stadium' },
  'Real-Time':        { color: '#ec4899', shape: 'pill' },
  'Auth/Security':    { color: '#ef4444', shape: 'rectangle' },
  'Monitoring':       { color: '#eab308', shape: 'stadium' },
  'Search':           { color: '#14b8a6', shape: 'pill' },
  'DevOps':           { color: '#8b5cf6', shape: 'hexish' }
};

const components = {
  'producer-api': {
    name: 'Producer API', category: 'Compute',
    is: 'HTTP API that ingests events and publishes them to the event log',
    gain: 'Simple interface for event ingestion, schema validation',
    cost: 'Additional hop before Kafka, potential bottleneck',
    position: { x: 330, y: 20 },
    heatStatus: 'green',
    connections: [
      { target: 'event-log', label: 'Produce', connType: 'queue', protocol: 'Kafka Binary Protocol (TCP:9092)', pattern: 'Produce → Ack',
        direction: 'Producer API publishes validated events to the event log',
        role: 'Event Producer',
        summary: 'The API validates incoming events against a schema and publishes them to Kafka. It handles batching, compression, and retries. The API returns immediately after Kafka acks the write, making it a fast ingestion layer.',
        latency: '~5-15ms (validation + Kafka ack)', colocatable: false,
        code: `<span class="cm">// Producer API → Kafka</span>\n<span class="kw">await</span> kafka.<span class="fn">send</span>({\n  topic: <span class="str">'events'</span>,\n  messages: [{\n    key: event.userId,\n    value: <span class="fn">JSON.stringify</span>(event),\n    headers: { schema: <span class="str">'v1'</span> }\n  }],\n  acks: <span class="num">-1</span>\n})` }
    ],
    dataContext: [
      { name: 'Event Ingestion', icon: 'endpoint', behaviors: {
        'express': { fit: 'good', note: 'Simple routing, manual validation' },
        'fastify': { fit: 'great', note: 'Schema-first validation, 2-3x faster' },
        'go-api': { fit: 'great', note: 'High concurrency, compiled performance' }
      }},
      { name: 'Batch Upload', icon: 'table', behaviors: {
        'express': { fit: 'tradeoff', note: 'Single-threaded, limited batch throughput' },
        'fastify': { fit: 'good', note: 'Async batching, schema validation' },
        'go-api': { fit: 'great', note: 'Goroutines handle large batches efficiently' }
      }},
      { name: 'Schema Validation', icon: 'route', behaviors: {
        'express': { fit: 'tradeoff', note: 'Manual validation via middleware' },
        'fastify': { fit: 'great', note: 'Compiled JSON Schema validation' },
        'go-api': { fit: 'good', note: 'Struct validation, type safety' }
      }}
    ],
    variants: {
      'express': { label: 'Express.js',
        metrics: { 'Latency': 75, 'Throughput': 65, 'Cost Efficiency': 85, 'Op. Simplicity': 88, 'Reliability': 68, 'Portability': 95, 'Learning Curve': 90 },
        pros: ['Minimal footprint','Easy to learn','Huge ecosystem'], cons: ['Single-threaded','No built-in validation'] },
      'fastify': { label: 'Fastify',
        metrics: { 'Latency': 88, 'Throughput': 82, 'Cost Efficiency': 88, 'Op. Simplicity': 75, 'Reliability': 75, 'Portability': 92, 'Learning Curve': 72 },
        pros: ['2-3x faster','Schema validation built-in','Plugin system'], cons: ['Smaller community','Different patterns'] },
      'go-api': { label: 'Go API',
        metrics: { 'Latency': 92, 'Throughput': 90, 'Cost Efficiency': 90, 'Op. Simplicity': 60, 'Reliability': 85, 'Portability': 88, 'Learning Curve': 50 },
        pros: ['Compiled performance','High concurrency','Type safety'], cons: ['More boilerplate','Steeper learning curve'] }
    },
    currentVariant: 'express'
  },
  'event-log': {
    name: 'Event Log', category: 'Messaging',
    is: 'Distributed append-only log that stores all events durably',
    gain: 'Replayable history, decouples producers from consumers, high throughput',
    cost: 'Operational complexity, storage costs, learning curve',
    position: { x: 330, y: 170 },
    heatStatus: 'yellow',
    connections: [
      { target: 'stream-processor', label: 'Subscribe', connType: 'queue', protocol: 'Kafka Binary Protocol (TCP:9092)', pattern: 'Poll → Batch Consume',
        direction: 'Event log delivers event stream to processor for transformation',
        role: 'Event Source',
        summary: 'The stream processor subscribes to event topics and consumes events in batches. Kafka tracks consumer offsets, enabling exactly-once processing semantics. The processor can replay events by resetting offsets.',
        latency: '~10-50ms (batch poll interval)', colocatable: false,
        code: `<span class="cm">// Kafka → Stream Processor</span>\n<span class="kw">const</span> consumer = kafka.<span class="fn">consumer</span>({\n  groupId: <span class="str">'stream-processor'</span>\n})\n<span class="kw">await</span> consumer.<span class="fn">subscribe</span>({\n  topic: <span class="str">'events'</span>,\n  fromBeginning: <span class="num">false</span>\n})\n<span class="kw">await</span> consumer.<span class="fn">run</span>({\n  <span class="fn">eachBatch</span>: <span class="kw">async</span> ({ batch }) => {\n    <span class="kw">await</span> <span class="fn">processBatch</span>(batch)\n  }\n})` }
    ],
    dataContext: [
      { name: 'Event Topics', icon: 'message', behaviors: {
        'kafka': { fit: 'great', note: 'Distributed, replicated, partitioned topics' },
        'aws-kinesis': { fit: 'good', note: 'Managed streams, auto-scaling, AWS-only' },
        'redpanda': { fit: 'great', note: 'Kafka-compatible, faster, simpler ops' }
      }},
      { name: 'Retention Policies', icon: 'table', behaviors: {
        'kafka': { fit: 'great', note: 'Time/size-based retention, log compaction' },
        'aws-kinesis': { fit: 'tradeoff', note: 'Max 7-day retention, no compaction' },
        'redpanda': { fit: 'great', note: 'Same retention options as Kafka' }
      }},
      { name: 'Consumer Groups', icon: 'route', behaviors: {
        'kafka': { fit: 'great', note: 'Parallel consumption, auto-rebalancing' },
        'aws-kinesis': { fit: 'good', note: 'Enhanced fan-out for parallel consumers' },
        'redpanda': { fit: 'great', note: 'Kafka-compatible consumer groups' }
      }}
    ],
    variants: {
      'kafka': { label: 'Apache Kafka',
        metrics: { 'Throughput': 90, 'Ordering': 90, 'Scalability': 92, 'Op. Simplicity': 40, 'Reliability': 88, 'Portability': 85, 'Learning Curve': 35 },
        pros: ['High throughput','Replayable log','Battle-tested'], cons: ['Operational complexity','Steep learning curve'] },
      'aws-kinesis': { label: 'AWS Kinesis',
        metrics: { 'Throughput': 75, 'Ordering': 88, 'Scalability': 85, 'Op. Simplicity': 85, 'Reliability': 90, 'Portability': 25, 'Learning Curve': 65 },
        pros: ['Fully managed','Auto-scaling','Simple setup'], cons: ['AWS lock-in','Higher cost','7-day retention limit'] },
      'redpanda': { label: 'Redpanda',
        metrics: { 'Throughput': 95, 'Ordering': 90, 'Scalability': 90, 'Op. Simplicity': 70, 'Reliability': 85, 'Portability': 88, 'Learning Curve': 45 },
        pros: ['Kafka-compatible','10x faster','Simpler ops'], cons: ['Newer project','Smaller ecosystem'] }
    },
    currentVariant: 'kafka'
  },
  'stream-processor': {
    name: 'Stream Processor', category: 'Compute',
    is: 'Consumes events from the log, transforms them, and writes to downstream stores',
    gain: 'Real-time processing, stateful transforms, exactly-once semantics',
    cost: 'Complexity varies dramatically: simple consumer vs full stream engine',
    position: { x: 330, y: 320 },
    heatStatus: 'red',
    connections: [
      { target: 'primary-db', label: 'Write', connType: 'database', protocol: 'PostgreSQL Wire Protocol (TCP:5432)', pattern: 'Batch INSERT',
        direction: 'Stream processor writes processed events to primary database',
        role: 'Materialized View Writer',
        summary: 'The processor maintains materialized views in the database by writing transformed events. Batch writes optimize throughput. Idempotent upserts ensure exactly-once semantics.',
        latency: '~10-100ms (batch dependent)', colocatable: false,
        code: `<span class="cm">// Stream processor → Primary DB</span>\n<span class="kw">await</span> db.<span class="fn">query</span>(\n  <span class="str">'INSERT INTO events (id, data) VALUES ($1, $2) ON CONFLICT DO NOTHING'</span>,\n  [event.id, event.data]\n)` },
      { target: 'search-index', label: 'Index', connType: 'http', protocol: 'HTTP/JSON', pattern: 'Bulk Index',
        direction: 'Stream processor updates search index in real-time',
        role: 'Search Indexer',
        summary: 'The processor extracts searchable fields from events and bulk-indexes them into Elasticsearch. This keeps search fresh without querying the database.',
        latency: '~50-200ms (bulk index)', colocatable: false,
        code: `<span class="cm">// Stream processor → Search</span>\n<span class="kw">await</span> esClient.<span class="fn">bulk</span>({\n  body: events.<span class="fn">flatMap</span>(e => [\n    { index: { _index: <span class="str">'events'</span>, _id: e.id } },\n    { text: e.text, userId: e.userId }\n  ])\n})` },
      { target: 'analytics-store', label: 'Aggregate', connType: 'database', protocol: 'ClickHouse HTTP', pattern: 'Batch INSERT',
        direction: 'Stream processor writes aggregated metrics to analytics store',
        role: 'Metrics Aggregator',
        summary: 'The processor runs windowed aggregations (5-minute counts, hourly rollups) and writes them to ClickHouse. This enables fast dashboard queries without scanning raw events.',
        latency: '~100-500ms (batch aggregation)', colocatable: false,
        code: `<span class="cm">// Stream processor → Analytics</span>\n<span class="kw">await</span> clickhouse.<span class="fn">insert</span>(\n  <span class="str">'INSERT INTO event_metrics (timestamp, user_id, count) VALUES'</span>,\n  aggregated.<span class="fn">map</span>(m => [m.ts, m.userId, m.count])\n)` },
      { target: 'cache-layer', label: 'Update', connType: 'cache', protocol: 'RESP (TCP:6379)', pattern: 'SET with TTL',
        direction: 'Stream processor updates cache with derived views',
        role: 'Cache Warmer',
        summary: 'The processor pre-computes expensive views (user summaries, leaderboards) and writes them to Redis. This makes reads instant for the API without database queries.',
        latency: '~1-5ms (Redis write)', colocatable: false,
        code: `<span class="cm">// Stream processor → Cache</span>\n<span class="kw">await</span> redis.<span class="fn">set</span>(\n  <span class="str">\`user:\${userId}:summary\`</span>,\n  <span class="fn">JSON.stringify</span>(summary),\n  <span class="str">'EX'</span>, <span class="num">3600</span>\n)` }
    ],
    dataContext: [
      { name: 'Event Transformations', icon: 'endpoint', behaviors: {
        'simple-consumer': { fit: 'good', note: 'Manual loops, good for simple filters/maps' },
        'kafka-streams': { fit: 'great', note: 'DSL for map/filter/join, stateful processing' },
        'apache-flink': { fit: 'great', note: 'Full SQL, CEP, complex event processing' }
      }},
      { name: 'Windowed Aggregations', icon: 'table', behaviors: {
        'simple-consumer': { fit: 'poor', note: 'Manual state management, hard to get right' },
        'kafka-streams': { fit: 'great', note: 'Built-in windowing (tumbling, hopping, session)' },
        'apache-flink': { fit: 'great', note: 'Advanced windowing, watermarks, late data handling' }
      }},
      { name: 'Join Operations', icon: 'route', behaviors: {
        'simple-consumer': { fit: 'poor', note: 'Manual cross-stream joins are complex' },
        'kafka-streams': { fit: 'good', note: 'Stream-stream and stream-table joins' },
        'apache-flink': { fit: 'great', note: 'Temporal joins, interval joins, lookup joins' }
      }}
    ],
    variants: {
      'simple-consumer': { label: 'Simple Consumer',
        metrics: { 'Latency': 85, 'Throughput': 50, 'Scalability': 40, 'Cost Efficiency': 90, 'Op. Simplicity': 88, 'Reliability': 65, 'Learning Curve': 85 },
        pros: ['Easy to understand','Low ops burden','Simple debugging'], cons: ['Limited transforms','Manual state management','No exactly-once'] },
      'kafka-streams': { label: 'Kafka Streams',
        metrics: { 'Latency': 75, 'Throughput': 78, 'Scalability': 70, 'Cost Efficiency': 80, 'Op. Simplicity': 65, 'Reliability': 75, 'Learning Curve': 55 },
        pros: ['Stateful processing','No cluster needed','Kafka-native'], cons: ['Kafka-only','Less mature than Flink','Limited SQL support'] },
      'apache-flink': { label: 'Apache Flink',
        metrics: { 'Latency': 60, 'Throughput': 95, 'Scalability': 92, 'Cost Efficiency': 40, 'Op. Simplicity': 25, 'Reliability': 88, 'Learning Curve': 20 },
        pros: ['Full-featured','Exactly-once','Advanced windowing'], cons: ['Heavy ops burden','Cluster required','Steep learning curve'] }
    },
    currentVariant: 'simple-consumer'
  },
  'primary-db': {
    name: 'Primary Database', category: 'Data Storage',
    is: 'Relational database storing processed events and materialized views',
    gain: 'ACID guarantees, complex queries, mature ecosystem',
    cost: 'Write throughput limits, schema migrations, tuning complexity',
    position: { x: 80, y: 470 },
    heatStatus: 'green',
    connections: [],
    dataContext: [
      { name: 'Entity Records', icon: 'session', behaviors: {
        'postgresql': { fit: 'great', note: 'Full relational model, JSONB for flexibility' },
        'mongodb': { fit: 'good', note: 'Document model, fast writes, eventual consistency' },
        'cockroachdb': { fit: 'great', note: 'Distributed SQL, horizontal scaling' }
      }},
      { name: 'Transaction Log', icon: 'message', behaviors: {
        'postgresql': { fit: 'great', note: 'WAL for crash recovery, streaming replication' },
        'mongodb': { fit: 'good', note: 'OpLog for replication, no ACID across docs' },
        'cockroachdb': { fit: 'great', note: 'Raft consensus, distributed transactions' }
      }},
      { name: 'Materialized Views', icon: 'table', behaviors: {
        'postgresql': { fit: 'great', note: 'Native materialized views, refresh strategies' },
        'mongodb': { fit: 'tradeoff', note: 'Aggregation pipeline, manual refresh logic' },
        'cockroachdb': { fit: 'good', note: 'Experimental materialized views' }
      }}
    ],
    variants: {
      'postgresql': { label: 'PostgreSQL',
        metrics: { 'Read Perf': 78, 'Write Perf': 75, 'Scalability': 60, 'Consistency': 95, 'Op. Simplicity': 75, 'Reliability': 92, 'Learning Curve': 80 },
        pros: ['ACID compliance','Mature ecosystem','JSONB support'], cons: ['Vertical scaling limits','Manual replication setup'] },
      'mongodb': { label: 'MongoDB',
        metrics: { 'Read Perf': 82, 'Write Perf': 88, 'Scalability': 85, 'Consistency': 70, 'Op. Simplicity': 80, 'Reliability': 85, 'Learning Curve': 75 },
        pros: ['Flexible schema','High write throughput','Horizontal scaling'], cons: ['Weaker consistency','No joins across collections'] },
      'cockroachdb': { label: 'CockroachDB',
        metrics: { 'Read Perf': 75, 'Write Perf': 70, 'Scalability': 90, 'Consistency': 95, 'Op. Simplicity': 65, 'Reliability': 90, 'Learning Curve': 65 },
        pros: ['Distributed SQL','Strong consistency','Auto-sharding'], cons: ['Higher latency','More complex ops'] }
    },
    currentVariant: 'postgresql'
  },
  'search-index': {
    name: 'Search Index', category: 'Search',
    is: 'Full-text search engine for finding events by content',
    gain: 'Fast text search, faceted queries, relevance ranking',
    cost: 'Index storage overhead, eventual consistency, ops complexity',
    position: { x: 260, y: 470 },
    heatStatus: 'yellow',
    connections: [],
    dataContext: [
      { name: 'Full-Text Search', icon: 'message', behaviors: {
        'elasticsearch': { fit: 'great', note: 'Lucene-based, powerful query DSL' },
        'meilisearch': { fit: 'good', note: 'Typo-tolerant, simpler ops, faster indexing' },
        'pg-fts': { fit: 'tradeoff', note: 'Built into PostgreSQL, limited features' }
      }},
      { name: 'Faceted Queries', icon: 'table', behaviors: {
        'elasticsearch': { fit: 'great', note: 'Aggregations for facets, analytics' },
        'meilisearch': { fit: 'good', note: 'Faceted search with filters' },
        'pg-fts': { fit: 'poor', note: 'Manual GROUP BY queries, slow' }
      }},
      { name: 'Autocomplete', icon: 'route', behaviors: {
        'elasticsearch': { fit: 'great', note: 'Edge n-grams, completion suggester' },
        'meilisearch': { fit: 'great', note: 'Prefix search out of the box' },
        'pg-fts': { fit: 'tradeoff', note: 'Trigram indexes, not real-time' }
      }}
    ],
    variants: {
      'elasticsearch': { label: 'Elasticsearch',
        metrics: { 'Read Perf': 85, 'Write Perf': 75, 'Scalability': 88, 'Cost Efficiency': 50, 'Op. Simplicity': 45, 'Reliability': 82, 'Learning Curve': 50 },
        pros: ['Powerful query DSL','Aggregations','Mature ecosystem'], cons: ['Heavy resource usage','Complex ops','Expensive at scale'] },
      'meilisearch': { label: 'Meilisearch',
        metrics: { 'Read Perf': 90, 'Write Perf': 88, 'Scalability': 70, 'Cost Efficiency': 80, 'Op. Simplicity': 85, 'Reliability': 78, 'Learning Curve': 85 },
        pros: ['Typo-tolerant','Fast indexing','Simple setup'], cons: ['Fewer features','Smaller community'] },
      'pg-fts': { label: 'PostgreSQL FTS',
        metrics: { 'Read Perf': 65, 'Write Perf': 70, 'Scalability': 55, 'Cost Efficiency': 95, 'Op. Simplicity': 75, 'Reliability': 90, 'Learning Curve': 70 },
        pros: ['No extra service','Built into DB','ACID guarantees'], cons: ['Limited features','Slower search','Less relevant ranking'] }
    },
    currentVariant: 'elasticsearch'
  },
  'analytics-store': {
    name: 'Analytics Store', category: 'Data Storage',
    is: 'Columnar database optimized for aggregation queries and dashboards',
    gain: 'Blazing fast aggregations, time-series analysis, compression',
    cost: 'Slower inserts, limited update support, eventual consistency',
    position: { x: 440, y: 470 },
    heatStatus: 'green',
    connections: [],
    dataContext: [
      { name: 'Time-Series Metrics', icon: 'message', behaviors: {
        'clickhouse': { fit: 'great', note: 'Purpose-built for time-series, custom compression' },
        'bigquery': { fit: 'good', note: 'Serverless, auto-scaling, expensive for small workloads' },
        'timescaledb': { fit: 'great', note: 'PostgreSQL extension, hypertables for time-series' }
      }},
      { name: 'Aggregation Queries', icon: 'table', behaviors: {
        'clickhouse': { fit: 'great', note: 'Vectorized execution, parallel aggregations' },
        'bigquery': { fit: 'great', note: 'Petabyte-scale, SQL standard' },
        'timescaledb': { fit: 'good', note: 'PostgreSQL aggregations, slower than ClickHouse' }
      }},
      { name: 'Dashboards', icon: 'route', behaviors: {
        'clickhouse': { fit: 'great', note: 'Sub-second queries on billions of rows' },
        'bigquery': { fit: 'good', note: 'Fast but costs per query scanned' },
        'timescaledb': { fit: 'good', note: 'Good for smaller datasets, familiar SQL' }
      }}
    ],
    variants: {
      'clickhouse': { label: 'ClickHouse',
        metrics: { 'Read Perf': 95, 'Write Perf': 80, 'Scalability': 92, 'Cost Efficiency': 85, 'Op. Simplicity': 55, 'Reliability': 85, 'Learning Curve': 60 },
        pros: ['Extremely fast aggregations','High compression','Cost-effective'], cons: ['No updates/deletes','Manual cluster mgmt'] },
      'bigquery': { label: 'BigQuery',
        metrics: { 'Read Perf': 90, 'Write Perf': 85, 'Scalability': 95, 'Cost Efficiency': 60, 'Op. Simplicity': 90, 'Reliability': 92, 'Learning Curve': 75 },
        pros: ['Fully managed','Petabyte-scale','Standard SQL'], cons: ['Pay per scan','GCP lock-in','Costs add up'] },
      'timescaledb': { label: 'TimescaleDB',
        metrics: { 'Read Perf': 75, 'Write Perf': 78, 'Scalability': 70, 'Cost Efficiency': 88, 'Op. Simplicity': 80, 'Reliability': 88, 'Learning Curve': 85 },
        pros: ['PostgreSQL compatibility','Familiar SQL','ACID support'], cons: ['Slower than ClickHouse','Limited parallelism'] }
    },
    currentVariant: 'clickhouse'
  },
  'cache-layer': {
    name: 'Cache Layer', category: 'Caching',
    is: 'In-memory cache for derived views and hot data',
    gain: 'Sub-millisecond reads, reduces database load, TTL-based expiry',
    cost: 'Memory cost, cache invalidation complexity, data loss on failure',
    position: { x: 600, y: 470 },
    heatStatus: 'green',
    connections: [],
    dataContext: [
      { name: 'Hot Data Cache', icon: 'cache_item', behaviors: {
        'redis': { fit: 'great', note: 'Rich data structures, pub/sub, persistence options' },
        'memcached': { fit: 'good', note: 'Simple KV cache, lower memory overhead' },
        'keydb': { fit: 'great', note: 'Multi-threaded Redis fork, higher throughput' }
      }},
      { name: 'Session State', icon: 'session', behaviors: {
        'redis': { fit: 'great', note: 'TTL-based expiry, persistence for HA' },
        'memcached': { fit: 'tradeoff', note: 'Fast but no persistence, session loss on restart' },
        'keydb': { fit: 'great', note: 'Redis-compatible, better performance' }
      }},
      { name: 'Derived View Cache', icon: 'table', behaviors: {
        'redis': { fit: 'great', note: 'Hash, sorted sets for complex views' },
        'memcached': { fit: 'poor', note: 'Simple KV only, no complex data structures' },
        'keydb': { fit: 'great', note: 'All Redis data types, multi-threaded' }
      }}
    ],
    variants: {
      'redis': { label: 'Redis',
        metrics: { 'Read Perf': 95, 'Write Perf': 92, 'Scalability': 75, 'Cost Efficiency': 70, 'Op. Simplicity': 75, 'Reliability': 80, 'Learning Curve': 85 },
        pros: ['Rich data structures','Pub/sub','Persistence options'], cons: ['Single-threaded','Memory cost'] },
      'memcached': { label: 'Memcached',
        metrics: { 'Read Perf': 95, 'Write Perf': 95, 'Scalability': 85, 'Cost Efficiency': 85, 'Op. Simplicity': 90, 'Reliability': 75, 'Learning Curve': 95 },
        pros: ['Simple','Multi-threaded','Low overhead'], cons: ['No persistence','No complex data types'] },
      'keydb': { label: 'KeyDB',
        metrics: { 'Read Perf': 98, 'Write Perf': 96, 'Scalability': 82, 'Cost Efficiency': 75, 'Op. Simplicity': 75, 'Reliability': 82, 'Learning Curve': 85 },
        pros: ['Multi-threaded','Redis-compatible','Higher throughput'], cons: ['Smaller community','Less mature'] }
    },
    currentVariant: 'redis'
  }
};

const dashboardCategories = [
  { name: 'Perf', key: 'perf', icon: 'perf' },
  { name: 'Cost', key: 'cost', icon: 'cost_dash' },
  { name: 'Reliab', key: 'rel', icon: 'rel' },
  { name: 'Ops', key: 'ops', icon: 'ops' },
  { name: 'Scale', key: 'scale', icon: 'scale' },
  { name: 'Strat', key: 'strat', icon: 'strat' },
  { name: 'Dev', key: 'dev', icon: 'dev_dash' }
];

// Maps each component metric to a dashboard category key
const METRIC_TO_CATEGORY = {
  'Latency': 'perf',
  'Throughput': 'perf',
  'Read Perf': 'perf',
  'Write Perf': 'perf',
  'Cost Efficiency': 'cost',
  'Reliability': 'rel',
  'Consistency': 'rel',
  'Ordering': 'rel',
  'Op. Simplicity': 'ops',
  'Scalability': 'scale',
  'Portability': 'strat',
  'Learning Curve': 'dev'
};

// ═══════════════ STATE ═══════════════
const state = {
  selectedNode: null,
  selectedConnection: null, // { sourceId, targetId }
  heatmapEnabled: false,
  toolboxTab: 'components',
  swapOpenNode: null,
  variantOpenNode: null,
  // Node drag state
  dragging: null,    // node id being dragged
  dragStart: null,   // { mx, my, nx, ny } mouse + node start positions
  dragMoved: false,  // true if mouse actually moved (to distinguish click vs drag)
  // Connection label drag state
  draggingConn: null,  // { sourceId, targetId, connIdx }
  connDragStart: null, // { mx, my, ox, oy } mouse + original offset
  // Collapsible section state
  collapsedSections: new Set(),
  lastDeltas: {},
  deltaTimeout: null,
  issuesOpen: false,
  flowParticles: [],
  flowAnimationId: null,
  hiddenMetrics: new Set(['Reliability', 'Portability', 'Learning Curve']),
  metricFilterOpen: false,
  inspSwapOpen: false,
  inspVariantOpen: false,
  dashboardExpanded: false
};
let connectionPathData = [];

// ═══════════════ HELPER FUNCTIONS ═══════════════

function getMetricColor(value) {
  if (value >= 70) return 'var(--green)';
  if (value >= 40) return 'var(--yellow)';
  return 'var(--red)';
}

function getHeatColor(status) {
  if (status === 'green') return 'var(--green)';
  if (status === 'yellow') return 'var(--yellow)';
  return 'var(--red)';
}

function getConnectionHealth(srcId, tgtId) {
  const src = components[srcId];
  const tgt = components[tgtId];
  // Worst of the two endpoints
  const priority = { 'red': 0, 'yellow': 1, 'green': 2 };
  return priority[src.heatStatus] <= priority[tgt.heatStatus] ? src.heatStatus : tgt.heatStatus;
}

const HEALTH_LABELS = {
  green: { label: 'Healthy', color: 'var(--green)', icon: 'gain',
    desc: 'Both endpoints are performing well. This connection is not a bottleneck — data flows efficiently between these components.' },
  yellow: { label: 'Warning', color: 'var(--yellow)', icon: 'Monitoring',
    desc: 'One or both endpoints have degraded metrics. This connection may become a bottleneck under load. Consider optimizing the weaker endpoint or adjusting its configuration variant.' },
  red: { label: 'Bottleneck', color: 'var(--red)', icon: 'cons',
    desc: 'One or both endpoints are critically underperforming. This connection is likely a system bottleneck. The weakest endpoint constrains the entire path — improving it will have the most impact.' }
};

function buildEndpointMetricDetail(nodeId, panelId) {
  const c = components[nodeId];
  const metrics = c.variants[c.currentVariant].metrics;
  const entries = Object.entries(metrics);
  const belowThreshold = entries.filter(([, v]) => v < 70);
  const causeText = belowThreshold.length === 0
    ? '<div style="font-size:10px;color:var(--green);margin-bottom:4px">All metrics above threshold</div>'
    : `<div class="conn-health-metrics-label">${belowThreshold.length} metric${belowThreshold.length > 1 ? 's' : ''} below threshold (70)</div>`;
  return `<div class="conn-health-metrics" id="${panelId}">
    ${causeText}
    ${entries.map(([name, val]) => {
      const color = getMetricColor(val);
      const isCause = val < 70;
      return `<div class="conn-health-metric-row">
        <span class="conn-health-metric-flag" style="color:${isCause ? 'var(--red)' : 'transparent'}">${isCause ? '!' : ''}</span>
        <span class="conn-health-metric-name" style="${isCause ? 'color:var(--text-primary);font-weight:500' : ''}">${name}</span>
        <div class="conn-health-metric-bar">
          <div class="conn-health-metric-fill" style="width:${val}%;background:${color}"></div>
        </div>
        <span class="conn-health-metric-val" style="color:${color}">${val}</span>
      </div>`;
    }).join('')}
  </div>`;
}

function toggleConnHealthDetail(panelId, event) {
  if (event) event.stopPropagation();
  const el = document.getElementById(panelId);
  if (el) el.classList.toggle('visible');
}

function renderConnectionHealth(srcId, tgtId) {
  const health = getConnectionHealth(srcId, tgtId);
  const h = HEALTH_LABELS[health];
  const src = components[srcId];
  const tgt = components[tgtId];
  const srcH = HEALTH_LABELS[src.heatStatus];
  const tgtH = HEALTH_LABELS[tgt.heatStatus];
  const infoIcon = `<svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><circle cx="8" cy="8" r="6"/><path d="M8 7v4M8 5v.5"/></svg>`;
  const content = `<div class="conn-health-indicator">
      <div class="conn-health-badge" style="background:${h.color}20;color:${h.color};border:1px solid ${h.color}40">
        <span class="conn-health-dot" style="background:${h.color}"></span> ${h.label}
      </div>
      <div class="conn-health-desc">${h.desc}</div>
      <div class="conn-health-endpoints">
        <div>
          <div class="conn-health-ep" style="cursor:pointer" title="Inspect ${src.name}">
            <span class="conn-health-dot" style="background:${srcH.color}"></span>
            <span onclick="selectNode('${srcId}')" style="text-decoration:underline;text-decoration-style:dotted;cursor:pointer">${src.name}</span>
            <span style="color:${srcH.color};font-weight:600;margin-left:auto">${srcH.label}</span>
            <button class="conn-health-info-btn" onclick="toggleConnHealthDetail('chd-${srcId}', event)" title="Show metric details">${infoIcon}</button>
          </div>
          ${buildEndpointMetricDetail(srcId, 'chd-' + srcId)}
        </div>
        <div>
          <div class="conn-health-ep" style="cursor:pointer" title="Inspect ${tgt.name}">
            <span class="conn-health-dot" style="background:${tgtH.color}"></span>
            <span onclick="selectNode('${tgtId}')" style="text-decoration:underline;text-decoration-style:dotted;cursor:pointer">${tgt.name}</span>
            <span style="color:${tgtH.color};font-weight:600;margin-left:auto">${tgtH.label}</span>
            <button class="conn-health-info-btn" onclick="toggleConnHealthDetail('chd-${tgtId}', event)" title="Show metric details">${infoIcon}</button>
          </div>
          ${buildEndpointMetricDetail(tgtId, 'chd-' + tgtId)}
        </div>
      </div>
      <div class="conn-health-rule">Health = worst of the two endpoints</div>
    </div>`;
  return collapsible('conn-health', 'Monitoring', 'var(--text-secondary)', 'Connection Health', content);
}

function icon(name, color) {
  const svg = ICONS[name] || '';
  if (color) return svg.replace(/stroke="currentColor"/g, `stroke="${color}"`);
  return svg;
}

// ═══════════════ COLLAPSIBLE HELPER ═══════════════

function toggleInspSwap(event) {
  if (event) event.stopPropagation();
  state.inspVariantOpen = false;
  state.inspSwapOpen = !state.inspSwapOpen;
  renderInspector();
  if (state.inspSwapOpen) positionInspDropdown('.insp-swap-btn', '.insp-header-dropdown.swap');
}

function toggleInspVariant(event) {
  if (event) event.stopPropagation();
  state.inspSwapOpen = false;
  state.inspVariantOpen = !state.inspVariantOpen;
  renderInspector();
  if (state.inspVariantOpen) positionInspDropdown('.insp-variant-btn', '.insp-header-dropdown.variant');
}

function positionInspDropdown(btnSelector, menuSelector) {
  const btn = document.querySelector(btnSelector);
  const menu = document.querySelector(menuSelector);
  if (!btn || !menu) return;
  const rect = btn.getBoundingClientRect();
  menu.style.top = (rect.bottom + 4) + 'px';
  // For swap dropdown, align left; for variant, align right
  if (menuSelector.includes('swap')) {
    menu.style.left = rect.left + 'px';
  } else {
    menu.style.right = (window.innerWidth - rect.right) + 'px';
  }
}

function inspSwapComponent(newId, event) {
  if (event) event.stopPropagation();
  state.inspSwapOpen = false;
  swapComponent(state.selectedNode, newId);
}

function inspChangeVariant(variantKey, event) {
  if (event) event.stopPropagation();
  state.inspVariantOpen = false;
  changeVariant(state.selectedNode, variantKey);
}

function toggleMetricFilter(event) {
  if (event) event.stopPropagation();
  state.metricFilterOpen = !state.metricFilterOpen;
  renderInspector();
  if (state.metricFilterOpen) {
    positionMetricFilterMenu();
  }
}

function positionMetricFilterMenu() {
  const btn = document.querySelector('.metric-filter-btn');
  const menu = document.querySelector('.metric-filter-menu');
  if (!btn || !menu) return;
  const rect = btn.getBoundingClientRect();
  menu.style.top = (rect.bottom + 4) + 'px';
  menu.style.right = (window.innerWidth - rect.right) + 'px';
}

function toggleMetricVisibility(metricName, event) {
  if (event) event.stopPropagation();
  if (state.hiddenMetrics.has(metricName)) {
    state.hiddenMetrics.delete(metricName);
  } else {
    state.hiddenMetrics.add(metricName);
  }
  renderInspector();
  if (state.metricFilterOpen) positionMetricFilterMenu();
}

function setAllMetrics(show, event) {
  if (event) event.stopPropagation();
  const c = components[state.selectedNode];
  const v = c.variants[c.currentVariant];
  if (show) {
    Object.keys(v.metrics).forEach(name => state.hiddenMetrics.delete(name));
  } else {
    Object.keys(v.metrics).forEach(name => state.hiddenMetrics.add(name));
  }
  renderInspector();
  if (state.metricFilterOpen) positionMetricFilterMenu();
}

function toggleMetricExplanation(panelId, event) {
  if (event) event.stopPropagation();
  const el = document.getElementById(panelId);
  if (!el) return;
  // Close other open metric explanations first
  document.querySelectorAll('.metric-explanation.visible').forEach(other => {
    if (other.id !== panelId) other.classList.remove('visible');
  });
  el.classList.toggle('visible');
}

function toggleSection(sectionId) {
  if (state.collapsedSections.has(sectionId)) {
    state.collapsedSections.delete(sectionId);
  } else {
    state.collapsedSections.add(sectionId);
  }
  const body = document.getElementById(sectionId);
  if (body) body.classList.toggle('collapsed');
  const title = document.querySelector(`[data-toggle="${sectionId}"]`);
  if (title) {
    const chev = title.querySelector('.section-chevron');
    if (chev) chev.classList.toggle('open');
  }
}

function collapsible(id, titleIcon, titleColor, titleText, content) {
  const isCollapsed = state.collapsedSections.has(id);
  return `<div class="insp-section">
    <div class="insp-section-title collapsible" data-toggle="${id}" onclick="toggleSection('${id}')">
      ${icon(titleIcon, titleColor)} ${titleText}
      <span class="section-chevron ${isCollapsed ? '' : 'open'}">${icon('chevron', 'var(--text-secondary)')}</span>
    </div>
    <div class="insp-section-body ${isCollapsed ? 'collapsed' : ''}" id="${id}">${content}</div>
  </div>`;
}

// ═══════════════ RENDER FUNCTIONS ═══════════════

function renderLegend() {
  const el = document.getElementById('canvasLegend');
  if (state.heatmapEnabled) {
    el.innerHTML = `
      <div class="legend-title">${icon('Monitoring', 'var(--text-secondary)')} Health Overlay</div>
      <div class="legend-item"><div class="legend-dot" style="border-color:var(--green)"></div> Healthy</div>
      <div class="legend-item"><div class="legend-dot" style="border-color:var(--yellow)"></div> Warning</div>
      <div class="legend-item"><div class="legend-dot" style="border-color:var(--red)"></div> Bottleneck</div>
      <div class="legend-divider"></div>
      <div class="legend-item"><div class="legend-swatch" style="background:var(--green)"></div> Line: healthy</div>
      <div class="legend-item"><div class="legend-swatch" style="background:var(--yellow);height:2px;border-top:1px dashed var(--yellow)"></div> Line: warning</div>
      <div class="legend-item"><div class="legend-swatch" style="background:var(--red);height:2px;border-top:1px dashed var(--red)"></div> Line: bottleneck</div>
    `;
  } else {
    // Show category legend for visible categories
    const usedCats = new Set(Object.values(components).map(c => c.category));
    el.innerHTML = `
      <div class="legend-title">${icon('Search', 'var(--text-secondary)')} Component Types</div>
      ${[...usedCats].map(cat => `<div class="legend-item clickable" onclick="showCategoryInfo('${cat}')" title="About ${cat}">${icon(cat, CATEGORIES[cat].color)} <span style="color:var(--text-secondary)">${cat}</span></div>`).join('')}
    `;
  }
}

function renderToolbox() {
  const el = document.getElementById('toolboxContent');
  if (state.toolboxTab === 'components') {
    // Build a set of component names currently on canvas
    const onCanvas = new Set(Object.values(components).map(c => c.name));

    el.innerHTML = Object.entries(COMPONENT_CATALOG).map(([catName, items]) => {
      const cat = CATEGORIES[catName];
      const info = CATEGORY_INFO[catName];
      const groupId = `catgrp-${catName.replace(/[^a-zA-Z]/g, '')}`;
      const isCollapsed = state.collapsedSections.has(groupId);
      const activeCount = items.filter(i => onCanvas.has(i.name)).length;

      return `<div class="cat-group">
        <div class="cat-group-header" onclick="toggleSection('${groupId}')" data-toggle="${groupId}">
          ${icon(catName, cat.color)}
          <span class="cat-group-name" style="color:${cat.color}">${catName}</span>
          ${activeCount ? `<span class="cat-item-active">${activeCount} in use</span>` : ''}
          <span class="cat-group-count">${items.length}</span>
          <span class="section-chevron ${isCollapsed ? '' : 'open'}">${icon('chevron', 'var(--text-secondary)')}</span>
        </div>
        <div class="cat-group-body ${isCollapsed ? 'collapsed' : ''}" id="${groupId}">
          ${info ? `<div class="cat-group-desc">${info.role}</div>` : ''}
          ${items.map(item => {
            const isActive = onCanvas.has(item.name);
            const fromTags = item.connectsFrom.map(t => `<span class="cat-item-tip-tag">${t}</span>`).join('');
            const toTags = item.connectsTo.map(t => `<span class="cat-item-tip-tag">${t}</span>`).join('');
            // Find the canvas node id if this component is on canvas
            const canvasId = Object.entries(components).find(([, c]) => c.name === item.name)?.[0];
            return `<div class="cat-item${isActive ? ' active-item' : ''}" ${canvasId ? `ondblclick="selectNode('${canvasId}')"` : ''}>
              <span class="cat-item-dot" style="background:${cat.color}${isActive ? '' : '60'}"></span>
              <span class="cat-item-name">${item.name}</span>
              ${isActive ? '<span class="cat-item-active">ON CANVAS</span>' : ''}
              <span class="cat-item-sub">${item.sub}</span>
              <div class="cat-item-tip">
                <strong>${item.name}</strong> <span style="color:var(--text-secondary)">· ${item.sub}</span>
                ${item.connectsFrom.length ? `<div class="cat-item-tip-label">Receives from</div><div class="cat-item-tip-list">${fromTags}</div>` : ''}
                ${item.connectsTo.length ? `<div class="cat-item-tip-label">Connects to</div><div class="cat-item-tip-list">${toTags}</div>` : ''}
              </div>
            </div>`;
          }).join('')}
        </div>
      </div>`;
    }).join('');
  } else if (state.toolboxTab === 'stacks') {
    el.innerHTML = `<div class="component-card" style="border-left-color:var(--accent)">
      <div class="card-header">
        <div class="card-icon">${icon('Messaging', 'var(--accent)')}</div>
        <div><div class="card-name">Real-Time Messaging Stack</div><div class="card-category">${icon('Messaging', 'var(--accent)')} 5 components</div></div></div>
      <div class="card-section"><div class="card-section-label card-is">${icon('is', 'var(--text-secondary)')} IS</div>Pre-wired stack for real-time message delivery with persistence and caching</div>
      <div class="card-section"><div class="card-section-label card-gain">${icon('gain', 'var(--green)')} GAIN</div>Complete messaging pipeline, proven pattern</div>
      <div class="card-section"><div class="card-section-label card-cost">${icon('cost', 'var(--yellow)')} COST</div>Full Kafka + Redis operational burden</div>
    </div>
    <div class="component-card" style="border-left-color:var(--cat-auth)">
      <div class="card-header">
        <div class="card-icon">${icon('Auth/Security', 'var(--cat-auth)')}</div>
        <div><div class="card-name">Auth Stack</div><div class="card-category">${icon('Auth/Security', 'var(--cat-auth)')} 3 components</div></div></div>
      <div class="card-section"><div class="card-section-label card-is">${icon('is', 'var(--text-secondary)')} IS</div>Authentication and authorization with JWT, rate limiting, and session store</div>
    </div>`;
  } else {
    el.innerHTML = `<div class="component-card" style="border-left-color:var(--accent)">
      <div class="card-header">
        <div class="card-icon">${icon('Delivery/Network', 'var(--accent)')}</div>
        <div><div class="card-name">Stream Processing</div><div class="card-category">${icon('Monitoring', 'var(--accent)')} Tier 2 · 7 components</div></div></div>
      <div class="card-section"><div class="card-section-label card-is">${icon('is', 'var(--text-secondary)')} IS</div>Real-time messaging with persistent storage, caching layer, and event streaming</div>
    </div>
    <div class="component-card" style="border-left-color:var(--cat-realtime)">
      <div class="card-header">
        <div class="card-icon">${icon('Real-Time', 'var(--cat-realtime)')}</div>
        <div><div class="card-name">ETL Pipeline (Batch)</div><div class="card-category">${icon('Monitoring', 'var(--cat-realtime)')} Tier 1 · 4 components</div></div></div>
      <div class="card-section"><div class="card-section-label card-is">${icon('is', 'var(--text-secondary)')} IS</div>Multi-datacenter messaging with MTProto, distributed file storage, and bot platform</div>
    </div>`;
  }
}

const VARIANT_ICON = '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.5"><circle cx="6" cy="6" r="2"/><path d="M6 1v2M6 9v2M1 6h2M9 6h2"/></svg>';

function renderNodes() {
  const container = document.getElementById('nodesContainer');
  container.innerHTML = Object.entries(components).map(([id, c]) => {
    const cat = CATEGORIES[c.category];
    const v = c.variants[c.currentVariant];
    const allMetrics = Object.entries(v.metrics);
    const visibleMetrics = allMetrics.filter(([k]) => !state.hiddenMetrics.has(k));
    const isSelected = state.selectedNode === id;
    let heatClass = '';
    if (state.heatmapEnabled) heatClass = `heatmap-${c.heatStatus}`;
    const alts = ALTERNATIVES[id] || [];
    const swapOpen = state.swapOpenNode === id;
    const variantOpen = state.variantOpenNode === id;
    const variantKeys = Object.keys(c.variants);
    const hasDropdown = swapOpen || variantOpen;
    return `<div class="node ${isSelected ? 'selected' : ''} ${heatClass}" id="node-${id}"
      data-shape="${cat.shape}" data-node-id="${id}"
      style="left:${c.position.x}px;top:${c.position.y}px;border-top:3px solid ${cat.color}${hasDropdown ? ';z-index:15' : ''}"
      onmousedown="startDrag(event, '${id}')">
      <div class="node-tooltip">
        <div class="tooltip-header">${icon(c.category, cat.color)} <strong>${c.name}</strong> · <span style="color:var(--text-secondary)">${c.category}</span></div>
        <div class="tooltip-metrics">
          ${visibleMetrics.slice(0,4).map(([k,val]) => `<div class="tooltip-metric">${k}: <span>${val}</span></div>`).join('')}
        </div>
      </div>
      <div class="node-body">
        <div class="node-header">
          <div class="node-icon clickable" onclick="event.stopPropagation(); ${alts.length > 1 ? `toggleSwapDropdown('${id}')` : `showCategoryInfo('${c.category}')`}" title="${alts.length > 1 ? 'Swap component' : 'About ' + c.category}">${icon(c.category, cat.color)}</div>
          <div class="node-name">${c.name}</div>
        </div>
        ${swapOpen ? `<div class="node-dropdown left" onclick="event.stopPropagation()">
          ${alts.map(a => `<div class="swap-option ${a.id === id ? 'current' : ''}" onclick="swapComponent('${id}', '${a.id}')">
            ${icon(c.category, cat.color)} ${a.name} <span class="swap-option-sub">${a.sub}</span>
          </div>`).join('')}
        </div>` : ''}
        ${variantKeys.length > 1 ? `<div class="node-variant-btn" onclick="event.stopPropagation(); toggleVariantDropdown('${id}')" title="Change configuration variant">${VARIANT_ICON}</div>` : ''}
        ${variantOpen ? `<div class="node-dropdown right" onclick="event.stopPropagation()">
          ${variantKeys.map(vk => {
            const vl = c.variants[vk];
            return `<div class="swap-option ${vk === c.currentVariant ? 'current' : ''}" onclick="changeVariantFromNode('${id}', '${vk}')">
              ${VARIANT_ICON} ${vl.label} ${vk === c.currentVariant ? '<span class="swap-option-sub">Current</span>' : ''}
            </div>`;
          }).join('')}
        </div>` : ''}
        <div class="node-variant">${v.label}</div>
        <div class="node-mini-metrics">
          ${visibleMetrics.map(([k,val]) => `<div class="node-mini-bar"><div class="node-mini-fill" style="width:${val}%;background:${getMetricColor(val)}"></div></div>`).join('')}
        </div>
      </div>
    </div>`;
  }).join('');
}

function renderConnections() {
  connectionPathData = [];
  const svg = document.getElementById('canvasSvg');
  let defs = `<defs>
    <marker id="arrowDefault" markerWidth="8" markerHeight="6" refX="8" refY="3" orient="auto"><path d="M0,0 L8,3 L0,6" fill="var(--border)"/></marker>
    <marker id="arrowGreen" markerWidth="8" markerHeight="6" refX="8" refY="3" orient="auto"><path d="M0,0 L8,3 L0,6" fill="var(--green)"/></marker>
    <marker id="arrowYellow" markerWidth="8" markerHeight="6" refX="8" refY="3" orient="auto"><path d="M0,0 L8,3 L0,6" fill="var(--yellow)"/></marker>
    <marker id="arrowRed" markerWidth="8" markerHeight="6" refX="8" refY="3" orient="auto"><path d="M0,0 L8,3 L0,6" fill="var(--red)"/></marker>
    <marker id="arrowAccent" markerWidth="8" markerHeight="6" refX="8" refY="3" orient="auto"><path d="M0,0 L8,3 L0,6" fill="var(--accent)"/></marker>
  </defs>`;
  let paths = '';
  let labels = '';
  Object.entries(components).forEach(([id, c]) => {
    c.connections.forEach((conn, ci) => {
      const targetId = conn.target;
      const src = c.position;
      const tgt = components[targetId].position;
      const sx = src.x + 76, sy = src.y + 50;
      const tx = tgt.x + 76, ty = tgt.y + 10;
      const baseMx = (sx + tx) / 2, baseMy = (sy + ty) / 2;
      // Offset defines where the LABEL sits (on the curve at t=0.5)
      if (!conn.offset) conn.offset = { x: 0, y: 0 };
      // Label position = midpoint + offset (this is where the curve passes at t=0.5)
      const lx = baseMx + conn.offset.x;
      const ly = baseMy + conn.offset.y;
      // Derive control point so curve passes through label at t=0.5
      // P(0.5) = 0.25*P0 + 0.5*Pc + 0.25*P1  →  Pc = 2*P(0.5) - 0.5*(P0+P1)
      const cpx = 2 * lx - 0.5 * (sx + tx);
      const cpy = 2 * ly - 0.5 * (sy + ty);
      const pathD = `M${sx},${sy} Q${cpx},${cpy} ${tx},${ty}`;
      const health = getConnectionHealth(id, targetId);
      connectionPathData.push({ sx, sy, cpx, cpy, tx, ty, health });
      let heatClass = '';
      let markerEnd = 'url(#arrowDefault)';
      if (state.heatmapEnabled) {
        heatClass = `heat-${health}`;
        markerEnd = `url(#arrow${health.charAt(0).toUpperCase() + health.slice(1)})`;
      }
      const isSelected = state.selectedConnection &&
        state.selectedConnection.sourceId === id && state.selectedConnection.targetId === targetId;
      if (isSelected) markerEnd = 'url(#arrowAccent)';
      paths += `<path id="conn-${id}-${targetId}" class="conn-path ${heatClass} ${isSelected ? 'conn-selected' : ''}" d="${pathD}" marker-end="${markerEnd}"/>`;
      // Label sits exactly on the curve at t=0.5
      const labelText = conn.label || '';
      const connType = conn.connType || 'http';
      const ctDef = CONN_TYPE_DEFS[connType];
      const iconSpace = 14; // 10px icon + 4px gap
      const labelW = labelText.length * 6 + 16 + iconSpace;
      const iconX = lx - labelW/2 + 4;
      const iconY = ly - 5;
      const textX = lx + iconSpace/2;
      labels += `<g class="conn-label-group ${isSelected ? 'selected' : ''}"
        onmousedown="event.stopPropagation(); startConnDrag(event, '${id}', '${targetId}', ${ci})"
        onclick="event.stopPropagation();">
        <rect class="conn-label-bg ${isSelected ? 'selected' : ''}" x="${lx - labelW/2}" y="${ly - 9}" width="${labelW}" height="18" />
        <g transform="translate(${iconX},${iconY}) scale(1)"><path d="${ctDef.path}" fill="none" stroke="${ctDef.color}" stroke-width="1.3"/></g>
        <text class="conn-label-text" x="${textX}" y="${ly}">${labelText}</text>
      </g>`;
    });
  });
  svg.innerHTML = defs + paths + labels;
}

function renderInspector() {
  const el = document.getElementById('inspectorContent');

  // Connection detail view
  if (state.selectedConnection) {
    const { sourceId, targetId } = state.selectedConnection;
    const conn = getConnectionData(sourceId, targetId);
    const srcComp = components[sourceId];
    const tgtComp = components[targetId];
    if (!conn || !srcComp || !tgtComp) { state.selectedConnection = null; return renderInspector(); }
    const srcCat = CATEGORIES[srcComp.category];
    const tgtCat = CATEGORIES[tgtComp.category];
    el.innerHTML = `
      <div class="conn-header">
        <div class="conn-endpoint" onclick="selectNode('${sourceId}')" title="Inspect ${srcComp.name}">
          <div class="conn-ep-icon" style="border-color:${srcCat.color}">${icon(srcComp.category, srcCat.color)}</div>
          <div class="conn-ep-name">${srcComp.name}</div>
        </div>
        <div class="conn-header-arrow">${icon('arrow_right', 'var(--text-secondary)')}</div>
        <div class="conn-endpoint" onclick="selectNode('${targetId}')" title="Inspect ${tgtComp.name}">
          <div class="conn-ep-icon" style="border-color:${tgtCat.color}">${icon(tgtComp.category, tgtCat.color)}</div>
          <div class="conn-ep-name">${tgtComp.name}</div>
        </div>
      </div>
      <div class="conn-meta">
        <span class="conn-protocol-badge">${conn.label}</span>
        ${conn.role ? `<span class="conn-role-tag">${conn.role}</span>` : ''}
      </div>
      ${conn.direction ? `<div class="conn-direction-text">${conn.direction}</div>` : ''}
      <div class="conn-props-strip">
        <div class="conn-prop-chip">
          ${icon('protocol', 'var(--text-secondary)')}
          <span class="conn-prop-chip-label">Protocol</span>
          <span class="conn-prop-chip-val">${conn.protocol}</span>
        </div>
        <div class="conn-prop-chip">
          ${icon('pattern', 'var(--text-secondary)')}
          <span class="conn-prop-chip-label">Pattern</span>
          <span class="conn-prop-chip-val">${conn.pattern}</span>
        </div>
        <div class="conn-prop-chip">
          ${icon('speed', 'var(--text-secondary)')}
          <span class="conn-prop-chip-label">Latency</span>
          <span class="conn-prop-chip-val">${conn.latency}</span>
        </div>
        <div class="conn-prop-chip ${conn.colocatable ? 'positive' : 'negative'}">
          ${icon('coloc', conn.colocatable ? 'var(--green)' : 'var(--red)')}
          <span class="conn-prop-chip-label">Co-locatable</span>
          <span class="conn-prop-chip-val">${conn.colocatable ? 'Yes' : 'No'}</span>
        </div>
      </div>
      ${conn.summary ? collapsible('conn-summary', 'is', 'var(--text-secondary)', 'What This Connection Does',
        `<div class="conn-summary">${conn.summary}</div>`) : ''}
      ${renderConnectionHealth(sourceId, targetId)}
      ${conn.code ? collapsible('conn-code', 'code', 'var(--text-secondary)', 'Connection Code',
        `<div class="conn-code-pattern">${conn.code}</div>`) : ''}
      <div class="conn-footer">
        <div class="conn-footer-link" onclick="selectNode('${sourceId}')">
          ${icon(srcComp.category, srcCat.color)} ${srcComp.name}
        </div>
        <div class="conn-footer-link" onclick="selectNode('${targetId}')">
          ${icon(tgtComp.category, tgtCat.color)} ${tgtComp.name}
        </div>
      </div>
    `;
    return;
  }

  if (!state.selectedNode) {
    el.innerHTML = `<div class="inspector-empty">
      <svg viewBox="0 0 32 32" fill="none" stroke="currentColor" stroke-width="1"><circle cx="16" cy="16" r="12"/><path d="M16 10v6M16 20v1"/></svg>
      Click a component or connection on the canvas to inspect it.
    </div>`;
    return;
  }
  const c = components[state.selectedNode];
  const cat = CATEGORIES[c.category];
  const v = c.variants[c.currentVariant];
  const alts = ALTERNATIVES[state.selectedNode] || [];
  const variantKeys = Object.keys(c.variants);
  const currentMetrics = v.metrics;
  const rec = getVariantRecommendation(state.selectedNode);

  // Build swap dropdown items with metric diffs
  const swapDropdownHTML = alts.length > 1 ? `<div class="insp-header-dropdown swap ${state.inspSwapOpen ? 'visible' : ''}">
    ${alts.map(a => {
      const isCurrent = a.id === state.selectedNode;
      const altComp = components[a.id];
      const altMetrics = altComp ? altComp.variants[altComp.currentVariant].metrics : {};
      const metricDiffs = !isCurrent ? Object.entries(currentMetrics).map(([mk, mv]) => {
        const altVal = altMetrics[mk];
        if (altVal === undefined || state.hiddenMetrics.has(mk)) return '';
        const diff = altVal - mv;
        if (diff === 0) return '';
        const mi = METRIC_ICON_MAP[mk] ? icon(METRIC_ICON_MAP[mk], diff > 0 ? 'var(--green)' : 'var(--red)') : '';
        return `<span class="insp-dd-metric ${diff > 0 ? 'positive' : 'negative'}">${mi}${diff > 0 ? '+' : ''}${diff}</span>`;
      }).filter(Boolean).join('') : '';
      return `<div class="insp-dd-item ${isCurrent ? 'current' : ''}" onclick="inspSwapComponent('${a.id}', event)">
        <div class="insp-dd-item-header">
          ${icon(c.category, cat.color)} ${a.name}
          <span class="insp-dd-item-sub">${a.sub}</span>
          ${isCurrent ? '<span class="insp-dd-item-current">Current</span>' : ''}
        </div>
        ${metricDiffs ? `<div class="insp-dd-metrics">${metricDiffs}</div>` : ''}
      </div>`;
    }).join('')}
  </div>` : '';

  // Build variant dropdown items with metric change previews
  const variantDropdownHTML = variantKeys.length > 1 ? `<div class="insp-header-dropdown variant ${state.inspVariantOpen ? 'visible' : ''}">
    ${variantKeys.map(vk => {
      const vv = c.variants[vk];
      const isCurrent = vk === c.currentVariant;
      const metricDiffs = !isCurrent ? Object.entries(vv.metrics).map(([mk, mv]) => {
        const diff = mv - currentMetrics[mk];
        if (diff === 0 || state.hiddenMetrics.has(mk)) return '';
        const mi = METRIC_ICON_MAP[mk] ? icon(METRIC_ICON_MAP[mk], diff > 0 ? 'var(--green)' : 'var(--red)') : '';
        return `<span class="insp-dd-metric ${diff > 0 ? 'positive' : 'negative'}">${mi}${diff > 0 ? '+' : ''}${diff}</span>`;
      }).filter(Boolean).join('') : '';
      return `<div class="insp-dd-item ${isCurrent ? 'current' : ''}" onclick="inspChangeVariant('${vk}', event)">
        <div class="insp-dd-item-header">
          ${VARIANT_ICON} ${vv.label}
          ${isCurrent ? '<span class="insp-dd-item-current">Current</span>' : ''}
        </div>
        ${metricDiffs ? `<div class="insp-dd-metrics">${metricDiffs}</div>` : ''}
      </div>`;
    }).join('')}
    ${rec ? `<div class="insp-dd-rec">${icon('gain', 'var(--accent)')} Try <strong>${rec.label}</strong> for <span class="delta-positive" style="margin-left:2px">+${rec.improvement} ${rec.metric}</span></div>` : ''}
  </div>` : '';
  const allMetricEntries = Object.entries(v.metrics);
  const visibleCount = allMetricEntries.filter(([name]) => !state.hiddenMetrics.has(name)).length;
  const checkSvg = '<svg viewBox="0 0 10 10" fill="none" stroke="white" stroke-width="2"><path d="M2 5l2 2 4-4"/></svg>';
  const filterMenuItems = allMetricEntries.map(([name, val]) => {
    const isVisible = !state.hiddenMetrics.has(name);
    const mi = METRIC_ICON_MAP[name] ? icon(METRIC_ICON_MAP[name], 'var(--text-secondary)') : '';
    return `<div class="metric-filter-item ${isVisible ? 'checked' : ''}" onclick="toggleMetricVisibility('${name}', event)">
      <div class="metric-filter-check">${isVisible ? checkSvg : ''}</div>
      <span class="metric-filter-name">${mi} ${name}</span>
      <span class="metric-filter-val" style="color:${getMetricColor(val)}">${val}</span>
    </div>`;
  }).join('');
  const filterMenu = `<div class="metric-filter-menu ${state.metricFilterOpen ? 'visible' : ''}">
    <div class="metric-filter-actions">
      <button class="metric-filter-action" onclick="setAllMetrics(true, event)">All</button>
      <button class="metric-filter-action" onclick="setAllMetrics(false, event)">None</button>
    </div>
    ${filterMenuItems}
  </div>`;
  const filterBtnLabel = visibleCount < allMetricEntries.length ? `${visibleCount}/${allMetricEntries.length}` : '';
  const filterBtn = `<div class="metric-filter-wrap">
    <button class="metric-filter-btn ${state.metricFilterOpen ? 'active' : ''}" onclick="toggleMetricFilter(event)" title="Choose which metrics to show">
      ${icon('filter', 'currentColor')} ${filterBtnLabel}
    </button>
    ${filterMenu}
  </div>`;

  const metricBars = allMetricEntries.filter(([name]) => !state.hiddenMetrics.has(name)).map(([name, val], idx) => {
    const metricIcon = METRIC_ICON_MAP[name] ? icon(METRIC_ICON_MAP[name], 'var(--text-secondary)') : '';
    const delta = state.lastDeltas[name];
    const deltaHTML = delta ? ` <span class="metric-delta ${delta > 0 ? 'positive' : delta < 0 ? 'negative' : 'neutral'}">${delta > 0 ? '+' : ''}${delta}</span>` : '';
    const explData = METRIC_EXPLANATIONS[state.selectedNode] && METRIC_EXPLANATIONS[state.selectedNode][c.currentVariant] && METRIC_EXPLANATIONS[state.selectedNode][c.currentVariant][name];
    const explId = `mexpl-${idx}`;
    const infoBtn = explData ? `<button class="metric-info-btn" onclick="toggleMetricExplanation('${explId}', event)" title="Why this score?">${icon('info', 'currentColor')}</button>` : '';
    const explPanel = explData ? `<div class="metric-explanation" id="${explId}"><div class="metric-expl-reason">${explData.reason}</div><ul class="metric-expl-factors">${explData.factors.map(f => `<li>${f}</li>`).join('')}</ul></div>` : '';
    return `<div class="metric-row-wrap">
      <div class="metric-row">
        <div class="metric-label"><span class="metric-name">${metricIcon} ${name}</span><span class="metric-value" style="color:${getMetricColor(val)}">${val}${deltaHTML}</span>${infoBtn}</div>
        <div class="metric-bar-track"><div class="metric-bar-fill" style="width:${val}%;background:${getMetricColor(val)}"></div><div class="metric-threshold" style="left:70%" title="Healthy threshold"></div></div>
      </div>
      ${explPanel}
    </div>`;
  }).join('');
  const metricsEmpty = visibleCount === 0 ? '<div style="font-size:11px;color:var(--text-secondary);padding:8px 0;text-align:center;">No metrics selected. Click the filter to add metrics.</div>' : '';

  const codePattern = CODE_PATTERNS[state.selectedNode] && CODE_PATTERNS[state.selectedNode][c.currentVariant];

  // Auto-open metrics for components with issues
  if (c.heatStatus !== 'green') {
    state.collapsedSections.delete('insp-metrics');
  }

  el.innerHTML = `
    <div class="insp-header">
      <div class="insp-header-btn insp-swap-btn ${state.inspSwapOpen ? 'active' : ''}" ${alts.length > 1 ? 'onclick="toggleInspSwap(event)"' : 'style="cursor:default;opacity:0.6"'} title="${alts.length > 1 ? 'Swap component' : c.category}">${icon(c.category, cat.color)}</div>
      <div class="insp-header-center">
        <div class="insp-name">${c.name}</div>
        <div class="insp-variant-label">${v.label}</div>
      </div>
      ${variantKeys.length > 1 ? `<div class="insp-header-btn insp-variant-btn ${state.inspVariantOpen ? 'active' : ''}" onclick="toggleInspVariant(event)" title="Change configuration variant">${VARIANT_ICON}</div>` : ''}
    </div>
    <div class="insp-category"><div class="insp-cat-dot" style="background:${cat.color}"></div>${c.category}</div>
    ${swapDropdownHTML}
    ${variantDropdownHTML}
    <div class="insp-section">
      <div class="insp-section-title collapsible" data-toggle="insp-metrics" onclick="toggleSection('insp-metrics')">
        <span class="metric-section-title-row">
          ${icon('metrics', 'var(--text-secondary)')} Metrics
          <span onclick="event.stopPropagation()">${filterBtn}</span>
        </span>
        <span class="section-chevron ${state.collapsedSections.has('insp-metrics') ? '' : 'open'}">${icon('chevron', 'var(--text-secondary)')}</span>
      </div>
      <div class="insp-section-body ${state.collapsedSections.has('insp-metrics') ? 'collapsed' : ''}" id="insp-metrics">${metricsEmpty}${metricBars}</div>
    </div>
    ${collapsible('insp-tradeoffs', 'cons', 'var(--text-secondary)', 'Pros & Cons',
      `<div class="pros-cons">${v.pros.map(p => `<div class="pro">${p}</div>`).join('')}${v.cons.map(cc => `<div class="con">${cc}</div>`).join('')}</div>`)}
    ${c.dataContext ? collapsible('insp-data', 'data_ctx', 'var(--accent)', 'Your Data Context',
      c.dataContext.map(item => {
        const behavior = item.behaviors[c.currentVariant];
        if (!behavior) return '';
        return `<div class="data-item fit-${behavior.fit}">
          <div class="data-item-header">
            ${icon(item.icon, 'var(--text-secondary)')}
            ${item.name}
            <span class="fit-badge ${behavior.fit}">${behavior.fit === 'tradeoff' ? 'trade-off' : behavior.fit}</span>
          </div>
          <div class="data-item-note">${behavior.note}</div>
        </div>`;
      }).join('')) : ''}
    ${codePattern ? collapsible('insp-code', 'code', 'var(--text-secondary)', 'Implementation Pattern',
      `<div class="code-pattern">${codePattern}</div>`) : ''}
  `;
}

function renderDashboard() {
  // Compact bottom bar
  const el = document.getElementById('dashboardBars');
  const { scores, breakdown } = calculateDashboardScores();
  el.innerHTML = dashboardCategories.map(cat => {
    const val = scores[cat.key];
    return `<div class="dash-bar-group">
      <div class="dash-bar-track clickable" onclick="highlightForDashboard('${cat.key}')"><div class="dash-bar-fill" style="width:${val}%;background:${getMetricColor(val)}">
        <span class="dash-bar-value">${val}</span>
      </div></div>
      <div class="dash-bar-label">${icon(cat.icon, 'var(--text-secondary)')} ${cat.name}</div>
    </div>`;
  }).join('');

  // Overlay grid (always update so it's ready when toggled)
  const overlayGrid = document.getElementById('dashOverlayGrid');
  overlayGrid.innerHTML = dashboardCategories.map(cat => {
    const val = scores[cat.key];
    const factors = breakdown[cat.key] || [];
    const info = DASHBOARD_INFO[cat.key];
    const catFullName = info ? info.name : cat.name;
    return `<div class="dash-card">
      <div class="dash-card-header">
        ${icon(cat.icon, getMetricColor(val))} ${catFullName}
        <span class="dash-card-score" style="color:${getMetricColor(val)}">${val}</span>
      </div>
      <div class="dash-card-bar"><div class="dash-card-fill" style="width:${val}%;background:${getMetricColor(val)}"></div></div>
      ${info ? `<div class="dash-card-desc">${info.desc}</div>` : ''}
      <div class="dash-card-factors">
        ${factors.map(f => {
          const mi = METRIC_ICON_MAP[f.metric] ? icon(METRIC_ICON_MAP[f.metric], getMetricColor(f.value)) : '';
          return `<div class="dash-card-factor">
            <span class="dash-card-factor-tip">${f.comp} — ${f.metric}: ${f.value}</span>
            <span class="dash-card-factor-comp">${f.comp}</span>
            <span class="dash-card-factor-icon">${mi}</span>
            <span class="dash-card-factor-bar"><span class="dash-card-factor-fill" style="width:${f.value}%;background:${getMetricColor(f.value)}"></span></span>
            <span class="dash-card-factor-val" style="color:${getMetricColor(f.value)}">${f.value}</span>
          </div>`;
        }).join('')}
      </div>
    </div>`;
  }).join('');

  // Sync overlay visibility
  document.getElementById('dashOverlay').classList.toggle('visible', state.dashboardExpanded);
  document.getElementById('dashboard').classList.toggle('expanded', state.dashboardExpanded);
}

function toggleDashboardExpand() {
  state.dashboardExpanded = !state.dashboardExpanded;
  document.getElementById('dashOverlay').classList.toggle('visible', state.dashboardExpanded);
  document.getElementById('dashboard').classList.toggle('expanded', state.dashboardExpanded);
  if (state.dashboardExpanded) renderDashboard(); // refresh overlay content
}

function calculateDashboardScores() {
  // Build breakdown: for each category, collect { comp, metric, value } entries
  const breakdown = {};
  dashboardCategories.forEach(cat => { breakdown[cat.key] = []; });

  Object.entries(components).forEach(([id, c]) => {
    const v = c.variants[c.currentVariant];
    Object.entries(v.metrics).forEach(([metricName, value]) => {
      const catKey = METRIC_TO_CATEGORY[metricName];
      if (catKey && breakdown[catKey]) {
        breakdown[catKey].push({ comp: c.name, metric: metricName, value });
      }
    });
  });

  // Score per category = average of all contributing metric values
  const scores = {};
  dashboardCategories.forEach(cat => {
    const factors = breakdown[cat.key];
    if (factors.length > 0) {
      scores[cat.key] = Math.round(factors.reduce((sum, f) => sum + f.value, 0) / factors.length);
    } else {
      scores[cat.key] = 50; // default if no data
    }
  });

  return { scores, breakdown };
}

// ═══════════════ INTERACTIONS ═══════════════

function selectNode(id) {
  if (state.selectedNode !== id) state.lastDeltas = {}; // clear deltas when switching components
  state.inspSwapOpen = false;
  state.inspVariantOpen = false;
  state.selectedNode = id;
  state.selectedConnection = null; // deselect connection when selecting node
  renderNodes();
  renderConnections();
  renderInspector();
  updatePrompt();
}

// ═══════════════ DRAG & DROP ═══════════════

function startDrag(e, nodeId) {
  // Ignore if clicking on interactive children (icon swap, variant btn, dropdowns, select)
  if (e.target.closest('.node-variant-btn') || e.target.closest('.node-dropdown') || e.target.closest('.swap-dropdown') || e.target.closest('.node-icon.clickable') || e.target.closest('select')) return;
  e.preventDefault();
  const c = components[nodeId];
  state.dragging = nodeId;
  state.dragMoved = false;
  state.dragStart = { mx: e.clientX, my: e.clientY, nx: c.position.x, ny: c.position.y };
}

function onDrag(e) {
  if (!state.dragging) return;
  const dx = e.clientX - state.dragStart.mx;
  const dy = e.clientY - state.dragStart.my;
  // Only count as drag if moved more than 4px (to allow click)
  if (Math.abs(dx) > 4 || Math.abs(dy) > 4) state.dragMoved = true;
  if (!state.dragMoved) return;
  const c = components[state.dragging];
  c.position.x = state.dragStart.nx + dx;
  c.position.y = state.dragStart.ny + dy;
  // Move the DOM element directly for performance (no full re-render)
  const nodeEl = document.getElementById(`node-${state.dragging}`);
  if (nodeEl) {
    nodeEl.style.left = c.position.x + 'px';
    nodeEl.style.top = c.position.y + 'px';
    nodeEl.classList.add('dragging');
  }
  // Update connection lines
  renderConnections();
}

function endDrag(e) {
  if (!state.dragging) return;
  const nodeId = state.dragging;
  const nodeEl = document.getElementById(`node-${nodeId}`);
  if (nodeEl) nodeEl.classList.remove('dragging');
  state.dragging = null;
  if (!state.dragMoved) {
    // It was a click, not a drag — select the node
    selectNode(nodeId);
  }
  state.dragStart = null;
  state.dragMoved = false;
}

// ═══════════════ CONNECTION LABEL DRAG ═══════════════

function startConnDrag(e, sourceId, targetId, connIdx) {
  e.preventDefault();
  const conn = components[sourceId].connections[connIdx];
  if (!conn.offset) conn.offset = { x: 0, y: 0 };
  state.draggingConn = { sourceId, targetId, connIdx };
  state.connDragStart = { mx: e.clientX, my: e.clientY, ox: conn.offset.x, oy: conn.offset.y };
  state.dragMoved = false;
}

function onConnDrag(e) {
  if (!state.draggingConn) return;
  const dx = e.clientX - state.connDragStart.mx;
  const dy = e.clientY - state.connDragStart.my;
  if (Math.abs(dx) > 3 || Math.abs(dy) > 3) state.dragMoved = true;
  if (!state.dragMoved) return;
  const { sourceId, connIdx } = state.draggingConn;
  const conn = components[sourceId].connections[connIdx];
  conn.offset.x = state.connDragStart.ox + dx;
  conn.offset.y = state.connDragStart.oy + dy;
  renderConnections();
}

function endConnDrag(e) {
  if (!state.draggingConn) return;
  const wasDrag = state.dragMoved;
  const { sourceId, targetId } = state.draggingConn;
  state.draggingConn = null;
  state.connDragStart = null;
  if (!wasDrag) {
    // It was a click, not a drag — select the connection
    selectConnection(sourceId, targetId);
  }
  state.dragMoved = false;
}

// Combined mouse handlers for both node and connection dragging
document.addEventListener('mousemove', function(e) { onDrag(e); onConnDrag(e); });
document.addEventListener('mouseup', function(e) { endDrag(e); endConnDrag(e); });

function changeVariant(nodeId, variantKey) {
  const c = components[nodeId];
  // Store previous metrics for delta display
  const prevMetrics = { ...c.variants[c.currentVariant].metrics };
  c.currentVariant = variantKey;

  // Calculate deltas for display
  const newMetrics = c.variants[variantKey].metrics;
  state.lastDeltas = {};
  Object.entries(newMetrics).forEach(([key, val]) => {
    if (prevMetrics[key] !== undefined) state.lastDeltas[key] = val - prevMetrics[key];
  });
  // Deltas persist until the next variant change (cleared at top of this function)

  // Update heatmap status based on new metrics
  const v = c.variants[variantKey];
  const avg = Object.values(v.metrics).reduce((a,b) => a+b, 0) / Object.values(v.metrics).length;
  c.heatStatus = avg >= 70 ? 'green' : avg >= 50 ? 'yellow' : 'red';

  // Immediate update on source
  renderInspector();
  renderNodes();
  renderConnections();

  // Sequential ripple through connections
  triggerRipple(nodeId);

  // Dashboard updates after ripple
  setTimeout(() => renderDashboard(), 300 + c.connections.length * 150);
  restartFlowIfActive();
  renderIssuesButton();
  updatePrompt();
}

function triggerRipple(sourceId) {
  const c = components[sourceId];
  const sourceNode = document.getElementById(`node-${sourceId}`);
  if (sourceNode) { sourceNode.classList.add('rippling'); setTimeout(() => sourceNode.classList.remove('rippling'), 400); }

  c.connections.forEach((conn, i) => {
    const targetId = conn.target;
    setTimeout(() => {
      // Flash the connection line
      const line = document.getElementById(`conn-${sourceId}-${targetId}`);
      if (line) { line.classList.add('ripple'); setTimeout(() => line.classList.remove('ripple'), 300); }

      // Ripple the target node
      const targetNode = document.getElementById(`node-${targetId}`);
      if (targetNode) {
        targetNode.classList.add('rippling');
        setTimeout(() => targetNode.classList.remove('rippling'), 400);
      }

      renderNodes();
      renderConnections();
      if (i === c.connections.length - 1) restartFlowIfActive();
    }, (i + 1) * 150);
  });
}

function toggleHeatmap() {
  state.heatmapEnabled = !state.heatmapEnabled;
  document.getElementById('heatmapToggle').classList.toggle('active', state.heatmapEnabled);
  renderNodes();
  renderConnections();
  renderLegend();
  if (state.heatmapEnabled) {
    startFlowAnimation();
  } else {
    stopFlowAnimation();
  }
  updatePrompt();
}

function togglePanel(panelId) {
  document.getElementById(panelId).classList.toggle('collapsed');
}

function switchTab(tabEl, tabName) {
  document.querySelectorAll('.toolbox-tab').forEach(t => t.classList.remove('active'));
  tabEl.classList.add('active');
  state.toolboxTab = tabName;
  renderToolbox();
}

// ═══════════════ CONNECTION SELECTION ═══════════════

function selectConnection(sourceId, targetId) {
  // Toggle selection
  if (state.selectedConnection &&
      state.selectedConnection.sourceId === sourceId &&
      state.selectedConnection.targetId === targetId) {
    state.selectedConnection = null;
  } else {
    state.selectedConnection = { sourceId, targetId };
    state.selectedNode = null; // deselect node when selecting connection
  }
  renderNodes();
  renderConnections();
  renderInspector();
  updatePrompt();
}

function getConnectionData(sourceId, targetId) {
  const c = components[sourceId];
  if (!c) return null;
  return c.connections.find(conn => conn.target === targetId) || null;
}

// ═══════════════ COMPONENT SWAP ═══════════════

function toggleSwapDropdown(nodeId) {
  state.variantOpenNode = null;
  state.swapOpenNode = state.swapOpenNode === nodeId ? null : nodeId;
  renderNodes();
  renderConnections();
}

function toggleVariantDropdown(nodeId) {
  state.swapOpenNode = null;
  state.variantOpenNode = state.variantOpenNode === nodeId ? null : nodeId;
  renderNodes();
  renderConnections();
}

function changeVariantFromNode(nodeId, variantKey) {
  state.variantOpenNode = null;
  changeVariant(nodeId, variantKey);
}

function swapComponent(currentId, newId) {
  if (currentId === newId) {
    state.swapOpenNode = null;
    renderNodes();
    renderConnections();
    return;
  }
  // In a real app this would replace the component entirely.
  // For this playground, show feedback that it would swap.
  const alt = (ALTERNATIVES[currentId] || []).find(a => a.id === newId);
  const node = document.getElementById(`node-${currentId}`);
  if (node) {
    node.style.transition = 'transform 0.2s, opacity 0.2s';
    node.style.transform = 'scale(0.9)';
    node.style.opacity = '0.5';
    setTimeout(() => {
      node.style.transform = 'scale(1)';
      node.style.opacity = '1';
    }, 200);
  }
  state.swapOpenNode = null;
  // Update the prompt to reflect the swap intention
  if (alt) {
    const c = components[currentId];
    c._swapTarget = alt;
  }
  renderNodes();
  renderConnections();
  renderInspector();
  updatePrompt();
}

// Close swap/variant dropdown on click outside
document.addEventListener('click', function(e) {
  if (state.swapOpenNode && !e.target.closest('.node-icon.clickable') && !e.target.closest('.node-dropdown') && !e.target.closest('.swap-dropdown')) {
    state.swapOpenNode = null;
    renderNodes();
    renderConnections();
  }
  if (state.variantOpenNode && !e.target.closest('.node-variant-btn') && !e.target.closest('.node-dropdown')) {
    state.variantOpenNode = null;
    renderNodes();
    renderConnections();
  }
  if (state.issuesOpen && !e.target.closest('#issuesBtn') && !e.target.closest('#issuesDropdown')) {
    state.issuesOpen = false;
    document.getElementById('issuesDropdown').classList.remove('visible');
  }
  if (state.metricFilterOpen && !e.target.closest('.metric-filter-wrap') && !e.target.closest('.metric-filter-menu')) {
    state.metricFilterOpen = false;
    const menu = document.querySelector('.metric-filter-menu');
    if (menu) menu.classList.remove('visible');
  }
  if (state.inspSwapOpen && !e.target.closest('.insp-swap-btn') && !e.target.closest('.insp-header-dropdown.swap')) {
    state.inspSwapOpen = false;
    renderInspector();
  }
  if (state.inspVariantOpen && !e.target.closest('.insp-variant-btn') && !e.target.closest('.insp-header-dropdown.variant')) {
    state.inspVariantOpen = false;
    renderInspector();
  }
});

// ═══════════════ PROMPT OUTPUT ═══════════════

function updatePrompt() {
  const el = document.getElementById('promptText');
  const parts = [];
  parts.push('Build the Archie architecture simulator interface with these specifications:');
  parts.push('');
  parts.push('LAYOUT: VS Code three-zone pattern — Toolbox sidebar (left, 270px), Canvas (center, dark bg #0f1117), Inspector panel (right, 310px). Dashboard bar at bottom (110px). Top bar with logo, architecture name, tier badge, and icon+label action buttons.');
  parts.push('');
  parts.push('THEME: Dark mode primary. Panel bg: #1a1d27, Surface: #242736, Border: #2e3348, Text: #e2e4eb / #8b8fa3, Accent: #6366f1 (indigo). Font: Inter, 13px base. 4px spacing unit.');
  parts.push('');
  parts.push('ICONOGRAPHY: Every category, action, metric, and label has an SVG icon. Icons are the primary visual communication — users identify component types by icon before text. 10 category icons: CPU (compute), Database cylinder (data storage), Lightning bolt (caching), Chat bubble (messaging), Globe (delivery/network), Signal waves (real-time), Shield (auth), Chart (monitoring), Magnifying glass (search), Gear (devops). Icons appear in nodes, toolbox cards, inspector, dashboard labels, tabs, and buttons.');
  parts.push('');
  parts.push('NODE SHAPES: Each component category has a distinct node shape: Compute = sharp rectangle (4px radius), Data Storage = bottom-rounded cylinder shape (4px top, 14px bottom radius), Caching = pill (16px radius), Messaging = alternating corners (12px/4px), Delivery = stadium (20px radius). Nodes show: category color top stripe, category icon + name, variant label, mini metric bars.');
  parts.push('');
  parts.push('COLOR SYSTEM: Two separate color layers — category colors (10 distinct hues) identify component TYPE via accent stripes and icon fills. Heatmap colors (green/yellow/red) show HEALTH status on borders and connection lines when heatmap is enabled. These never overlap — category = identity, heatmap = performance.');
  parts.push('');

  if (state.heatmapEnabled) {
    parts.push('HEATMAP: Enabled — node borders glow with health colors (green/yellow/red). Connection LINES also colored by health (worst of two endpoints). Dashed lines for warning/bottleneck connections. Legend visible in top-right corner of canvas.');
    parts.push('');
  }

  if (state.selectedNode) {
    const c = components[state.selectedNode];
    const v = c.variants[c.currentVariant];
    parts.push(`CURRENT SELECTION: ${c.name} (${c.category}) with "${v.label}" config variant.`);
    parts.push(`Metrics: ${Object.entries(v.metrics).map(([k,val]) => `${k}: ${val}/100`).join(', ')}`);
    parts.push('');
  }

  parts.push('CORE INTERACTION: Config variant dropdown in inspector. On change → metric bars animate (0.5s cubic-bezier), sequential ripple propagates through connections (~150ms per hop), heatmap colors shift on nodes AND lines, dashboard updates after ripple completes.');
  parts.push('');
  parts.push('TOOLBOX: Three tabs with icons (grid=Components | stack=Stacks | blueprint=Blueprints). Component cards in IS/GAIN/COST format with category icon + color left border. Section labels have micro-icons (circle=IS, up-arrow=GAIN, down-arrow=COST).');
  parts.push('');
  parts.push('DASHBOARD: 7 horizontal bars with category icons (rocket=Perf, dollar=Cost, shield=Reliab, gear=Ops, mountain=Scale, flag=Strat, code=Dev). Color-coded: green >70, yellow 40-70, red <40.');
  parts.push('');
  parts.push('DATA CONTEXT: Each component has user-defined data items (e.g., Redis: "User Sessions", "Rate Limits", "Message Cache"). When switching config variants, a "Your Data Context" section in the inspector shows how each data item behaves under that variant with fit indicators (great/good/trade-off/poor/risky) and specific notes. This makes abstract metrics concrete: "Your sessions are read-heavy → Cache-Aside is a great fit" vs "Your rate limit counters are write-heavy → Cache-Aside is a poor fit." Users can edit their data items to personalize the trade-off analysis.');
  parts.push('');
  parts.push('COMPONENT SWAP: Each node shows a swap button (arrows icon) on hover in the top-right corner. Clicking opens a dropdown with alternative components in the same category (e.g., Redis → Memcached, KeyDB, Dragonfly). The inspector also shows a "Swap to" dropdown below the component name. This enables quick comparison of alternative tools without rebuilding the architecture.');
  parts.push('');
  parts.push('IMPLEMENTATION PATTERNS: Below the config variant dropdown in the inspector, a code snippet panel shows the actual implementation pattern for the current variant. Syntax-highlighted (keywords purple, functions blue, strings green, comments gray). This makes the difference between variants tangible — users see HOW the code changes, not just abstract metric scores.');
  parts.push('');
  parts.push('CONNECTIONS AS FIRST-CLASS OBJECTS: Connections between components are not just lines — they have properties. Each connection specifies: protocol (HTTP, RESP, Kafka TCP, PostgreSQL Wire, etc.), communication pattern (request-response, pub-sub, poll-consume, fire-and-forget), typical latency, whether components can be co-located on the same machine, and implementation code showing HOW the connection works. Click any connection label on the canvas to inspect its properties. Connections show directional arrows. The Stream Processing architecture has directional flows: Producer→Kafka writes, Stream Processor→Derived Stores materializes, Cache→API serves hot data.');

  if (state.selectedConnection) {
    const conn = getConnectionData(state.selectedConnection.sourceId, state.selectedConnection.targetId);
    if (conn) {
      const src = components[state.selectedConnection.sourceId];
      const tgt = components[state.selectedConnection.targetId];
      parts.push('');
      parts.push(`SELECTED CONNECTION: ${src.name} → ${tgt.name} via ${conn.protocol}. Pattern: ${conn.pattern}. Latency: ${conn.latency}. Co-locatable: ${conn.colocatable ? 'Yes' : 'No'}.`);
    }
  }

  el.textContent = parts.join('\n');
}

function copyPrompt() {
  const text = document.getElementById('promptText').textContent;
  navigator.clipboard.writeText(text).then(() => {
    const btn = document.querySelector('.prompt-copy-btn');
    const original = btn.innerHTML;
    btn.innerHTML = '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 6l3 3 5-5"/></svg> Copied!';
    setTimeout(() => btn.innerHTML = original, 1500);
  });
}

// ═══════════════ INFO POPUPS ═══════════════

function showInfoPopup(headerHTML, bodyHTML) {
  const overlay = document.getElementById('infoPopupOverlay');
  document.getElementById('infoPopupHeader').innerHTML = headerHTML + `<button class="info-popup-close" onclick="hideInfoPopup()">${icon('close', 'var(--text-secondary)')}</button>`;
  document.getElementById('infoPopupBody').innerHTML = bodyHTML;
  overlay.classList.add('visible');
}

function hideInfoPopup() {
  document.getElementById('infoPopupOverlay').classList.remove('visible');
}

function showCategoryInfo(categoryName) {
  const info = CATEGORY_INFO[categoryName];
  if (!info) return;
  const cat = CATEGORIES[categoryName];
  const headerHTML = `${icon(categoryName, cat.color)} <span style="color:${cat.color}">${categoryName}</span>`;
  const bodyHTML = `
    <p><strong>${info.desc}</strong></p>
    <div class="info-popup-section">
      <div class="info-popup-section-title">Role in Architecture</div>
      <p>${info.role}</p>
    </div>
    <div class="info-popup-section">
      <div class="info-popup-section-title">Common Examples</div>
      <p>${info.examples}</p>
    </div>
    <div class="info-popup-section">
      <div class="info-popup-section-title">How to Choose</div>
      <p>${info.key}</p>
    </div>
  `;
  showInfoPopup(headerHTML, bodyHTML);
}

function showDashboardInfo(categoryKey) {
  const info = DASHBOARD_INFO[categoryKey];
  if (!info) return;
  const dashCat = dashboardCategories.find(c => c.key === categoryKey);
  const headerHTML = `${dashCat ? icon(dashCat.icon, 'var(--accent)') : ''} <span style="color:var(--accent)">${info.name}</span>`;
  const bodyHTML = `
    <p><strong>${info.desc}</strong></p>
    <div class="info-popup-section">
      <div class="info-popup-section-title">Key Metrics</div>
      <p>${info.metrics}</p>
    </div>
    <div class="info-popup-section">
      <div class="info-popup-section-title">Why It Matters</div>
      <p>${info.impact}</p>
    </div>
    <div class="info-popup-section">
      <div class="info-popup-section-title">How to Improve</div>
      <p>${info.improve}</p>
    </div>
  `;
  showInfoPopup(headerHTML, bodyHTML);
}

// Close popup on Escape key
document.addEventListener('keydown', function(e) {
  if (e.key === 'Escape') {
    hideInfoPopup();
    if (state.issuesOpen) { state.issuesOpen = false; document.getElementById('issuesDropdown').classList.remove('visible'); }
    if (state.swapOpenNode || state.variantOpenNode) { state.swapOpenNode = null; state.variantOpenNode = null; renderNodes(); renderConnections(); }
  }
});

// ═══════════════ ISSUES SUMMARY ═══════════════

function getIssues() {
  const issues = [];
  Object.entries(components).forEach(([id, c]) => {
    if (c.heatStatus !== 'green') {
      const v = c.variants[c.currentVariant];
      const avg = Math.round(Object.values(v.metrics).reduce((a,b) => a+b, 0) / Object.values(v.metrics).length);
      const worst = Object.entries(v.metrics).sort((a,b) => a[1] - b[1])[0];
      issues.push({ id, name: c.name, category: c.category, status: c.heatStatus, avg, worstMetric: worst[0], worstValue: worst[1] });
    }
  });
  const priority = { 'red': 0, 'yellow': 1 };
  issues.sort((a, b) => (priority[a.status] ?? 2) - (priority[b.status] ?? 2) || a.avg - b.avg);
  return issues;
}

function renderIssuesButton() {
  const issues = getIssues();
  const badge = document.getElementById('issuesBadge');
  if (issues.length === 0) {
    badge.classList.add('hidden');
  } else {
    badge.classList.remove('hidden');
    badge.textContent = issues.length;
    badge.className = 'issues-badge' + (issues.some(i => i.status === 'red') ? '' : ' warning');
  }
}

function toggleIssues() {
  state.issuesOpen = !state.issuesOpen;
  const dropdown = document.getElementById('issuesDropdown');
  const btn = document.getElementById('issuesBtn');
  if (state.issuesOpen) {
    const rect = btn.getBoundingClientRect();
    dropdown.style.top = (rect.bottom + 4) + 'px';
    dropdown.style.left = Math.max(8, rect.left - 80) + 'px';
    const issues = getIssues();
    if (issues.length === 0) {
      dropdown.innerHTML = `<div class="issues-dropdown-title">${icon('gain', 'var(--green)')} Architecture Health</div>
        <div class="issues-none">All components healthy — no issues detected</div>`;
    } else {
      dropdown.innerHTML = `<div class="issues-dropdown-title">${icon('cons', 'var(--red)')} ${issues.length} Issue${issues.length > 1 ? 's' : ''} Detected</div>
        ${issues.map(i => {
          const cat = CATEGORIES[i.category];
          const h = HEALTH_LABELS[i.status];
          return `<div class="issues-item" onclick="selectNode('${i.id}'); toggleIssues();">
            <span class="issues-item-dot" style="background:${h.color}"></span>
            ${icon(i.category, cat.color)}
            <span class="issues-item-name">${i.name}</span>
            <span class="issues-item-detail">${h.label} · worst: ${i.worstMetric} ${i.worstValue}</span>
          </div>`;
        }).join('')}`;
    }
    dropdown.classList.add('visible');
  } else {
    dropdown.classList.remove('visible');
  }
}

// ═══════════════ VARIANT RECOMMENDATION ═══════════════

function getVariantRecommendation(nodeId) {
  const c = components[nodeId];
  const currentMetrics = c.variants[c.currentVariant].metrics;
  const worst = Object.entries(currentMetrics).sort((a,b) => a[1] - b[1])[0];
  if (worst[1] >= 70) return null;
  let bestAlt = null;
  let bestImprovement = 0;
  Object.entries(c.variants).forEach(([vk, vv]) => {
    if (vk === c.currentVariant) return;
    const altValue = vv.metrics[worst[0]];
    if (altValue !== undefined && altValue > worst[1]) {
      const improvement = altValue - worst[1];
      if (improvement > bestImprovement) {
        bestImprovement = improvement;
        bestAlt = { key: vk, label: vv.label, metric: worst[0], from: worst[1], to: altValue, improvement };
      }
    }
  });
  if (!bestAlt) return null;
  const altMetrics = c.variants[bestAlt.key].metrics;
  let worstRegression = null;
  Object.entries(currentMetrics).forEach(([k, v]) => {
    if (k === worst[0]) return;
    const altV = altMetrics[k];
    if (altV !== undefined && altV < v) {
      const loss = v - altV;
      if (!worstRegression || loss > worstRegression.loss) worstRegression = { metric: k, loss };
    }
  });
  bestAlt.tradeoff = worstRegression;
  return bestAlt;
}

// ═══════════════ TIER INFO ═══════════════

function showTierInfo() {
  const headerHTML = `${icon('strat', 'var(--accent)')} <span style="color:var(--accent)">Architecture Tier System</span>`;
  const issues = getIssues();
  const redCount = issues.filter(i => i.status === 'red').length;
  const yellowCount = issues.filter(i => i.status === 'yellow').length;
  const bodyHTML = `
    <p><strong>Tiers measure how complete and production-ready your architecture is.</strong></p>
    <div class="info-popup-section">
      <div class="info-popup-section-title">Current: Tier 2 / 3</div>
      <p>Your architecture has core components with defined connections and configuration variants. Metrics are tracked and trade-offs are visible.</p>
    </div>
    <div class="info-popup-section">
      <div class="info-popup-section-title">Tier Criteria</div>
      <ul class="info-popup-list">
        <li><strong style="color:var(--green)">Tier 1:</strong> Components placed with basic connections defined</li>
        <li><strong style="color:var(--accent)">Tier 2 (current):</strong> Config variants selected, metrics profiled, trade-offs mapped</li>
        <li><strong style="color:var(--yellow)">Tier 3:</strong> All bottlenecks addressed, heatmap mostly green, data context personalized</li>
      </ul>
    </div>
    <div class="info-popup-section">
      <div class="info-popup-section-title">Gap to Tier 3</div>
      <ul class="info-popup-list">
        ${redCount > 0 ? `<li style="color:var(--red)">Resolve ${redCount} bottleneck${redCount > 1 ? 's' : ''} (red components)</li>` : `<li style="color:var(--green)">No bottlenecks — great!</li>`}
        ${yellowCount > 0 ? `<li style="color:var(--yellow)">Address ${yellowCount} warning${yellowCount > 1 ? 's' : ''} (yellow components)</li>` : `<li style="color:var(--green)">No warnings — great!</li>`}
        <li>Customize data context items for your specific use case</li>
        <li>Verify connection health across all paths</li>
      </ul>
    </div>
  `;
  showInfoPopup(headerHTML, bodyHTML);
}

// ═══════════════ DASHBOARD LINKING ═══════════════

function highlightForDashboard(catKey) {
  const issues = getIssues();
  if (issues.length > 0) {
    issues.forEach(issue => {
      const nodeEl = document.getElementById('node-' + issue.id);
      if (nodeEl) {
        nodeEl.classList.add('flash-highlight');
        setTimeout(() => nodeEl.classList.remove('flash-highlight'), 800);
      }
    });
  }
  showDashboardInfo(catKey);
}

// ═══════════════ FLOW PARTICLE ANIMATION ═══════════════
const FLOW_SPEEDS = { green: 0.014, yellow: 0.006, red: 0.0025 };
const FLOW_COLORS = { green: '#22c55e', yellow: '#eab308', red: '#ef4444' };

function startFlowAnimation() {
  stopFlowAnimation();
  if (connectionPathData.length === 0) return;
  state.flowParticles = [];
  connectionPathData.forEach((path, pi) => {
    const count = path.health === 'green' ? 3 : 2;
    for (let i = 0; i < count; i++) {
      state.flowParticles.push({
        pathIdx: pi,
        t: i / count + Math.random() * 0.1,
        speed: FLOW_SPEEDS[path.health] * (0.9 + Math.random() * 0.2)
      });
    }
  });
  const svg = document.getElementById('flowSvg');
  svg.innerHTML = '<defs><filter id="flowGlow"><feGaussianBlur stdDeviation="2" result="blur"/>' +
    '<feMerge><feMergeNode in="blur"/><feMergeNode in="SourceGraphic"/></feMerge></filter></defs>' +
    state.flowParticles.map((p, i) => {
      const color = FLOW_COLORS[connectionPathData[p.pathIdx].health];
      return `<circle id="fp${i}" cx="0" cy="0" r="3" fill="${color}" opacity="0.9" filter="url(#flowGlow)"/>`;
    }).join('');
  function tick() {
    if (!state.heatmapEnabled) return;
    for (let i = 0; i < state.flowParticles.length; i++) {
      const p = state.flowParticles[i];
      p.t += p.speed;
      if (p.t > 1) p.t -= 1;
      const pd = connectionPathData[p.pathIdx];
      if (!pd) continue;
      const mt = 1 - p.t;
      const x = mt * mt * pd.sx + 2 * mt * p.t * pd.cpx + p.t * p.t * pd.tx;
      const y = mt * mt * pd.sy + 2 * mt * p.t * pd.cpy + p.t * p.t * pd.ty;
      const el = document.getElementById(`fp${i}`);
      if (el) {
        el.setAttribute('cx', x);
        el.setAttribute('cy', y);
        el.setAttribute('r', 2.5 + Math.sin(p.t * Math.PI * 4) * 0.8);
      }
    }
    state.flowAnimationId = requestAnimationFrame(tick);
  }
  state.flowAnimationId = requestAnimationFrame(tick);
}

function stopFlowAnimation() {
  if (state.flowAnimationId) cancelAnimationFrame(state.flowAnimationId);
  state.flowAnimationId = null;
  state.flowParticles = [];
  const svg = document.getElementById('flowSvg');
  if (svg) svg.innerHTML = '';
}

function restartFlowIfActive() {
  if (state.heatmapEnabled) startFlowAnimation();
}

// ═══════════════ INIT ═══════════════
function init() {
  renderLegend();
  renderToolbox();
  renderNodes();
  renderConnections();
  renderDashboard();
  renderIssuesButton();
  updatePrompt();
}

init();
</script>
</body>
</html>
