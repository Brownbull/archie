<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Sysops Squad Saga — Archie Playground</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
<style>
/* ═══════════════ RESET & BASE ═══════════════ */
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
:root {
  --canvas-bg: #0f1117;
  --panel-bg: #1a1d27;
  --surface: #242736;
  --border: #2e3348;
  --text-primary: #e2e4eb;
  --text-secondary: #8b8fa3;
  --accent: #6366f1;
  --accent-hover: #818cf8;
  --green: #22c55e;
  --yellow: #eab308;
  --red: #ef4444;
  --cat-compute: #3b82f6;
  --cat-data: #22c55e;
  --cat-cache: #f97316;
  --cat-messaging: #a855f7;
  --cat-delivery: #06b6d4;
  --cat-realtime: #ec4899;
  --cat-auth: #ef4444;
  --cat-monitoring: #eab308;
  --cat-search: #14b8a6;
  --cat-devops: #8b5cf6;
  --radius: 6px;
  --space: 4px;
  --toolbox-w: 270px;
  --inspector-w: 310px;
  --topbar-h: 44px;
}
html, body { height: 100%; overflow: hidden; }
body {
  font-family: 'Inter', system-ui, -apple-system, sans-serif;
  background: var(--canvas-bg);
  color: var(--text-primary);
  font-size: 13px;
  line-height: 1.4;
}

/* ═══════════════ TOP BAR ═══════════════ */
.top-bar {
  height: var(--topbar-h);
  background: var(--panel-bg);
  border-bottom: 1px solid var(--border);
  display: flex;
  align-items: center;
  padding: 0 12px;
  gap: 12px;
  z-index: 100;
}
.logo {
  font-weight: 700;
  font-size: 15px;
  color: var(--accent);
  letter-spacing: -0.5px;
  display: flex;
  align-items: center;
  gap: 6px;
}
.logo svg { width: 18px; height: 18px; }
.arch-name {
  font-weight: 500;
  color: var(--text-secondary);
  flex: 1;
}
.tier-badge {
  background: var(--accent);
  color: white;
  font-size: 11px;
  font-weight: 600;
  padding: 3px 10px;
  border-radius: 12px;
  cursor: default;
  display: flex;
  align-items: center;
  gap: 4px;
}
.tier-badge svg { width: 12px; height: 12px; }
.tier-badge .tier-hint {
  font-weight: 400;
  opacity: 0.7;
  font-size: 10px;
}
.top-actions { display: flex; gap: 6px; }
.top-btn {
  background: var(--surface);
  border: 1px solid var(--border);
  color: var(--text-secondary);
  padding: 5px 10px;
  border-radius: var(--radius);
  font-size: 11px;
  font-family: inherit;
  cursor: pointer;
  transition: all 0.15s;
  display: flex;
  align-items: center;
  gap: 4px;
}
.top-btn svg { width: 14px; height: 14px; }
.top-btn:hover { color: var(--text-primary); border-color: var(--text-secondary); }
.top-btn.active { background: var(--accent); color: white; border-color: var(--accent); }

/* ═══════════════ MAIN LAYOUT ═══════════════ */
.main-layout {
  display: flex;
  height: calc(100vh - var(--topbar-h));
}

/* ═══════════════ TOOLBOX ═══════════════ */
.toolbox {
  width: var(--toolbox-w);
  min-width: var(--toolbox-w);
  background: var(--panel-bg);
  border-right: 1px solid var(--border);
  display: flex;
  flex-direction: column;
  transition: width 0.2s, min-width 0.2s, opacity 0.2s;
  overflow: hidden;
}
.toolbox.collapsed { width: 0; min-width: 0; opacity: 0; pointer-events: none; }
.toolbox-title {
  padding: 10px 12px;
  border-bottom: 1px solid var(--border);
  font-weight: 600;
  font-size: 12px;
  color: var(--text-secondary);
  text-transform: uppercase;
  letter-spacing: 0.5px;
  display: flex;
  align-items: center;
  gap: 6px;
}
.toolbox-title svg { width: 14px; height: 14px; }
.toolbox-tabs {
  display: flex;
  border-bottom: 1px solid var(--border);
}
.toolbox-tab {
  flex: 1;
  padding: 8px 4px;
  text-align: center;
  font-size: 11px;
  font-weight: 500;
  color: var(--text-secondary);
  cursor: pointer;
  border-bottom: 2px solid transparent;
  transition: all 0.15s;
  background: none;
  border-top: none;
  border-left: none;
  border-right: none;
  font-family: inherit;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 4px;
}
.toolbox-tab svg { width: 14px; height: 14px; }
.toolbox-tab:hover { color: var(--text-primary); }
.toolbox-tab.active { color: var(--accent); border-bottom-color: var(--accent); }
.toolbox-content {
  flex: 1;
  overflow-y: auto;
  padding: 8px;
}
.toolbox-content::-webkit-scrollbar { width: 4px; }
.toolbox-content::-webkit-scrollbar-track { background: transparent; }
.toolbox-content::-webkit-scrollbar-thumb { background: var(--border); border-radius: 2px; }
.component-card {
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 10px;
  margin-bottom: 8px;
  cursor: grab;
  transition: all 0.15s;
  border-left: 3px solid var(--cat-color);
}
.component-card:hover {
  border-color: var(--text-secondary);
  transform: translateY(-1px);
}
.card-header {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 6px;
}
.card-icon {
  width: 20px;
  height: 20px;
  flex-shrink: 0;
  display: flex;
  align-items: center;
  justify-content: center;
}
.card-icon svg { width: 18px; height: 18px; }
.card-name { font-weight: 600; font-size: 12px; }
.card-category { font-size: 10px; color: var(--text-secondary); display: flex; align-items: center; gap: 3px; }
.card-category svg { width: 10px; height: 10px; }
.card-section {
  font-size: 10px;
  margin-top: 4px;
  line-height: 1.5;
}
.card-section-label {
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  font-size: 9px;
  margin-bottom: 1px;
  display: flex;
  align-items: center;
  gap: 3px;
}
.card-section-label svg { width: 10px; height: 10px; }
.card-is { color: var(--text-secondary); }
.card-gain { color: var(--green); }
.card-cost { color: var(--yellow); }
/* ═══════════════ CATALOG CATEGORY GROUPS ═══════════════ */
.cat-group {
  margin-bottom: 4px;
}
.cat-group-header {
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 6px 8px;
  cursor: pointer;
  border-radius: var(--radius);
  transition: background 0.1s;
  user-select: none;
}
.cat-group-header:hover { background: var(--surface); }
.cat-group-header svg { width: 14px; height: 14px; flex-shrink: 0; }
.cat-group-name {
  font-weight: 600;
  font-size: 11px;
  flex: 1;
}
.cat-group-count {
  font-size: 9px;
  color: var(--text-secondary);
  background: var(--surface);
  padding: 1px 6px;
  border-radius: 8px;
}
.cat-group-header .section-chevron svg { width: 10px; height: 10px; }
.cat-group-body {
  padding: 0 0 4px 8px;
}
.cat-group-body.collapsed { display: none; }
.cat-group-desc {
  font-size: 10px;
  color: var(--text-secondary);
  line-height: 1.4;
  padding: 2px 8px 6px 20px;
  font-style: italic;
}
.cat-item {
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 5px 8px;
  border-radius: 4px;
  font-size: 11px;
  cursor: grab;
  transition: background 0.1s;
  position: relative;
}
.cat-item:hover { background: var(--surface); }
.cat-item-dot {
  width: 6px;
  height: 6px;
  border-radius: 50%;
  flex-shrink: 0;
}
.cat-item-name { font-weight: 500; }
.cat-item-sub { font-size: 9px; color: var(--text-secondary); margin-left: auto; }
.cat-item-active {
  font-size: 8px;
  color: var(--accent);
  font-weight: 600;
  margin-left: 4px;
}
/* Catalog item tooltip */
.cat-item-tip {
  display: none;
  position: absolute;
  left: calc(100% + 8px);
  top: 50%;
  transform: translateY(-50%);
  background: var(--panel-bg);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 8px 10px;
  font-size: 10px;
  min-width: 180px;
  z-index: 30;
  box-shadow: 0 4px 16px rgba(0,0,0,0.5);
  pointer-events: none;
  white-space: normal;
  line-height: 1.4;
}
.cat-item:hover .cat-item-tip { display: block; }
.cat-item-tip-label {
  font-size: 9px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  color: var(--text-secondary);
  margin-top: 4px;
}
.cat-item-tip-label:first-child { margin-top: 0; }
.cat-item-tip-list {
  display: flex;
  flex-wrap: wrap;
  gap: 3px;
  margin-top: 2px;
}
.cat-item-tip-tag {
  font-size: 9px;
  padding: 1px 5px;
  border-radius: 3px;
  background: var(--surface);
  border: 1px solid var(--border);
}

/* ═══════════════ CANVAS ═══════════════ */
.canvas {
  flex: 1;
  position: relative;
  background: var(--canvas-bg);
  overflow: hidden;
}
.canvas-svg {
  position: absolute;
  top: 0; left: 0;
  width: 100%; height: 100%;
  pointer-events: none;
  z-index: 1;
}
.canvas-svg .conn-label-group { pointer-events: all; cursor: grab; }
.canvas-svg .conn-label-group:active { cursor: grabbing; }
.canvas-svg .conn-path {
  stroke: var(--border);
  stroke-width: 2;
  fill: none;
  transition: stroke 0.4s, stroke-width 0.3s;
}
.canvas-svg .conn-path.heat-green { stroke: var(--green); stroke-width: 2.5; }
.canvas-svg .conn-path.heat-yellow { stroke: var(--yellow); stroke-width: 2.5; stroke-dasharray: 8 4; }
.canvas-svg .conn-path.heat-red { stroke: var(--red); stroke-width: 3; stroke-dasharray: 6 3; }
.canvas-svg .conn-path.ripple { stroke: var(--accent); stroke-width: 3; }
.canvas-svg .conn-path.conn-selected { stroke: var(--accent); stroke-width: 2.5; }

/* Canvas Legend */
.canvas-legend {
  position: absolute;
  top: 12px;
  right: 12px;
  background: var(--panel-bg);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 8px 10px;
  font-size: 10px;
  z-index: 5;
  opacity: 0.9;
  transition: opacity 0.2s;
}
.canvas-legend:hover { opacity: 1; }
.legend-title {
  font-weight: 600;
  font-size: 9px;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  color: var(--text-secondary);
  margin-bottom: 6px;
  display: flex;
  align-items: center;
  gap: 4px;
}
.legend-title svg { width: 12px; height: 12px; }
.legend-item {
  display: flex;
  align-items: center;
  gap: 6px;
  margin-bottom: 3px;
  color: var(--text-secondary);
}
.legend-item svg { width: 12px; height: 12px; }
.legend-swatch {
  width: 12px;
  height: 3px;
  border-radius: 2px;
  flex-shrink: 0;
}
.legend-dot {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  border: 2px solid;
  flex-shrink: 0;
}
.legend-divider {
  height: 1px;
  background: var(--border);
  margin: 5px 0;
}

/* Canvas Nodes */
.node {
  position: absolute;
  width: 152px;
  background: var(--surface);
  border: 2px solid var(--border);
  padding: 0;
  cursor: pointer;
  z-index: 2;
  transition: all 0.2s;
  user-select: none;
}
/* Shape variations per category */
.node[data-shape="rectangle"] { border-radius: 4px; }
.node[data-shape="cylinder"] { border-radius: 4px 4px 14px 14px; }
.node[data-shape="pill"] { border-radius: 16px; }
.node[data-shape="hexish"] { border-radius: 12px 4px 12px 4px; }
.node[data-shape="stadium"] { border-radius: 20px; }

.node:hover { border-color: var(--text-secondary); z-index: 3; }
.node.selected { border-color: var(--accent); box-shadow: 0 0 0 2px rgba(99,102,241,0.3); z-index: 4; }
.node.dragging { opacity: 0.85; z-index: 10; cursor: grabbing; box-shadow: 0 8px 32px rgba(0,0,0,0.5); transition: none; }

.node-body {
  padding: 8px 10px 10px;
  position: relative;
}
/* Variant button on node (right side) */
.node-variant-btn {
  position: absolute;
  top: 4px;
  right: 4px;
  width: 20px;
  height: 20px;
  background: var(--panel-bg);
  border: 1px solid var(--border);
  border-radius: 4px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  opacity: 0;
  transition: opacity 0.15s, background 0.15s;
  z-index: 5;
}
.node-variant-btn svg { width: 12px; height: 12px; }
.node:hover .node-variant-btn { opacity: 0.7; }
.node-variant-btn:hover { opacity: 1 !important; background: var(--accent); border-color: var(--accent); }
/* Node dropdown overlays (shared) */
.node-dropdown {
  position: absolute;
  margin-top: 4px;
  background: var(--panel-bg);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 4px;
  min-width: 160px;
  z-index: 20;
  box-shadow: 0 8px 24px rgba(0,0,0,0.4);
}
.node-dropdown.left { top: 100%; left: 0; }
.node-dropdown.right { top: 100%; right: 0; }
/* Legacy alias */
.swap-dropdown { position: absolute; top: 100%; right: 0; margin-top: 4px; background: var(--panel-bg); border: 1px solid var(--border); border-radius: var(--radius); padding: 4px; min-width: 160px; z-index: 20; box-shadow: 0 8px 24px rgba(0,0,0,0.4); }
.swap-option {
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 5px 8px;
  border-radius: 3px;
  font-size: 11px;
  cursor: pointer;
  transition: background 0.1s;
  color: var(--text-primary);
}
.swap-option:hover { background: var(--surface); }
.swap-option.current { color: var(--accent); font-weight: 600; }
.swap-option svg { width: 12px; height: 12px; }
.swap-option-sub { font-size: 9px; color: var(--text-secondary); margin-left: auto; }
.node-header {
  display: flex;
  align-items: center;
  gap: 6px;
  margin-bottom: 4px;
}
.node-icon {
  width: 20px;
  height: 20px;
  flex-shrink: 0;
  display: flex;
  align-items: center;
  justify-content: center;
}
.node-icon svg { width: 18px; height: 18px; }
.node-name { font-weight: 600; font-size: 12px; line-height: 1.2; }
.node-variant { font-size: 10px; color: var(--text-secondary); margin-left: 26px; }
.node-mini-metrics {
  display: flex;
  gap: 3px;
  margin-top: 6px;
}
.node-mini-bar {
  flex: 1;
  height: 3px;
  background: var(--border);
  border-radius: 2px;
  overflow: hidden;
}
.node-mini-fill {
  height: 100%;
  border-radius: 2px;
  transition: width 0.4s ease, background-color 0.4s ease;
}

/* Heatmap borders */
.node.heatmap-green { border-color: var(--green); box-shadow: 0 0 10px rgba(34,197,94,0.3); }
.node.heatmap-yellow { border-color: var(--yellow); box-shadow: 0 0 10px rgba(234,179,8,0.3); }
.node.heatmap-red { border-color: var(--red); box-shadow: 0 0 10px rgba(239,68,68,0.3); }
.node.selected.heatmap-green { box-shadow: 0 0 0 2px rgba(34,197,94,0.3), 0 0 10px rgba(34,197,94,0.2); }
.node.selected.heatmap-yellow { box-shadow: 0 0 0 2px rgba(234,179,8,0.3), 0 0 10px rgba(234,179,8,0.2); }
.node.selected.heatmap-red { box-shadow: 0 0 0 2px rgba(239,68,68,0.3), 0 0 10px rgba(239,68,68,0.2); }

/* Tooltip */
.node-tooltip {
  display: none;
  position: absolute;
  bottom: calc(100% + 8px);
  left: 50%;
  transform: translateX(-50%);
  background: var(--panel-bg);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 8px 10px;
  font-size: 11px;
  white-space: nowrap;
  z-index: 10;
  pointer-events: none;
  box-shadow: 0 4px 12px rgba(0,0,0,0.4);
}
.node:hover .node-tooltip { display: block; }
.tooltip-header { display: flex; align-items: center; gap: 5px; margin-bottom: 3px; }
.tooltip-header svg { width: 14px; height: 14px; }
.tooltip-metrics { display: flex; gap: 10px; margin-top: 4px; }
.tooltip-metric { color: var(--text-secondary); }
.tooltip-metric span { color: var(--text-primary); font-weight: 500; }

/* Canvas empty state hint */
.canvas-hint {
  position: absolute;
  bottom: 72px;
  left: 50%;
  transform: translateX(-50%);
  color: var(--text-secondary);
  font-size: 11px;
  opacity: 0.5;
  pointer-events: none;
  display: flex;
  align-items: center;
  gap: 6px;
}
.canvas-hint svg { width: 14px; height: 14px; }

/* ═══════════════ INSPECTOR ═══════════════ */
.inspector {
  width: var(--inspector-w);
  min-width: var(--inspector-w);
  background: var(--panel-bg);
  border-left: 1px solid var(--border);
  display: flex;
  flex-direction: column;
  transition: width 0.2s, min-width 0.2s, opacity 0.2s;
  overflow: hidden;
}
.inspector.collapsed { width: 0; min-width: 0; opacity: 0; pointer-events: none; }
.inspector-header {
  padding: 10px 12px;
  border-bottom: 1px solid var(--border);
  font-weight: 600;
  font-size: 12px;
  color: var(--text-secondary);
  text-transform: uppercase;
  letter-spacing: 0.5px;
  display: flex;
  align-items: center;
  gap: 6px;
}
.inspector-header svg { width: 14px; height: 14px; }
.inspector-content {
  flex: 1;
  overflow-y: auto;
  padding: 12px;
}
.inspector-content::-webkit-scrollbar { width: 4px; }
.inspector-content::-webkit-scrollbar-track { background: transparent; }
.inspector-content::-webkit-scrollbar-thumb { background: var(--border); border-radius: 2px; }
.inspector-empty {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 100%;
  color: var(--text-secondary);
  font-size: 12px;
  text-align: center;
  padding: 20px;
  gap: 8px;
}
.inspector-empty svg { width: 32px; height: 32px; opacity: 0.3; }
.insp-header {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 4px;
}
.insp-header-btn {
  width: 28px;
  height: 28px;
  display: flex;
  align-items: center;
  justify-content: center;
  border: 1px solid var(--border);
  border-radius: var(--radius);
  background: var(--surface);
  cursor: pointer;
  transition: all 0.15s;
  flex-shrink: 0;
}
.insp-header-btn:hover { border-color: var(--text-secondary); }
.insp-header-btn.active { border-color: var(--accent); background: rgba(99, 102, 241, 0.1); }
.insp-header-btn svg { width: 16px; height: 16px; }
.insp-header-center {
  flex: 1;
  min-width: 0;
}
.insp-name { font-size: 16px; font-weight: 700; }
.insp-variant-label { font-size: 11px; color: var(--text-secondary); }
.insp-category { font-size: 11px; color: var(--text-secondary); margin-bottom: 12px; display: flex; align-items: center; gap: 6px; }
.insp-cat-dot { width: 8px; height: 8px; border-radius: 50%; }
/* Inspector header dropdowns */
.insp-header-dropdown {
  display: none;
  position: fixed;
  background: var(--panel-bg);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 6px 0;
  min-width: 240px;
  max-width: 280px;
  z-index: 1000;
  box-shadow: 0 4px 16px rgba(0,0,0,0.4);
  animation: metricExpand 0.15s ease-out;
}
.insp-header-dropdown.visible { display: block; }
.insp-dd-item {
  padding: 8px 12px;
  cursor: pointer;
  transition: background 0.1s;
  border-left: 3px solid transparent;
}
.insp-dd-item:hover { background: var(--surface); }
.insp-dd-item.current {
  border-left-color: var(--accent);
  background: rgba(99, 102, 241, 0.05);
}
.insp-dd-item-header {
  display: flex;
  align-items: center;
  gap: 6px;
  font-size: 12px;
  font-weight: 500;
}
.insp-dd-item-header svg { width: 14px; height: 14px; }
.insp-dd-item-sub {
  font-size: 10px;
  color: var(--text-secondary);
  font-weight: 400;
}
.insp-dd-item-current {
  font-size: 9px;
  color: var(--accent);
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.3px;
}
.insp-dd-metrics {
  display: flex;
  gap: 4px;
  margin-top: 5px;
  flex-wrap: wrap;
}
.insp-dd-metric {
  font-size: 9px;
  padding: 1px 5px;
  border-radius: 3px;
  background: var(--surface);
  border: 1px solid var(--border);
  display: inline-flex;
  align-items: center;
  gap: 2px;
}
.insp-dd-metric svg { width: 10px; height: 10px; flex-shrink: 0; }
.insp-dd-metric.positive { color: var(--green); border-color: rgba(34,197,94,0.3); }
.insp-dd-metric.negative { color: var(--red); border-color: rgba(239,68,68,0.3); }
.insp-dd-metric.neutral { color: var(--text-secondary); }
.insp-dd-rec {
  padding: 6px 12px;
  margin-top: 2px;
  border-top: 1px solid var(--border);
  font-size: 10px;
  color: var(--text-secondary);
  display: flex;
  align-items: center;
  gap: 4px;
}
.insp-dd-rec svg { width: 10px; height: 10px; }
.insp-section { margin-bottom: 14px; }
.insp-section-title {
  font-size: 10px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  color: var(--text-secondary);
  margin-bottom: 6px;
  display: flex;
  align-items: center;
  gap: 5px;
}
.insp-section-title svg { width: 12px; height: 12px; }
.insp-select {
  width: 100%;
  background: var(--surface);
  border: 1px solid var(--border);
  color: var(--text-primary);
  padding: 6px 8px;
  border-radius: var(--radius);
  font-family: inherit;
  font-size: 12px;
  cursor: pointer;
  outline: none;
}
.insp-select:focus { border-color: var(--accent); }

/* Metric bars in inspector */
.metric-row { margin-bottom: 0; }
.metric-label {
  display: flex;
  justify-content: space-between;
  font-size: 11px;
  margin-bottom: 3px;
}
.metric-name { color: var(--text-secondary); display: flex; align-items: center; gap: 4px; }
.metric-name svg { width: 11px; height: 11px; }
.metric-value { font-weight: 600; }
.metric-bar-track {
  height: 6px;
  background: var(--surface);
  border-radius: 3px;
  overflow: hidden;
  position: relative;
}
.metric-bar-fill {
  height: 100%;
  border-radius: 3px;
  transition: width 0.5s cubic-bezier(0.4, 0, 0.2, 1), background-color 0.5s;
}

/* Metric filter dropdown */
.metric-filter-wrap {
  position: relative;
  display: inline-block;
}
.metric-filter-btn {
  background: none;
  border: 1px solid transparent;
  color: var(--text-secondary);
  cursor: pointer;
  padding: 2px 5px;
  border-radius: var(--radius);
  display: flex;
  align-items: center;
  gap: 3px;
  font-size: 10px;
  font-family: inherit;
  transition: all 0.15s;
  margin-left: auto;
}
.metric-filter-btn:hover { color: var(--accent); border-color: var(--border); }
.metric-filter-btn.active { color: var(--accent); background: rgba(99, 102, 241, 0.1); border-color: var(--accent); }
.metric-filter-btn svg { width: 10px; height: 10px; }
.metric-filter-menu {
  display: none;
  position: fixed;
  background: var(--panel-bg);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 6px 0;
  min-width: 200px;
  z-index: 1000;
  box-shadow: 0 4px 16px rgba(0,0,0,0.4);
  animation: metricExpand 0.15s ease-out;
}
.metric-filter-menu.visible { display: block; }
.metric-filter-actions {
  display: flex;
  gap: 4px;
  padding: 0 8px 6px;
  border-bottom: 1px solid var(--border);
  margin-bottom: 4px;
}
.metric-filter-action {
  background: none;
  border: none;
  color: var(--accent);
  font-size: 10px;
  font-family: inherit;
  cursor: pointer;
  padding: 2px 6px;
  border-radius: 3px;
  transition: background 0.15s;
}
.metric-filter-action:hover { background: rgba(99, 102, 241, 0.15); }
.metric-filter-item {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 4px 10px;
  cursor: pointer;
  font-size: 11px;
  color: var(--text-secondary);
  transition: background 0.1s;
}
.metric-filter-item:hover { background: var(--surface); }
.metric-filter-check {
  width: 14px;
  height: 14px;
  border: 1.5px solid var(--border);
  border-radius: 3px;
  display: flex;
  align-items: center;
  justify-content: center;
  flex-shrink: 0;
  transition: all 0.15s;
}
.metric-filter-item.checked .metric-filter-check {
  background: var(--accent);
  border-color: var(--accent);
}
.metric-filter-check svg { width: 10px; height: 10px; }
.metric-filter-name { display: flex; align-items: center; gap: 4px; flex: 1; }
.metric-filter-name svg { width: 11px; height: 11px; }
.metric-filter-val {
  font-size: 10px;
  font-weight: 600;
  margin-left: auto;
}
.metric-section-title-row {
  display: flex;
  align-items: center;
  width: 100%;
}

/* Metric explanation dropdown */
.metric-row-wrap { margin-bottom: 8px; }
.metric-info-btn {
  background: none;
  border: none;
  color: var(--text-secondary);
  cursor: pointer;
  padding: 0;
  width: 14px;
  height: 14px;
  display: flex;
  align-items: center;
  justify-content: center;
  opacity: 0.5;
  transition: opacity 0.15s, color 0.15s;
  flex-shrink: 0;
}
.metric-info-btn:hover { opacity: 1; color: var(--accent); }
.metric-info-btn svg { width: 11px; height: 11px; }
.metric-explanation {
  display: none;
  margin-top: 6px;
  padding: 8px 10px;
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  font-size: 11px;
  line-height: 1.5;
  animation: metricExpand 0.2s ease-out;
}
.metric-explanation.visible { display: block; }
@keyframes metricExpand {
  from { opacity: 0; transform: translateY(-4px); }
  to { opacity: 1; transform: translateY(0); }
}
.metric-expl-reason {
  color: var(--text-primary);
  margin-bottom: 6px;
}
.metric-expl-factors {
  list-style: none;
  padding: 0;
  margin: 0;
  display: flex;
  flex-direction: column;
  gap: 3px;
}
.metric-expl-factors li {
  color: var(--text-secondary);
  font-size: 10px;
  padding-left: 12px;
  position: relative;
}
.metric-expl-factors li::before {
  content: '›';
  position: absolute;
  left: 2px;
  color: var(--accent);
  font-weight: 600;
}

/* Pros/Cons */
.pros-cons { display: flex; flex-direction: column; gap: 4px; }
.pro, .con { font-size: 11px; display: flex; gap: 4px; align-items: flex-start; }
.pro::before { content: '+'; color: var(--green); font-weight: 700; flex-shrink: 0; }
.con::before { content: '−'; color: var(--red); font-weight: 700; flex-shrink: 0; }

/* Data Context */
.data-context-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
}
.data-context-edit {
  font-size: 9px;
  color: var(--accent);
  cursor: pointer;
  opacity: 0.7;
  display: flex;
  align-items: center;
  gap: 3px;
}
.data-context-edit:hover { opacity: 1; }
.data-context-edit svg { width: 10px; height: 10px; }
.data-item {
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: 4px;
  padding: 6px 8px;
  margin-bottom: 6px;
  transition: border-color 0.3s;
}
.data-item.fit-great { border-left: 3px solid var(--green); }
.data-item.fit-good { border-left: 3px solid var(--green); opacity: 0.85; }
.data-item.fit-tradeoff { border-left: 3px solid var(--yellow); }
.data-item.fit-poor { border-left: 3px solid var(--red); }
.data-item.fit-risky { border-left: 3px solid var(--red); }
.data-item-header {
  display: flex;
  align-items: center;
  gap: 5px;
  margin-bottom: 2px;
  font-size: 11px;
  font-weight: 500;
}
.data-item-header svg { width: 11px; height: 11px; }
.fit-badge {
  font-size: 9px;
  font-weight: 600;
  padding: 1px 5px;
  border-radius: 3px;
  margin-left: auto;
  text-transform: uppercase;
  letter-spacing: 0.3px;
}
.fit-badge.great { background: rgba(34,197,94,0.15); color: var(--green); }
.fit-badge.good { background: rgba(34,197,94,0.1); color: var(--green); }
.fit-badge.tradeoff { background: rgba(234,179,8,0.15); color: var(--yellow); }
.fit-badge.poor { background: rgba(239,68,68,0.15); color: var(--red); }
.fit-badge.risky { background: rgba(239,68,68,0.15); color: var(--red); }
.data-item-note {
  font-size: 10px;
  color: var(--text-secondary);
  line-height: 1.4;
  margin-left: 16px;
}

/* Code Pattern */
.code-pattern {
  background: var(--canvas-bg);
  border: 1px solid var(--border);
  border-radius: 4px;
  padding: 8px 10px;
  font-family: 'SF Mono', 'Fira Code', 'Cascadia Code', monospace;
  font-size: 10px;
  line-height: 1.5;
  color: var(--text-secondary);
  overflow-x: auto;
  white-space: pre;
  tab-size: 2;
}
.code-pattern .kw { color: #c084fc; }
.code-pattern .fn { color: #60a5fa; }
.code-pattern .str { color: #4ade80; }
.code-pattern .cm { color: #6b7280; font-style: italic; }
.code-pattern .num { color: #fbbf24; }

/* Connection Labels */
.conn-label-group { cursor: pointer; }
.conn-label-group:hover .conn-label-bg { fill: var(--surface); }
.conn-label-bg {
  fill: var(--panel-bg);
  stroke: var(--border);
  stroke-width: 1;
  rx: 4;
  transition: fill 0.15s;
}
.conn-label-bg.selected { stroke: var(--accent); stroke-width: 1.5; }
.conn-label-text {
  fill: var(--text-secondary);
  font-size: 9px;
  font-family: 'Inter', system-ui, sans-serif;
  font-weight: 500;
  text-anchor: middle;
  dominant-baseline: central;
  pointer-events: none;
}
.conn-label-icon {
  fill: none;
  stroke: var(--text-secondary);
  stroke-width: 1;
}
.conn-label-group.selected .conn-label-text { fill: var(--accent); }

/* Connection detail in inspector */
/* Connection inspector — header with clickable endpoints */
.conn-header {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 10px;
}
.conn-endpoint {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 4px;
  cursor: pointer;
  flex: 1;
  min-width: 0;
  padding: 6px 4px;
  border-radius: var(--radius);
  transition: background 0.15s;
}
.conn-endpoint:hover { background: var(--surface); }
.conn-ep-icon {
  width: 32px;
  height: 32px;
  display: flex;
  align-items: center;
  justify-content: center;
  border: 2px solid var(--border);
  border-radius: 50%;
  background: var(--surface);
}
.conn-ep-icon svg { width: 16px; height: 16px; }
.conn-ep-name {
  font-size: 11px;
  font-weight: 600;
  text-align: center;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  max-width: 100%;
}
.conn-header-arrow { flex-shrink: 0; color: var(--text-secondary); }
.conn-header-arrow svg { width: 14px; height: 14px; }
/* Connection metadata badges */
.conn-meta {
  display: flex;
  align-items: center;
  gap: 6px;
  margin-bottom: 8px;
}
.conn-protocol-badge {
  display: inline-flex;
  align-items: center;
  gap: 3px;
  background: rgba(99, 102, 241, 0.1);
  border: 1px solid rgba(99, 102, 241, 0.3);
  border-radius: 3px;
  padding: 2px 8px;
  font-size: 10px;
  font-weight: 600;
  color: var(--accent);
}
.conn-role-tag {
  font-size: 10px;
  font-weight: 500;
  color: var(--text-secondary);
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: 3px;
  padding: 2px 8px;
}
/* Connection direction text */
.conn-direction-text {
  font-size: 11px;
  color: var(--text-secondary);
  line-height: 1.5;
  margin-bottom: 10px;
  font-style: italic;
  padding-left: 2px;
}
/* Connection property chips */
.conn-props-strip {
  display: flex;
  flex-direction: column;
  gap: 4px;
  margin-bottom: 10px;
}
.conn-prop-chip {
  display: flex;
  align-items: center;
  gap: 6px;
  font-size: 11px;
  padding: 5px 8px;
  background: var(--surface);
  border-radius: 4px;
  border-left: 3px solid var(--border);
}
.conn-prop-chip svg { width: 11px; height: 11px; flex-shrink: 0; }
.conn-prop-chip-label {
  color: var(--text-secondary);
  font-weight: 500;
  min-width: 60px;
  flex-shrink: 0;
}
.conn-prop-chip-val { color: var(--text-primary); }
.conn-prop-chip.positive { border-left-color: var(--green); }
.conn-prop-chip.positive .conn-prop-chip-val { color: var(--green); }
.conn-prop-chip.negative { border-left-color: var(--red); }
.conn-prop-chip.negative .conn-prop-chip-val { color: var(--red); }
/* Code pattern block */
.conn-code-pattern {
  background: var(--canvas-bg);
  border: 1px solid var(--border);
  border-radius: 4px;
  padding: 8px 10px;
  font-family: 'SF Mono', 'Fira Code', 'Cascadia Code', monospace;
  font-size: 10px;
  line-height: 1.5;
  color: var(--text-secondary);
  overflow-x: auto;
  white-space: pre;
  tab-size: 2;
  margin-top: 8px;
}
.conn-code-pattern .kw { color: #c084fc; }
.conn-code-pattern .fn { color: #60a5fa; }
.conn-code-pattern .str { color: #4ade80; }
.conn-code-pattern .cm { color: #6b7280; font-style: italic; }
.conn-code-pattern .num { color: #fbbf24; }
/* Connection footer — quick links to endpoints */
.conn-footer {
  display: flex;
  gap: 6px;
  margin-top: 12px;
  padding-top: 10px;
  border-top: 1px solid var(--border);
}
.conn-footer-link {
  flex: 1;
  display: flex;
  align-items: center;
  gap: 4px;
  font-size: 10px;
  color: var(--text-secondary);
  cursor: pointer;
  padding: 5px 8px;
  border: 1px solid var(--border);
  border-radius: var(--radius);
  transition: all 0.15s;
  justify-content: center;
}
.conn-footer-link:hover { border-color: var(--accent); color: var(--text-primary); }
.conn-footer-link svg { width: 11px; height: 11px; }
.conn-summary {
  font-size: 11px;
  color: var(--text-secondary);
  line-height: 1.6;
  padding: 6px 0;
}


/* ═══════════════ DASHBOARD ═══════════════ */
.dashboard {
  position: absolute;
  bottom: 0;
  left: 0;
  right: 0;
  background: var(--panel-bg);
  border-top: 1px solid var(--border);
  padding: 6px 12px;
  display: flex;
  flex-direction: column;
  z-index: 10;
}
.dashboard-title {
  font-size: 10px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  color: var(--text-secondary);
  margin-bottom: 4px;
  display: flex;
  align-items: center;
  gap: 5px;
}
.dashboard-title svg { width: 13px; height: 13px; }
.dashboard-bars {
  display: flex;
  gap: 6px;
  align-items: center;
}
.dash-bar-group {
  flex: 1;
  display: flex;
  flex-direction: column;
  gap: 2px;
}
.dash-bar-label {
  font-size: 9px;
  color: var(--text-secondary);
  text-align: center;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 3px;
}
.dash-bar-label svg { width: 10px; height: 10px; }
.dash-bar-track {
  height: 16px;
  background: var(--surface);
  border-radius: 3px;
  overflow: hidden;
  position: relative;
}
.dash-bar-fill {
  height: 100%;
  border-radius: 3px;
  transition: width 0.6s cubic-bezier(0.4, 0, 0.2, 1), background-color 0.6s;
  position: relative;
}
.dash-bar-value {
  position: absolute;
  right: 4px;
  top: 50%;
  transform: translateY(-50%);
  font-size: 9px;
  font-weight: 600;
  color: rgba(255,255,255,0.8);
}

/* Dashboard expand toggle */
.dash-expand-btn {
  background: none;
  border: 1px solid var(--border);
  border-radius: 3px;
  cursor: pointer;
  padding: 1px 4px;
  margin-left: auto;
  display: flex;
  align-items: center;
  color: var(--text-secondary);
  transition: all 0.15s;
}
.dash-expand-btn:hover { border-color: var(--text-secondary); color: var(--text-primary); }
.dash-expand-chevron { width: 10px; height: 10px; transition: transform 0.2s; }
.dashboard.expanded .dash-expand-chevron { transform: rotate(180deg); }

/* ═══════════════ DASHBOARD OVERLAY ═══════════════ */
.dash-overlay {
  display: none;
  position: absolute;
  top: 0; left: 0; right: 0; bottom: 0;
  background: rgba(15, 17, 23, 0.97);
  z-index: 20;
  flex-direction: column;
  overflow-y: auto;
  padding: 20px 24px;
}
.dash-overlay.visible { display: flex; }
.dash-overlay::-webkit-scrollbar { width: 4px; }
.dash-overlay::-webkit-scrollbar-track { background: transparent; }
.dash-overlay::-webkit-scrollbar-thumb { background: var(--border); border-radius: 2px; }
.dash-overlay-header {
  font-size: 12px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  color: var(--text-secondary);
  margin-bottom: 16px;
  display: flex;
  align-items: center;
  gap: 6px;
}
.dash-overlay-header svg { width: 14px; height: 14px; }
.dash-overlay-close {
  margin-left: auto;
  background: none;
  border: 1px solid var(--border);
  border-radius: 3px;
  color: var(--text-secondary);
  font-size: 16px;
  cursor: pointer;
  width: 24px;
  height: 24px;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.15s;
}
.dash-overlay-close:hover { border-color: var(--text-primary); color: var(--text-primary); }
.dash-overlay-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
  gap: 16px;
  flex: 1;
}
/* Each category card in the overlay */
.dash-card {
  background: var(--panel-bg);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 12px;
  display: flex;
  flex-direction: column;
  gap: 8px;
}
.dash-card-header {
  display: flex;
  align-items: center;
  gap: 6px;
  font-size: 12px;
  font-weight: 600;
}
.dash-card-header svg { width: 14px; height: 14px; }
.dash-card-score {
  font-size: 20px;
  font-weight: 700;
  margin-left: auto;
}
.dash-card-bar {
  height: 8px;
  background: var(--surface);
  border-radius: 4px;
  overflow: hidden;
}
.dash-card-fill {
  height: 100%;
  border-radius: 4px;
  transition: width 0.6s cubic-bezier(0.4, 0, 0.2, 1);
}
.dash-card-desc {
  font-size: 10px;
  color: var(--text-secondary);
  line-height: 1.4;
}
.dash-card-factors {
  display: flex;
  flex-direction: column;
  gap: 4px;
  margin-top: 4px;
}
.dash-card-factor {
  display: flex;
  align-items: center;
  gap: 6px;
  font-size: 10px;
  color: var(--text-secondary);
  position: relative;
}
.dash-card-factor-comp {
  width: 72px;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  flex-shrink: 0;
}
.dash-card-factor-icon {
  width: 14px;
  flex-shrink: 0;
  display: flex;
  align-items: center;
}
.dash-card-factor-icon svg { width: 11px; height: 11px; }
.dash-card-factor-bar {
  flex: 1;
  height: 6px;
  background: var(--surface);
  border-radius: 3px;
  overflow: hidden;
  min-width: 30px;
  display: block;
}
.dash-card-factor-fill {
  display: block;
  height: 100%;
  border-radius: 3px;
  transition: width 0.4s;
}
.dash-card-factor-val {
  width: 22px;
  text-align: right;
  font-weight: 600;
  font-size: 10px;
  flex-shrink: 0;
}
/* Factor tooltip */
.dash-card-factor-tip {
  display: none;
  position: absolute;
  bottom: calc(100% + 4px);
  left: 0;
  background: var(--panel-bg);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 6px 10px;
  font-size: 10px;
  color: var(--text-primary);
  white-space: nowrap;
  z-index: 5;
  box-shadow: 0 2px 8px rgba(0,0,0,0.3);
  pointer-events: none;
}
.dash-card-factor:hover .dash-card-factor-tip { display: block; }

/* ═══════════════ PROMPT OUTPUT ═══════════════ */
.prompt-section {
  position: fixed;
  bottom: 0;
  left: 0;
  right: 0;
  z-index: 200;
  transform: translateY(calc(100% - 32px));
  transition: transform 0.3s;
}
.prompt-section.open { transform: translateY(0); }
.prompt-toggle {
  background: var(--accent);
  color: white;
  border: none;
  padding: 6px 16px;
  font-size: 11px;
  font-weight: 600;
  font-family: inherit;
  cursor: pointer;
  border-radius: var(--radius) var(--radius) 0 0;
  margin-left: 16px;
  display: flex;
  align-items: center;
  gap: 5px;
}
.prompt-toggle svg { width: 14px; height: 14px; }
.prompt-body {
  background: var(--panel-bg);
  border-top: 1px solid var(--accent);
  padding: 12px 16px;
  max-height: 180px;
  display: flex;
  gap: 12px;
}
.prompt-text {
  flex: 1;
  font-size: 12px;
  color: var(--text-secondary);
  line-height: 1.6;
  overflow-y: auto;
  font-family: 'Inter', system-ui, sans-serif;
}
.prompt-copy-btn {
  background: var(--accent);
  color: white;
  border: none;
  padding: 6px 14px;
  border-radius: var(--radius);
  font-size: 11px;
  font-weight: 600;
  font-family: inherit;
  cursor: pointer;
  align-self: flex-start;
  white-space: nowrap;
  transition: background 0.15s;
  display: flex;
  align-items: center;
  gap: 4px;
}
.prompt-copy-btn svg { width: 12px; height: 12px; }
.prompt-copy-btn:hover { background: var(--accent-hover); }

/* ═══════════════ RIPPLE ANIMATION ═══════════════ */
@keyframes ripplePulse {
  0% { box-shadow: 0 0 0 0 rgba(99,102,241,0.4); }
  70% { box-shadow: 0 0 0 10px rgba(99,102,241,0); }
  100% { box-shadow: 0 0 0 0 rgba(99,102,241,0); }
}
.node.rippling { animation: ripplePulse 0.4s ease-out; }

/* ═══════════════ INFO POPUP ═══════════════ */
.info-popup-overlay {
  display: none;
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  background: rgba(0,0,0,0.5);
  z-index: 300;
  align-items: center;
  justify-content: center;
}
.info-popup-overlay.visible { display: flex; }
.info-popup {
  background: var(--panel-bg);
  border: 1px solid var(--border);
  border-radius: 8px;
  padding: 20px;
  max-width: 420px;
  width: 90%;
  box-shadow: 0 16px 48px rgba(0,0,0,0.5);
}
.info-popup-header {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 12px;
  font-size: 15px;
  font-weight: 700;
}
.info-popup-header svg { width: 22px; height: 22px; }
.info-popup-close {
  margin-left: auto;
  background: none;
  border: none;
  color: var(--text-secondary);
  cursor: pointer;
  font-size: 18px;
  padding: 2px 6px;
  border-radius: 4px;
  display: flex;
  align-items: center;
  transition: color 0.15s, background 0.15s;
}
.info-popup-close:hover { color: var(--text-primary); background: var(--surface); }
.info-popup-close svg { width: 14px; height: 14px; }
.info-popup-body {
  font-size: 12px;
  line-height: 1.6;
  color: var(--text-secondary);
}
.info-popup-body strong { color: var(--text-primary); font-weight: 600; }
.info-popup-body p { margin: 0 0 8px; }
.info-popup-section {
  margin-bottom: 10px;
}
.info-popup-section-title {
  font-size: 10px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  color: var(--text-secondary);
  margin-bottom: 4px;
}
.info-popup-list {
  margin: 0;
  padding-left: 16px;
}
.info-popup-list li { margin-bottom: 3px; }

/* Dashboard info icon */
.dash-info-btn {
  background: none;
  border: none;
  color: var(--text-secondary);
  cursor: pointer;
  padding: 0;
  display: inline-flex;
  align-items: center;
  opacity: 0.4;
  transition: opacity 0.15s, color 0.15s;
}
.dash-info-btn:hover { opacity: 1; color: var(--accent); }
.dash-info-btn svg { width: 9px; height: 9px; }

/* Clickable category icon on nodes */
.node-icon.clickable { cursor: pointer; transition: transform 0.15s; z-index: 6; position: relative; }
.node-icon.clickable:hover { transform: scale(1.2); }
.legend-item.clickable { cursor: pointer; transition: color 0.15s; }
.legend-item.clickable:hover { color: var(--text-primary) !important; }

/* Connection Health Indicator */
.conn-health-indicator { margin-top: 4px; }
.conn-health-badge {
  display: inline-flex;
  align-items: center;
  gap: 6px;
  padding: 4px 10px;
  border-radius: 4px;
  font-size: 11px;
  font-weight: 600;
  margin-bottom: 6px;
}
.conn-health-dot {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  flex-shrink: 0;
}
.conn-health-desc {
  font-size: 11px;
  color: var(--text-secondary);
  line-height: 1.5;
  margin-bottom: 8px;
}
.conn-health-endpoints {
  display: flex;
  flex-direction: column;
  gap: 4px;
  margin-bottom: 6px;
}
.conn-health-ep {
  display: flex;
  align-items: center;
  gap: 6px;
  font-size: 11px;
  color: var(--text-primary);
  background: var(--surface);
  padding: 4px 8px;
  border-radius: 4px;
}
.conn-health-rule {
  font-size: 9px;
  color: var(--text-secondary);
  font-style: italic;
  opacity: 0.7;
}
/* ═══════════════ CONNECTION HEALTH DETAIL ═══════════════ */
.conn-health-info-btn {
  width: 18px; height: 18px;
  border: none; background: none; cursor: pointer;
  color: var(--text-secondary); padding: 0; margin-left: 4px;
  border-radius: 50%; display: flex; align-items: center; justify-content: center;
  flex-shrink: 0; transition: color 0.15s, background 0.15s;
}
.conn-health-info-btn:hover { color: var(--accent); background: var(--accent)15; }
.conn-health-info-btn svg { width: 14px; height: 14px; }
.conn-health-metrics {
  display: none; padding: 6px 8px; margin-top: 4px;
  background: var(--canvas-bg); border-radius: 4px;
  border: 1px solid var(--border);
}
.conn-health-metrics.visible { display: block; }
.conn-health-metric-row {
  display: flex; align-items: center; gap: 6px;
  font-size: 10px; padding: 2px 0;
}
.conn-health-metric-name {
  width: 90px; color: var(--text-secondary); flex-shrink: 0;
}
.conn-health-metric-bar {
  flex: 1; height: 4px; background: var(--surface);
  border-radius: 2px; overflow: hidden; position: relative;
}
.conn-health-metric-fill {
  height: 100%; border-radius: 2px; transition: width 0.3s ease;
}
.conn-health-metric-val {
  width: 28px; text-align: right; font-weight: 600; font-size: 10px; flex-shrink: 0;
}
.conn-health-metric-flag {
  font-size: 9px; font-weight: 600; width: 12px; text-align: center; flex-shrink: 0;
}
.conn-health-metrics-label {
  font-size: 9px; color: var(--text-secondary); margin-bottom: 4px;
  text-transform: uppercase; letter-spacing: 0.5px; font-weight: 600;
}

/* ═══════════════ COLLAPSIBLE SECTIONS ═══════════════ */
.insp-section-title.collapsible {
  cursor: pointer;
  user-select: none;
  transition: color 0.15s;
}
.insp-section-title.collapsible:hover { color: var(--text-primary); }
.section-chevron {
  margin-left: auto;
  display: inline-flex;
  transition: transform 0.2s ease;
}
.section-chevron svg { width: 10px; height: 10px; }
.section-chevron.open { transform: rotate(90deg); }
.insp-section-body.collapsed { display: none; }
/* Collapsible toolbox cards */
.card-header.collapsible {
  cursor: pointer;
  user-select: none;
  transition: opacity 0.15s;
}
.card-header.collapsible:hover { opacity: 1; }
.card-header.collapsible .section-chevron { margin-left: auto; }
.card-details.collapsed { display: none; }

/* ═══════════════ METRIC DELTAS ═══════════════ */
.metric-delta {
  font-size: 10px;
  font-weight: 600;
  margin-left: 4px;
  display: inline-block;
  animation: deltaFadeIn 0.3s ease;
}
@keyframes deltaFadeIn {
  from { opacity: 0; transform: translateY(-4px); }
  to { opacity: 1; transform: translateY(0); }
}
.metric-delta.positive { color: var(--green); }
.metric-delta.negative { color: var(--red); }
.metric-delta.neutral { color: var(--text-secondary); }

/* ═══════════════ ISSUES SUMMARY ═══════════════ */
.issues-badge {
  position: absolute;
  top: -4px;
  right: -4px;
  background: var(--red);
  color: white;
  font-size: 9px;
  font-weight: 700;
  width: 16px;
  height: 16px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  pointer-events: none;
  line-height: 1;
}
.issues-badge.warning { background: var(--yellow); color: #000; }
.issues-badge.hidden { display: none; }
.issues-dropdown {
  position: fixed;
  background: var(--panel-bg);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 4px;
  min-width: 300px;
  z-index: 150;
  box-shadow: 0 8px 24px rgba(0,0,0,0.4);
  display: none;
}
.issues-dropdown.visible { display: block; }
.issues-dropdown-title {
  font-size: 10px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  color: var(--text-secondary);
  padding: 6px 8px 4px;
  display: flex;
  align-items: center;
  gap: 4px;
}
.issues-dropdown-title svg { width: 12px; height: 12px; }
.issues-item {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 6px 8px;
  border-radius: 4px;
  cursor: pointer;
  transition: background 0.1s;
  font-size: 11px;
}
.issues-item:hover { background: var(--surface); }
.issues-item svg { width: 14px; height: 14px; }
.issues-item-dot {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  flex-shrink: 0;
}
.issues-item-name { font-weight: 500; flex: 1; }
.issues-item-detail { color: var(--text-secondary); font-size: 10px; }
.issues-none {
  padding: 12px 8px;
  text-align: center;
  color: var(--text-secondary);
  font-size: 11px;
}

/* ═══════════════ VARIANT HINT ═══════════════ */
.variant-hint {
  background: var(--surface);
  border: 1px solid var(--border);
  border-left: 3px solid var(--accent);
  border-radius: var(--radius);
  padding: 6px 8px;
  margin-top: 6px;
  font-size: 10px;
  color: var(--text-secondary);
  line-height: 1.4;
  display: flex;
  align-items: flex-start;
  gap: 4px;
}
.variant-hint svg { width: 12px; height: 12px; flex-shrink: 0; margin-top: 1px; }
.variant-hint strong { color: var(--accent); font-weight: 600; }
.variant-hint .delta-positive { color: var(--green); font-weight: 600; }
.variant-hint .delta-negative { color: var(--red); font-weight: 600; }

/* ═══════════════ METRIC THRESHOLD ═══════════════ */
.metric-threshold {
  position: absolute;
  top: -1px;
  bottom: -1px;
  width: 1px;
  background: var(--text-secondary);
  opacity: 0.25;
  z-index: 1;
}

/* ═══════════════ DASHBOARD CLICKABLE ═══════════════ */
.dash-bar-track.clickable { cursor: pointer; transition: opacity 0.15s; }
.dash-bar-track.clickable:hover { opacity: 0.85; }
.node.flash-highlight { animation: nodeFlash 0.8s ease; }
@keyframes nodeFlash {
  0%, 100% { box-shadow: 0 0 0 0 rgba(99,102,241,0); }
  50% { box-shadow: 0 0 20px 4px rgba(99,102,241,0.5); }
}
</style>
</head>
<body>

<!-- ═══════════════ TOP BAR ═══════════════ -->
<div class="top-bar">
  <div class="logo">
    <svg viewBox="0 0 18 18" fill="none" stroke="currentColor" stroke-width="1.5"><rect x="2" y="2" width="14" height="14" rx="3"/><circle cx="6" cy="7" r="1.5" fill="currentColor" stroke="none"/><circle cx="12" cy="7" r="1.5" fill="currentColor" stroke="none"/><path d="M6 7h6M9 7v5"/></svg>
    Archie
  </div>
  <div class="arch-name">Sysops Squad Saga Architecture</div>
  <div class="tier-badge" onclick="showTierInfo()" style="cursor:pointer" title="Click for tier details">
    <svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M8 1l2.5 4.5L16 6.5l-4 3.5 1 5.5L8 13l-5 2.5 1-5.5-4-3.5 5.5-1z"/></svg>
    Tier 2 <span class="tier-hint">/ 3</span>
  </div>
  <div class="top-actions">
    <button class="top-btn" id="heatmapToggle" onclick="toggleHeatmap()">
      <svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><circle cx="8" cy="8" r="6"/><circle cx="8" cy="8" r="3" opacity="0.5"/><circle cx="8" cy="8" r="1" fill="currentColor" stroke="none"/></svg>
      Heatmap
    </button>
    <button class="top-btn" id="issuesBtn" onclick="toggleIssues()" style="position:relative">
      <svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M8 2L1 14h14z"/><path d="M8 6v4M8 12v.5"/></svg>
      Issues
      <span class="issues-badge hidden" id="issuesBadge">0</span>
    </button>
    <button class="top-btn" onclick="togglePanel('toolbox')">
      <svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><rect x="2" y="2" width="5" height="12" rx="1"/><rect x="9" y="2" width="5" height="5" rx="1"/><rect x="9" y="9" width="5" height="5" rx="1"/></svg>
      Toolbox
    </button>
    <button class="top-btn" onclick="togglePanel('inspector')">
      <svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><rect x="2" y="2" width="12" height="12" rx="1"/><line x1="8" y1="2" x2="8" y2="14"/><line x1="8" y1="6" x2="14" y2="6"/><line x1="8" y1="10" x2="14" y2="10"/></svg>
      Inspector
    </button>
    <button class="top-btn">
      <svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M3 14V9l5-7 5 7v5"/><path d="M6 14v-3h4v3"/></svg>
      Import
    </button>
    <button class="top-btn">
      <svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M4 2h8l2 3v9H2V5z"/><path d="M5 2v3h6V2"/><circle cx="8" cy="10" r="2"/></svg>
      Export
    </button>
  </div>
</div>

<!-- ═══════════════ MAIN LAYOUT ═══════════════ -->
<div class="main-layout">
  <!-- TOOLBOX -->
  <aside class="toolbox" id="toolbox">
    <div class="toolbox-title">
      <svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><rect x="2" y="2" width="5" height="12" rx="1"/><rect x="9" y="2" width="5" height="5" rx="1"/><rect x="9" y="9" width="5" height="5" rx="1"/></svg>
      Toolbox
    </div>
    <div class="toolbox-tabs">
      <button class="toolbox-tab active" onclick="switchTab(this,'components')">
        <svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><rect x="2" y="2" width="5" height="5" rx="1"/><rect x="9" y="2" width="5" height="5" rx="1"/><rect x="2" y="9" width="5" height="5" rx="1"/><rect x="9" y="9" width="5" height="5" rx="1"/></svg>
        Components
      </button>
      <button class="toolbox-tab" onclick="switchTab(this,'stacks')">
        <svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><rect x="3" y="2" width="10" height="3" rx="1"/><rect x="3" y="7" width="10" height="3" rx="1"/><rect x="3" y="12" width="10" height="3" rx="1"/></svg>
        Stacks
      </button>
      <button class="toolbox-tab" onclick="switchTab(this,'blueprints')">
        <svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 2h12v12H2z"/><path d="M5 5h6M5 8h6M5 11h3"/><circle cx="12" cy="11" r="1" fill="currentColor" stroke="none"/></svg>
        Blueprints
      </button>
    </div>
    <div class="toolbox-content" id="toolboxContent"></div>
  </aside>

  <!-- CANVAS -->
  <main class="canvas" id="canvas">
    <svg class="canvas-svg" id="flowSvg" style="z-index:0"></svg>
    <svg class="canvas-svg" id="canvasSvg"></svg>
    <div id="nodesContainer"></div>
    <!-- Legend -->
    <div class="canvas-legend" id="canvasLegend"></div>
    <div class="canvas-hint">
      <svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><circle cx="8" cy="8" r="6"/><path d="M8 5v3M8 10v1"/></svg>
      Click a component to inspect &middot; Toggle heatmap to see health overlay
    </div>
    <!-- DASHBOARD — inside canvas, at bottom -->
    <div class="dashboard" id="dashboard">
      <div class="dashboard-title">
        <svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><rect x="1" y="8" width="3" height="6" rx="0.5"/><rect x="5.5" y="5" width="3" height="9" rx="0.5"/><rect x="10" y="2" width="3" height="12" rx="0.5"/></svg>
        Architecture Health
        <button class="dash-expand-btn" onclick="toggleDashboardExpand()" title="Show contributing factors">
          <svg class="dash-expand-chevron" viewBox="0 0 10 10" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2.5 4L5 6.5L7.5 4"/></svg>
        </button>
      </div>
      <div class="dashboard-bars" id="dashboardBars"></div>
    </div>
    <!-- DASHBOARD EXPANDED OVERLAY -->
    <div class="dash-overlay" id="dashOverlay">
      <div class="dash-overlay-header">
        <svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><rect x="1" y="8" width="3" height="6" rx="0.5"/><rect x="5.5" y="5" width="3" height="9" rx="0.5"/><rect x="10" y="2" width="3" height="12" rx="0.5"/></svg>
        Architecture Health — 7 Metric Categories
        <button class="dash-overlay-close" onclick="toggleDashboardExpand()" title="Close details">&times;</button>
      </div>
      <div class="dash-overlay-grid" id="dashOverlayGrid"></div>
    </div>
  </main>

  <!-- INSPECTOR -->
  <aside class="inspector" id="inspector">
    <div class="inspector-header">
      <svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><rect x="2" y="2" width="12" height="12" rx="1"/><line x1="8" y1="2" x2="8" y2="14"/><line x1="8" y1="6" x2="14" y2="6"/><line x1="8" y1="10" x2="14" y2="10"/></svg>
      Inspector
    </div>
    <div class="inspector-content" id="inspectorContent">
      <div class="inspector-empty">
        <svg viewBox="0 0 32 32" fill="none" stroke="currentColor" stroke-width="1"><circle cx="16" cy="16" r="12"/><path d="M16 10v6M16 20v1"/></svg>
        Click a component on the canvas to see its details, metrics, and configuration variants.
      </div>
    </div>
  </aside>
</div>

<!-- ═══════════════ PROMPT OUTPUT ═══════════════ -->
<div class="prompt-section" id="promptSection">
  <button class="prompt-toggle" onclick="document.getElementById('promptSection').classList.toggle('open')">
    <svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><rect x="2" y="2" width="12" height="12" rx="2"/><path d="M5 6h6M5 8h6M5 10h4"/></svg>
    Prompt Output
  </button>
  <div class="prompt-body">
    <div class="prompt-text" id="promptText"></div>
    <button class="prompt-copy-btn" onclick="copyPrompt()">
      <svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><rect x="5" y="5" width="9" height="9" rx="1"/><path d="M5 11H3a1 1 0 01-1-1V3a1 1 0 011-1h7a1 1 0 011 1v2"/></svg>
      Copy Prompt
    </button>
  </div>
</div>

<!-- ═══════════════ INFO POPUP ═══════════════ -->
<div class="info-popup-overlay" id="infoPopupOverlay" onclick="if(event.target===this)hideInfoPopup()">
  <div class="info-popup">
    <div class="info-popup-header" id="infoPopupHeader"></div>
    <div class="info-popup-body" id="infoPopupBody"></div>
  </div>
</div>

<!-- Issues Dropdown (fixed position, placed by JS) -->
<div class="issues-dropdown" id="issuesDropdown"></div>

<script>
// ═══════════════ SVG ICONS ═══════════════
const ICONS = {
  // Category icons
  'Compute': '<svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><rect x="4" y="4" width="8" height="8" rx="1"/><line x1="6" y1="2" x2="6" y2="4"/><line x1="10" y1="2" x2="10" y2="4"/><line x1="6" y1="12" x2="6" y2="14"/><line x1="10" y1="12" x2="10" y2="14"/><line x1="2" y1="6" x2="4" y2="6"/><line x1="2" y1="10" x2="4" y2="10"/><line x1="12" y1="6" x2="14" y2="6"/><line x1="12" y1="10" x2="14" y2="10"/></svg>',
  'Data Storage': '<svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><ellipse cx="8" cy="4" rx="5" ry="2"/><path d="M3 4v8c0 1.1 2.24 2 5 2s5-.9 5-2V4"/><path d="M3 8c0 1.1 2.24 2 5 2s5-.9 5-2" opacity="0.5"/></svg>',
  'Caching': '<svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M9 1L4 9h4l-1 6 5-8H8l1-6z" stroke-linejoin="round"/></svg>',
  'Messaging': '<svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 3h12v8H6l-4 3V3z" stroke-linejoin="round"/></svg>',
  'Delivery/Network': '<svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><circle cx="8" cy="8" r="6"/><ellipse cx="8" cy="8" rx="3" ry="6"/><line x1="2" y1="8" x2="14" y2="8"/></svg>',
  'Real-Time': '<svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 8h2l2-4 2 8 2-5 2 3h2"/></svg>',
  'Auth/Security': '<svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M8 1L2 4v4c0 4 2.5 6 6 7 3.5-1 6-3 6-7V4L8 1z"/></svg>',
  'Monitoring': '<svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><rect x="2" y="2" width="12" height="12" rx="1"/><path d="M4 10l3-4 2 2 3-4"/></svg>',
  'Search': '<svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><circle cx="7" cy="7" r="4"/><line x1="10" y1="10" x2="14" y2="14"/></svg>',
  'DevOps': '<svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><circle cx="8" cy="8" r="2"/><path d="M8 2v2M8 12v2M2 8h2M12 8h2M3.8 3.8l1.4 1.4M10.8 10.8l1.4 1.4M3.8 12.2l1.4-1.4M10.8 5.2l1.4-1.4"/></svg>',
  // UI icons
  'is': '<svg viewBox="0 0 10 10" fill="none" stroke="currentColor" stroke-width="1.5"><circle cx="5" cy="5" r="3.5"/></svg>',
  'gain': '<svg viewBox="0 0 10 10" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M5 2v6M2 5l3-3 3 3"/></svg>',
  'cost': '<svg viewBox="0 0 10 10" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M5 8V2M2 5l3 3 3-3"/></svg>',
  'config': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.5"><circle cx="6" cy="6" r="2"/><path d="M6 1v2M6 9v2M1 6h2M9 6h2"/></svg>',
  'metrics': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.5"><rect x="1" y="6" width="2" height="5" rx="0.5"/><rect x="5" y="3" width="2" height="8" rx="0.5"/><rect x="9" y="1" width="2" height="10" rx="0.5"/></svg>',
  'pros': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.5"><circle cx="6" cy="6" r="4.5"/><path d="M4 6h4M6 4v4"/></svg>',
  'cons': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.5"><circle cx="6" cy="6" r="4.5"/><path d="M4 6h4"/></svg>',
  // Dashboard category icons
  'perf': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M2 10l3-5 2 2 3-5"/><path d="M9 2h2v2"/></svg>',
  'cost_dash': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><circle cx="6" cy="6" r="4"/><path d="M6 3v6M4.5 4.5h3M4.5 7.5h3"/></svg>',
  'rel': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M6 1L1.5 4v3.5c0 2.5 1.8 4 4.5 4.5 2.7-.5 4.5-2 4.5-4.5V4L6 1z"/></svg>',
  'ops': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><circle cx="6" cy="6" r="2"/><path d="M6 1v1.5M6 9.5V11M1 6h1.5M9.5 6H11M2.8 2.8l1 1M8.2 8.2l1 1M2.8 9.2l1-1M8.2 3.8l1-1"/></svg>',
  'scale': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M2 10V6l4-4 4 4v4"/></svg>',
  'strat': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><circle cx="6" cy="4" r="2"/><path d="M6 6v4M3 8h6"/></svg>',
  'dev_dash': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M4 3L1 6l3 3M8 3l3 3-3 3"/></svg>',
  // Data context icons
  'data_ctx': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><rect x="1" y="1" width="10" height="10" rx="1"/><path d="M4 4h4M4 6h4M4 8h2"/></svg>',
  'edit': '<svg viewBox="0 0 10 10" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M1 9l6-6 1 1-6 6z"/><path d="M6 3l1-1 2 2-1 1"/></svg>',
  'session': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><circle cx="6" cy="4" r="2.5"/><path d="M2 10c0-2.2 1.8-4 4-4s4 1.8 4 4"/></svg>',
  'counter': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M2 10V5l2-3 2 4 2-2 2 3v3"/></svg>',
  'cache_item': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><rect x="2" y="2" width="8" height="8" rx="1"/><path d="M5 4v4M4 7l1 1 1-1"/></svg>',
  'table': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><rect x="1" y="1" width="10" height="10" rx="1"/><line x1="1" y1="4" x2="11" y2="4"/><line x1="5" y1="4" x2="5" y2="11"/></svg>',
  'message': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M2 2h8v6H5l-3 2V2z"/></svg>',
  'endpoint': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M1 6h4M7 6h4"/><circle cx="6" cy="6" r="2"/></svg>',
  'route': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M2 2l8 8M2 5h3M7 9h3"/></svg>',
  'event': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M7 1L3 7h3l-1 4 4-6H6l1-4z"/></svg>',
  'receipt': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M2 6l3 3 5-5"/></svg>',
  'presence': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><circle cx="6" cy="6" r="3"/><circle cx="6" cy="6" r="1" fill="currentColor" stroke="none"/></svg>',
  'ssl': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><rect x="3" y="5" width="6" height="5" rx="1"/><path d="M4 5V4a2 2 0 014 0v1"/></svg>',
  'ratelimit': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><circle cx="6" cy="6" r="4.5"/><path d="M6 3v3l2 1"/></svg>',
  // Metric-specific icons
  'latency': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><circle cx="6" cy="6" r="4.5"/><path d="M6 3.5v3l2 1.5"/></svg>',
  'throughput': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M1 6h10M8 3l3 3-3 3"/></svg>',
  'cost_eff': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><circle cx="6" cy="6" r="4"/><path d="M6 3v6M4.5 4.5h3M4.5 7.5h3"/></svg>',
  'simplicity': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M3 4h6M3 6h6M3 8h4"/></svg>',
  'read_perf': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><circle cx="6" cy="5" r="3"/><path d="M1 5c2-3 8-3 10 0M1 5c2 3 8 3 10 0"/></svg>',
  'write_perf': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M2 10l7-7 1 1-7 7z"/><path d="M8 3l1-1 2 2-1 1"/></svg>',
  'scalability': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M2 10V6l4-4 4 4v4"/></svg>',
  'consistency': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M2 6h8M4 3h4M4 9h4"/></svg>',
  'ordering': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M3 3h6M3 6h4M3 9h2"/></svg>',
  'code': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M4 3L1 6l3 3"/><path d="M8 3l3 3-3 3"/><line x1="7" y1="2" x2="5" y2="10"/></svg>',
  // Connection property icons
  'protocol': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M2 6h8"/><circle cx="2" cy="6" r="1.5"/><circle cx="10" cy="6" r="1.5"/></svg>',
  'pattern': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M2 6h2l1-3 2 6 1-3h2"/></svg>',
  'speed': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><circle cx="6" cy="7" r="4"/><path d="M6 7l2-3"/><path d="M3 7h1M8 7h1"/></svg>',
  'coloc': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><rect x="1" y="3" width="10" height="6" rx="1"/><line x1="6" y1="3" x2="6" y2="9"/></svg>',
  'conn': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M1 6h3M8 6h3"/><rect x="4" y="3" width="4" height="6" rx="1"/></svg>',
  'arrow_right': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M2 6h8M7 3l3 3-3 3"/></svg>',
  'arrow_bidir': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M2 6h8M4 3L1 6l3 3M8 3l3 3-3 3"/></svg>',
  'info': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><circle cx="6" cy="6" r="5"/><path d="M6 5.5v3"/><circle cx="6" cy="3.5" r="0.5" fill="currentColor" stroke="none"/></svg>',
  'close': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M3 3l6 6M9 3l-6 6"/></svg>',
  'chevron': '<svg viewBox="0 0 10 10" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M3 2l4 3-4 3"/></svg>',
  // New metric icons
  'reliability': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M6 1L1.5 4v3.5c0 2.5 1.8 4 4.5 4.5 2.7-.5 4.5-2 4.5-4.5V4L6 1z"/></svg>',
  'portability': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M6 1v10M1 6h10"/><circle cx="6" cy="6" r="4.5"/><path d="M2.5 4h7M2.5 8h7"/></svg>',
  'learning': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M1 4.5l5-2.5 5 2.5-5 2.5z"/><path d="M2.5 5.5v3c0 1 1.5 1.5 3.5 1.5s3.5-.5 3.5-1.5v-3"/></svg>',
  'filter': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M1.5 2h9L7.5 6v3.5L4.5 11V6z"/></svg>'
};

// Map metric names to icon keys
const METRIC_ICON_MAP = {
  'Latency': 'latency', 'Throughput': 'throughput', 'Cost Efficiency': 'cost_eff',
  'Op. Simplicity': 'simplicity', 'Read Perf': 'read_perf', 'Write Perf': 'write_perf',
  'Scalability': 'scalability', 'Consistency': 'consistency', 'Ordering': 'ordering',
  'Reliability': 'reliability', 'Portability': 'portability', 'Learning Curve': 'learning'
};

// Metric explanations — why each component+variant scores the way it does
const METRIC_EXPLANATIONS = {
  'api-gateway': {
    'nginx': {
      'Latency': { reason: 'Nginx processes requests in C with minimal overhead, routing traffic to backend services with sub-millisecond proxy latency.', factors: ['Event-driven architecture, non-blocking I/O', 'Compiled C code, near-hardware speed', 'No managed-service network hop'] },
      'Throughput': { reason: 'Handles tens of thousands of concurrent connections with minimal memory per connection.', factors: ['Worker process model scales to CPU cores', 'Efficient connection handling (~2.5KB per conn)', 'No per-request billing or throttle limits'] },
      'Cost Efficiency': { reason: 'Open-source and self-hosted. Runs on commodity hardware with low resource usage.', factors: ['No license or per-request cost', 'Low CPU/memory footprint', 'Slight ops cost for self-management'] },
      'Op. Simplicity': { reason: 'Config-file driven with no GUI. Changes require reload and manual validation.', factors: ['Config syntax has a learning curve', 'No built-in dashboard or metrics UI', 'Manual cert management (unless using certbot)'] },
      'Reliability': { reason: 'Self-managed means you own failover, health checks, and restarts. No built-in HA without extra setup.', factors: ['No automatic failover — requires keepalived or similar', 'Worker process crash recovery is fast but manual to configure', 'No built-in health monitoring dashboard'] },
      'Portability': { reason: 'Fully open-source, runs on any Linux server. Config files are portable across environments.', factors: ['Open-source (BSD license), no vendor dependency', 'Runs on bare metal, VMs, containers, any cloud', 'Config syntax is Nginx-specific but well-documented'] },
      'Learning Curve': { reason: 'Config file syntax is unique and can be tricky. No GUI — all changes via text config and CLI.', factors: ['Nginx config syntax has its own conventions', 'Debugging config errors requires reading logs', 'Advanced features (Lua, stream) require deeper expertise'] }
    },
    'kong': {
      'Latency': { reason: 'Built on Nginx core but adds Lua plugin processing per request, introducing slight overhead.', factors: ['Nginx core provides fast baseline', 'Each plugin adds Lua execution time', 'Plugin chain depth affects total latency'] },
      'Throughput': { reason: 'Inherits Nginx performance but plugin overhead reduces peak throughput vs. raw Nginx.', factors: ['Nginx event loop handles connections efficiently', 'Plugin execution reduces per-request throughput', 'DB-backed mode adds admin API lookups'] },
      'Cost Efficiency': { reason: 'Open-source core is free, but enterprise features (RBAC, dev portal) require paid license.', factors: ['Open-source core is free to self-host', 'Enterprise license for advanced features', 'Operational cost for managing Kong + its database'] },
      'Op. Simplicity': { reason: 'Powerful but complex: requires its own database, admin API, and plugin configuration knowledge.', factors: ['Requires PostgreSQL or Cassandra for config', 'Plugin ecosystem has a learning curve', 'DB-less mode simplifies but limits dynamic routing'] },
      'Reliability': { reason: 'Built on Nginx core with HA clustering available, but requires manual configuration.', factors: ['Nginx core provides stable request handling', 'HA clustering requires enterprise or manual setup', 'Health checks available via plugin'] },
      'Portability': { reason: 'Open-source core is fully portable. Enterprise features create soft lock-in.', factors: ['Open-source core (Apache 2.0 license)', 'Enterprise features (RBAC, dev portal) are proprietary', 'Plugin configs are Kong-specific but open format'] },
      'Learning Curve': { reason: 'Plugin architecture and admin API require dedicated learning. DB setup adds initial complexity.', factors: ['Plugin system has its own configuration model', 'Admin API requires understanding Kong concepts', 'DB-backed mode requires PostgreSQL/Cassandra knowledge'] }
    },
    'aws-apigw': {
      'Latency': { reason: 'Managed service adds network overhead: request goes through AWS edge, auth, and transformation layers.', factors: ['Cold-start latency on Lambda integrations', 'Multi-hop: edge → regional → backend', 'Payload transformation adds processing time'] },
      'Throughput': { reason: 'Default throttle limits (10K req/s) and payload caps restrict raw throughput.', factors: ['Default 10,000 requests/sec soft limit', '10MB payload maximum', 'Scales automatically but within AWS limits'] },
      'Cost Efficiency': { reason: 'Pay-per-request pricing becomes expensive at scale ($3.50/million requests + data transfer).', factors: ['$1.00–$3.50 per million requests', 'Data transfer charges add up', 'Free tier covers only first 12 months'] },
      'Op. Simplicity': { reason: 'Fully managed: no servers, auto-scaling, built-in monitoring. Zero infrastructure ops.', factors: ['Zero server management', 'Built-in CloudWatch metrics & logging', 'Native auth via Cognito/IAM/Lambda authorizers'] },
      'Reliability': { reason: 'AWS-managed with 99.95% SLA, multi-AZ deployment, and automatic failover.', factors: ['99.95% uptime SLA backed by AWS', 'Multi-AZ deployment by default', 'Automatic scaling handles traffic spikes'] },
      'Portability': { reason: 'Deep AWS integration: IAM auth, Lambda triggers, CloudWatch. Migration requires rewriting integrations.', factors: ['Proprietary API config format (not portable)', 'Lambda authorizers tie auth to AWS', 'CloudWatch/X-Ray monitoring only works in AWS'] },
      'Learning Curve': { reason: 'Console-driven setup with good documentation. Concepts map to standard API gateway patterns.', factors: ['AWS Console provides guided setup', 'Well-documented with tutorials and examples', 'IAM permissions model has its own learning curve'] }
    }
  },
  'ticket-service': {
    'monolith-module': {
      'Latency': { reason: 'In-process calls are extremely fast — no network hops, direct function calls between modules.', factors: ['No HTTP serialization overhead', 'Shared memory space', 'Direct method calls (~nanoseconds)'] },
      'Throughput': { reason: 'Single process handles all requests. No inter-service coordination overhead.', factors: ['No network I/O between business logic modules', 'Shared connection pools to database', 'Simple request handling'] },
      'Cost Efficiency': { reason: 'One deployment, one server, one database connection pool. Minimal infrastructure cost.', factors: ['Single instance to run and monitor', 'No inter-service network traffic cost', 'Shared resources (DB pool, cache connections)'] },
      'Op. Simplicity': { reason: 'Deploy once, monitor one process. Logs in one place. Simple mental model.', factors: ['One deployment pipeline', 'Single log stream to monitor', 'No distributed tracing needed'] },
      'Reliability': { reason: 'One process failure brings down all ticket functionality. No isolation.', factors: ['Shared failure domain', 'Memory leak affects entire application', 'No independent restart of submodules'] },
      'Portability': { reason: 'Standard application code. Easy to move between environments.', factors: ['No service mesh or orchestration dependencies', 'Standard runtime (JVM, Node, etc.)', 'Config-driven deployment'] },
      'Learning Curve': { reason: 'Simplest mental model: just modules in one codebase.', factors: ['No distributed systems concepts needed', 'Standard programming patterns', 'Familiar to most developers'] }
    },
    'microservice': {
      'Latency': { reason: 'HTTP calls to assignment engine, customer service add 5-20ms per hop.', factors: ['Network serialization/deserialization', 'Multiple HTTP round-trips', 'Service discovery lookup time'] },
      'Throughput': { reason: 'Network I/O becomes bottleneck. Each inter-service call uses connection pool slots.', factors: ['HTTP connection overhead', 'Service-to-service network bandwidth limits', 'Connection pool exhaustion risk'] },
      'Cost Efficiency': { reason: 'Each service needs its own deployment, monitoring, and potentially separate instances.', factors: ['Multiple containers/VMs to run and orchestrate', 'Inter-service network traffic cost', 'Duplicate infrastructure (load balancers, sidecars)'] },
      'Op. Simplicity': { reason: 'Distributed debugging, logs scattered across services, network failures to handle.', factors: ['Distributed tracing required (Jaeger, Zipkin)', 'Log aggregation needed', 'Circuit breakers, retries, timeouts to configure'] },
      'Reliability': { reason: 'Isolated failures: assignment engine crash does not take down ticket creation.', factors: ['Independent deployment and restart', 'Bulkheads prevent cascading failures', 'Can degrade gracefully (skip assignment if service down)'] },
      'Portability': { reason: 'Standard HTTP APIs. Can run services on different clouds or on-prem.', factors: ['Language-agnostic HTTP contracts', 'No vendor lock-in on service level', 'Service mesh abstracts infrastructure'] },
      'Learning Curve': { reason: 'Requires understanding distributed systems: retries, circuit breakers, eventual consistency.', factors: ['Network failure modes', 'Distributed tracing and logging', 'Service versioning and compatibility'] }
    },
    'serverless': {
      'Latency': { reason: 'Cold starts add 100-500ms on first invocation. Warm invocations are fast.', factors: ['Cold start: container initialization + code load', 'Warm starts: sub-10ms overhead', 'API Gateway adds 5-10ms'] },
      'Throughput': { reason: 'Auto-scales to traffic but concurrent execution limits can throttle.', factors: ['AWS Lambda concurrency limits (default 1000)', 'Scales instantly within limits', 'Reserved concurrency prevents noisy neighbor'] },
      'Cost Efficiency': { reason: 'Pay only for execution time. Zero cost when idle. Extremely cost-effective at low-medium scale.', factors: ['No idle server cost', '$0.20 per 1M requests + compute time', 'Becomes expensive at very high sustained load'] },
      'Op. Simplicity': { reason: 'No servers to manage. Auto-scaling built-in. Monitoring via CloudWatch.', factors: ['Zero server management', 'Auto-scaling without configuration', 'Built-in logging and metrics'] },
      'Reliability': { reason: 'AWS manages infrastructure HA. Function failures isolated. Retry logic built-in.', factors: ['Multi-AZ execution by default', 'Automatic retries on failure', 'Dead-letter queue for poison messages'] },
      'Portability': { reason: 'Deep AWS integration. Code is portable but infrastructure (Lambda, API Gateway, IAM) is not.', factors: ['Proprietary Lambda runtime', 'Vendor-specific triggers and integrations', 'Migration requires rewriting infrastructure'] },
      'Learning Curve': { reason: 'Requires learning serverless patterns: stateless design, cold starts, event-driven.', factors: ['Stateless execution model', 'Cold start mitigation strategies', 'IAM permissions for every resource'] }
    }
  },
  'assignment-engine': {
    'rule-based': {
      'Latency': { reason: 'Simple conditional logic executes in microseconds. No external model loading.', factors: ['In-memory rule evaluation', 'No I/O required', 'Deterministic execution time'] },
      'Throughput': { reason: 'CPU-bound only. Can process thousands of assignments per second.', factors: ['No blocking I/O', 'Lightweight logic', 'Stateless, parallelizable'] },
      'Cost Efficiency': { reason: 'Minimal compute required. Runs in same process as ticket service.', factors: ['No GPU or model serving infrastructure', 'No ML training pipeline cost', 'Simple code, easy to maintain'] },
      'Op. Simplicity': { reason: 'Code-based rules are easy to understand, test, and debug.', factors: ['No model versioning or retraining', 'Standard if/else logic', 'Easy to unit test'] },
      'Reliability': { reason: 'Deterministic behavior. No external dependencies (model servers, APIs).', factors: ['Predictable output', 'No model drift or degradation', 'Failures are code bugs, not data issues'] },
      'Portability': { reason: 'Plain code. Runs anywhere.', factors: ['No ML framework dependencies', 'Language-agnostic logic', 'Config-driven rule changes'] },
      'Learning Curve': { reason: 'Standard programming. No ML expertise required.', factors: ['Familiar control flow', 'Easy for junior developers', 'Well-understood patterns'] }
    },
    'ml-based': {
      'Latency': { reason: 'Model inference adds 10-50ms depending on model complexity and serving infrastructure.', factors: ['Model load time on first call', 'Inference latency (GPU vs CPU)', 'Feature extraction overhead'] },
      'Throughput': { reason: 'Bottlenecked by model server capacity. GPU batching helps but adds complexity.', factors: ['Model server concurrency limits', 'GPU memory constraints', 'Batch processing trade-offs'] },
      'Cost Efficiency': { reason: 'Requires training pipeline, model storage, and serving infrastructure (GPU for low latency).', factors: ['Training data collection and labeling', 'Model training compute (GPU hours)', 'Inference serving (SageMaker, TensorFlow Serving)'] },
      'Op. Simplicity': { reason: 'Complex pipeline: data labeling, training, versioning, deployment, monitoring drift.', factors: ['Model versioning and rollback', 'Monitoring model performance drift', 'Retraining pipeline'] },
      'Reliability': { reason: 'Model drift over time. Predictions can degrade if data distribution changes.', factors: ['Model accuracy degrades without retraining', 'Feature engineering bugs are subtle', 'Unexpected input can cause bad predictions'] },
      'Portability': { reason: 'ML frameworks (TensorFlow, PyTorch) are portable but serving infrastructure varies.', factors: ['Framework-specific model formats', 'Serving infrastructure (SageMaker, Vertex AI)', 'Feature store integration'] },
      'Learning Curve': { reason: 'Requires ML expertise: feature engineering, training, hyperparameter tuning, monitoring.', factors: ['ML algorithm selection', 'Feature engineering is hard', 'Model debugging requires domain + ML knowledge'] }
    },
    'round-robin': {
      'Latency': { reason: 'Simple counter increment. Nanosecond-level overhead.', factors: ['In-memory counter', 'No decision logic', 'Lock-free in single-threaded context'] },
      'Throughput': { reason: 'Zero logic overhead. As fast as the underlying expert lookup.', factors: ['No conditional branching', 'Minimal CPU cycles', 'Stateless (counter can be distributed)'] },
      'Cost Efficiency': { reason: 'Trivial compute cost. No infrastructure required.', factors: ['No external dependencies', 'Runs in-process', 'Zero operational overhead'] },
      'Op. Simplicity': { reason: 'Simplest possible logic. No configuration needed.', factors: ['No rules to maintain', 'No training data', 'Trivial to understand'] },
      'Reliability': { reason: 'Deterministic distribution. No failure modes except expert availability.', factors: ['Predictable load balancing', 'No logic bugs', 'Failure is obvious (counter overflow is rare)'] },
      'Portability': { reason: 'Universal algorithm. Runs anywhere.', factors: ['Language-agnostic', 'No framework dependencies', 'Standard CS pattern'] },
      'Learning Curve': { reason: 'Universally understood. First algorithm taught in CS.', factors: ['Elementary logic', 'No domain knowledge needed', 'Trivial to implement'] }
    }
  },
  'customer-service': {
    'shared-db': {
      'Latency': { reason: 'Direct SQL query to shared database. No network hop to another service.', factors: ['In-process DB connection pool', 'No HTTP serialization', 'Single query execution'] },
      'Throughput': { reason: 'Shares connection pool with other modules. No inter-service overhead.', factors: ['Pooled connections to shared DB', 'No service-to-service network calls', 'Simple SELECT queries'] },
      'Cost Efficiency': { reason: 'No separate deployment or infrastructure. Runs as part of monolith.', factors: ['No dedicated service instance', 'Shared DB connection pool', 'Zero inter-service traffic'] },
      'Op. Simplicity': { reason: 'No separate deployment or monitoring. Just another module in the codebase.', factors: ['Single codebase, single deployment', 'No distributed tracing needed', 'Logs in one place'] },
      'Reliability': { reason: 'Tight coupling: if monolith crashes, customer data access goes down.', factors: ['Shared failure domain', 'No isolation from other modules', 'DB schema changes affect all services'] },
      'Portability': { reason: 'Standard SQL. Easy to move as part of the monolith.', factors: ['No service-specific dependencies', 'Standard database access patterns', 'Config-driven connection'] },
      'Learning Curve': { reason: 'Standard database access. No distributed systems concepts.', factors: ['Familiar SQL queries', 'No API versioning', 'No service discovery'] }
    },
    'separate-service': {
      'Latency': { reason: 'HTTP call to customer service adds 5-20ms per request.', factors: ['Network round-trip', 'JSON serialization/deserialization', 'Service discovery lookup'] },
      'Throughput': { reason: 'Limited by network bandwidth and HTTP connection pool size.', factors: ['HTTP connection overhead', 'Payload size affects throughput', 'Connection pool can exhaust'] },
      'Cost Efficiency': { reason: 'Requires separate deployment, monitoring, and infrastructure.', factors: ['Dedicated container/VM', 'Own database instance (if per-service DB)', 'Load balancer or service mesh overhead'] },
      'Op. Simplicity': { reason: 'Separate deployment, logs, and monitoring. Distributed debugging required.', factors: ['Separate CI/CD pipeline', 'Distributed tracing needed', 'API versioning and compatibility'] },
      'Reliability': { reason: 'Isolated failure: customer service can crash without taking down ticket service.', factors: ['Independent restart', 'Failure isolation (circuit breakers)', 'Can degrade gracefully'] },
      'Portability': { reason: 'HTTP API contract. Can run on different stack or cloud.', factors: ['Language-agnostic REST API', 'No shared infrastructure dependencies', 'Flexible deployment targets'] },
      'Learning Curve': { reason: 'Requires understanding distributed systems: retries, circuit breakers, timeouts.', factors: ['Network failure handling', 'API versioning strategies', 'Service mesh or client-side load balancing'] }
    },
    'event-sourced': {
      'Latency': { reason: 'Event replay for state reconstruction can be slow for long event histories.', factors: ['Must replay all events for entity', 'Snapshotting reduces replay cost', 'Event store read latency'] },
      'Throughput': { reason: 'Append-only event writes are fast, but reads require event aggregation.', factors: ['Event append is sequential write (fast)', 'State reconstruction is compute-intensive', 'Snapshots improve read throughput'] },
      'Cost Efficiency': { reason: 'Event store grows indefinitely. Requires snapshot management and archival strategy.', factors: ['Unbounded event log growth', 'Snapshot storage cost', 'Event replay compute cost'] },
      'Op. Simplicity': { reason: 'Complex pattern: event versioning, snapshots, projections, eventual consistency.', factors: ['Event schema evolution is hard', 'Snapshot management needed', 'Projection rebuilds on schema change'] },
      'Reliability': { reason: 'Full audit trail. Can replay to any point in time. But eventual consistency complicates queries.', factors: ['Complete event history for debugging', 'Time-travel queries possible', 'Eventual consistency requires careful handling'] },
      'Portability': { reason: 'Event store is custom. Migration requires replaying events into new system.', factors: ['Event schema is application-specific', 'Event store varies (EventStoreDB, Kafka, custom)', 'Projection logic is tightly coupled'] },
      'Learning Curve': { reason: 'Advanced pattern. Requires understanding CQRS, event sourcing, eventual consistency.', factors: ['Event modeling is different from CRUD', 'Projection design is non-trivial', 'Debugging via event replay'] }
    }
  },
  'expert-service': {
    'shared-db': {
      'Latency': { reason: 'Direct SQL query to shared database. No network hop to another service.', factors: ['In-process DB connection pool', 'No HTTP serialization', 'Single query execution'] },
      'Throughput': { reason: 'Shares connection pool with other modules. No inter-service overhead.', factors: ['Pooled connections to shared DB', 'No service-to-service network calls', 'Simple SELECT queries'] },
      'Cost Efficiency': { reason: 'No separate deployment or infrastructure. Runs as part of monolith.', factors: ['No dedicated service instance', 'Shared DB connection pool', 'Zero inter-service traffic'] },
      'Op. Simplicity': { reason: 'No separate deployment or monitoring. Just another module in the codebase.', factors: ['Single codebase, single deployment', 'No distributed tracing needed', 'Logs in one place'] },
      'Reliability': { reason: 'Tight coupling: if monolith crashes, expert data access goes down.', factors: ['Shared failure domain', 'No isolation from other modules', 'DB schema changes affect all services'] },
      'Portability': { reason: 'Standard SQL. Easy to move as part of the monolith.', factors: ['No service-specific dependencies', 'Standard database access patterns', 'Config-driven connection'] },
      'Learning Curve': { reason: 'Standard database access. No distributed systems concepts.', factors: ['Familiar SQL queries', 'No API versioning', 'No service discovery'] }
    },
    'separate-service': {
      'Latency': { reason: 'HTTP call to expert service adds 5-20ms per request.', factors: ['Network round-trip', 'JSON serialization/deserialization', 'Service discovery lookup'] },
      'Throughput': { reason: 'Limited by network bandwidth and HTTP connection pool size.', factors: ['HTTP connection overhead', 'Payload size affects throughput', 'Connection pool can exhaust'] },
      'Cost Efficiency': { reason: 'Requires separate deployment, monitoring, and infrastructure.', factors: ['Dedicated container/VM', 'Own database instance (if per-service DB)', 'Load balancer or service mesh overhead'] },
      'Op. Simplicity': { reason: 'Separate deployment, logs, and monitoring. Distributed debugging required.', factors: ['Separate CI/CD pipeline', 'Distributed tracing needed', 'API versioning and compatibility'] },
      'Reliability': { reason: 'Isolated failure: expert service can crash without taking down assignment engine.', factors: ['Independent restart', 'Failure isolation (circuit breakers)', 'Can degrade gracefully'] },
      'Portability': { reason: 'HTTP API contract. Can run on different stack or cloud.', factors: ['Language-agnostic REST API', 'No shared infrastructure dependencies', 'Flexible deployment targets'] },
      'Learning Curve': { reason: 'Requires understanding distributed systems: retries, circuit breakers, timeouts.', factors: ['Network failure handling', 'API versioning strategies', 'Service mesh or client-side load balancing'] }
    }
  },
  'notification-service': {
    'sync-http': {
      'Latency': { reason: 'Synchronous HTTP call blocks until notification sent. Email/SMS latency adds to request time.', factors: ['HTTP round-trip time', 'Email/SMS provider latency (50-500ms)', 'Blocks caller until complete'] },
      'Throughput': { reason: 'Limited by external notification provider rate limits and latency.', factors: ['Provider API rate limits', 'Each notification blocks a thread/connection', 'No batching'] },
      'Cost Efficiency': { reason: 'Simple to implement. No queue infrastructure. But tight coupling increases failure cost.', factors: ['No message queue infrastructure', 'Provider API costs (per-message)', 'Retries on failure can be expensive'] },
      'Op. Simplicity': { reason: 'Simple HTTP client. No queue management. But failure handling is harder.', factors: ['No queue to monitor', 'Inline error handling', 'Retry logic must be custom-built'] },
      'Reliability': { reason: 'Notification failure fails the caller. No retry queue or dead-letter handling.', factors: ['Tight coupling to provider uptime', 'Caller fails if notification fails', 'No automatic retry'] },
      'Portability': { reason: 'Standard HTTP. Can swap providers easily (SendGrid, Twilio, etc.).', factors: ['Provider-agnostic HTTP API', 'No infrastructure dependencies', 'Simple client library integration'] },
      'Learning Curve': { reason: 'Simplest pattern: make HTTP call, handle response.', factors: ['Standard HTTP client', 'Familiar request/response model', 'No async patterns needed'] }
    },
    'async-queue': {
      'Latency': { reason: 'Caller publishes to queue and returns immediately. Notification sent asynchronously.', factors: ['Queue publish is fast (~1-5ms)', 'Notification latency decoupled from caller', 'Background worker processes queue'] },
      'Throughput': { reason: 'Queue buffers bursts. Workers can process in parallel or batches.', factors: ['Queue absorbs traffic spikes', 'Workers scale independently', 'Batching improves provider throughput'] },
      'Cost Efficiency': { reason: 'Queue infrastructure cost (SQS, RabbitMQ). But decoupling reduces failure cost.', factors: ['Queue hosting/management cost', 'Worker instance cost', 'Retry and DLQ reduce wasted provider calls'] },
      'Op. Simplicity': { reason: 'Queue adds infrastructure. Workers need deployment and monitoring.', factors: ['Queue service to manage (SQS, RabbitMQ)', 'Worker process lifecycle', 'Dead-letter queue monitoring'] },
      'Reliability': { reason: 'Queue provides durability. Retries and DLQ handle transient failures.', factors: ['Messages persist until processed', 'Automatic retry on worker failure', 'Dead-letter queue for poison messages'] },
      'Portability': { reason: 'Queue abstraction varies (SQS, RabbitMQ, Azure Service Bus). Migration requires adapter.', factors: ['Queue API differs by provider', 'Message format is custom', 'Workers are portable but queue config is not'] },
      'Learning Curve': { reason: 'Requires understanding async messaging: queues, workers, DLQ, idempotency.', factors: ['Queue semantics (at-least-once, FIFO)', 'Worker scaling and failure handling', 'Idempotent message processing'] }
    },
    'event-driven': {
      'Latency': { reason: 'Event published to Kafka. Consumer processes asynchronously. Full decoupling.', factors: ['Kafka publish is fast (~5-20ms)', 'Consumer lag depends on throughput', 'No blocking on caller'] },
      'Throughput': { reason: 'Kafka handles massive throughput. Partitioning enables parallel processing.', factors: ['Kafka throughput: millions of events/sec', 'Consumer groups scale horizontally', 'Batching maximizes efficiency'] },
      'Cost Efficiency': { reason: 'Kafka cluster infrastructure cost. But reusable for other events.', factors: ['Kafka cluster hosting (managed or self-hosted)', 'Consumer instance cost', 'Event retention storage cost'] },
      'Op. Simplicity': { reason: 'Kafka adds operational complexity: topics, partitions, consumer groups, offset management.', factors: ['Topic and partition configuration', 'Consumer group rebalancing', 'Offset commit strategies'] },
      'Reliability': { reason: 'Kafka provides durability, replication, and replay. Consumer failures are isolated.', factors: ['Event log is durable and replicated', 'Consumer failure does not lose events', 'Can replay events for recovery'] },
      'Portability': { reason: 'Kafka-specific. Migration to other event buses (Pulsar, RabbitMQ) requires rewriting consumers.', factors: ['Kafka protocol and client libraries', 'Topic/partition model is Kafka-specific', 'Consumer group semantics vary by platform'] },
      'Learning Curve': { reason: 'Requires understanding Kafka: topics, partitions, consumer groups, offset management.', factors: ['Kafka concepts are complex', 'Consumer group rebalancing behavior', 'Exactly-once vs at-least-once semantics'] }
    }
  },
  'database': {
    'shared-postgresql': {
      'Read Perf': { reason: 'JOINs across tickets, customers, experts add query planning overhead. Simple queries fast.', factors: ['Multi-table JOINs for ticket views', 'Index lookups across relations', 'Query planner evaluates join strategies'] },
      'Write Perf': { reason: 'Single source of truth — each fact stored once. Writes are simple and consistent.', factors: ['No data duplication to maintain', 'Foreign key checks are fast with indexes', 'Single UPDATE per entity change'] },
      'Scalability': { reason: 'JOINs become expensive at scale. Vertical scaling hits limits. Shared schema prevents partitioning.', factors: ['Cross-table JOINs don\'t parallelize well', 'All services compete for same DB connection pool', 'Schema changes affect all services simultaneously'] },
      'Consistency': { reason: 'Perfect consistency. ACID transactions across all tables. Foreign keys enforce referential integrity.', factors: ['ACID transactions guarantee consistency', 'Foreign key constraints prevent orphan records', 'Single database = no distributed transaction coordination'] },
      'Op. Simplicity': { reason: 'One database to manage, backup, and monitor. But schema changes require coordination across services.', factors: ['Single DB instance to manage', 'One backup/restore strategy', 'Schema migrations affect all services (coordination needed)'] },
      'Reliability': { reason: 'Single point of failure. DB crash takes down entire system. Replication provides HA but adds complexity.', factors: ['Single DB failure = full system outage', 'Streaming replication provides failover', 'WAL ensures crash recovery'] },
      'Learning Curve': { reason: 'Standard SQL and relational modeling. Well-understood patterns.', factors: ['SQL is widely known', 'Relational design is taught everywhere', 'Extensive PostgreSQL documentation'] }
    },
    'per-service-dbs': {
      'Read Perf': { reason: 'No JOINs across service boundaries. Must fetch from multiple DBs and join in application code.', factors: ['Single-table queries are fast', 'Cross-service data requires multiple queries', 'Application-level joins add latency'] },
      'Write Perf': { reason: 'Each service writes to its own DB independently. No contention. But distributed transactions needed.', factors: ['Parallel writes across DBs', 'No shared connection pool contention', 'Saga pattern for cross-service transactions'] },
      'Scalability': { reason: 'Each DB scales independently. Can right-size per service. Excellent horizontal scaling.', factors: ['Independent read replicas per service', 'Service-specific partitioning strategies', 'No shared bottleneck'] },
      'Consistency': { reason: 'Eventual consistency across services. Distributed transactions or sagas required for atomicity.', factors: ['No ACID across service boundaries', 'Saga pattern handles cross-service transactions', 'Data inconsistencies possible on failure'] },
      'Op. Simplicity': { reason: 'Multiple databases to manage, backup, monitor. Schema changes are independent but coordination is complex.', factors: ['N databases to manage (one per service)', 'Distributed tracing needed for queries', 'Saga failure handling is non-trivial'] },
      'Reliability': { reason: 'Isolated failures. One DB crash does not take down all services. But partial failures harder to debug.', factors: ['Failure isolation improves availability', 'Service can degrade gracefully if dependency DB is down', 'Distributed transactions can leave inconsistent state'] },
      'Learning Curve': { reason: 'Requires understanding distributed data: sagas, eventual consistency, compensating transactions.', factors: ['Saga pattern is complex', 'Eventual consistency reasoning is hard', 'Cross-service data access requires careful design'] }
    },
    'cqrs': {
      'Read Perf': { reason: 'Read model is denormalized and optimized for queries. Extremely fast reads.', factors: ['Pre-joined read views', 'Separate read-optimized schema', 'Can use different storage (e.g., Elasticsearch for search)'] },
      'Write Perf': { reason: 'Write model is normalized. Writes update both command and read models (async projection).', factors: ['Normalized write model for consistency', 'Async projection to read model', 'Event publishing adds overhead'] },
      'Scalability': { reason: 'Read and write models scale independently. Can optimize each for its workload.', factors: ['Read replicas for read model only', 'Write model can be smaller, focused on commands', 'Event log drives async projections'] },
      'Consistency': { reason: 'Eventual consistency between write and read models. Projection lag creates staleness window.', factors: ['Write model is immediately consistent', 'Read model updated asynchronously', 'Projection lag can be seconds to minutes'] },
      'Op. Simplicity': { reason: 'Complex architecture: separate write/read models, event bus, projection workers.', factors: ['Two schemas to maintain (write + read)', 'Event-driven projection pipeline', 'Projection failure recovery is complex'] },
      'Reliability': { reason: 'Write model durability via events. Read model can be rebuilt. But projection failures cause stale reads.', factors: ['Event log is source of truth', 'Read model can be reconstructed from events', 'Projection lag or failure causes stale data'] },
      'Learning Curve': { reason: 'Advanced pattern. Requires understanding CQRS, event sourcing, eventual consistency, projections.', factors: ['CQRS mental model is non-intuitive', 'Event-driven projections are complex', 'Debugging requires tracing through events'] }
    }
  },
  'event-bus': {
    'kafka': {
      'Throughput': { reason: 'Designed for high throughput. Millions of events per second with partitioning.', factors: ['Append-only log is sequential write (fast)', 'Partitioning enables parallel writes', 'Zero-copy transfer from disk to network'] },
      'Ordering': { reason: 'Per-partition ordering guaranteed. Cross-partition ordering requires application logic.', factors: ['Single partition = total order', 'Multiple partitions = per-partition order only', 'Partition key determines placement'] },
      'Scalability': { reason: 'Horizontal scaling via partitions. Add brokers and consumers to scale.', factors: ['Partition count determines parallelism', 'Consumer groups auto-balance partitions', 'Brokers distribute partitions across cluster'] },
      'Op. Simplicity': { reason: 'Complex: topics, partitions, consumer groups, offset management, rebalancing.', factors: ['Topic/partition configuration', 'Consumer group rebalancing', 'Offset commit strategies'] },
      'Reliability': { reason: 'Replication across brokers. Leader failover automatic. Durable event log.', factors: ['Replication factor ensures durability', 'Automatic leader election on failure', 'Event log is durable (configurable retention)'] },
      'Portability': { reason: 'Open-source but Kafka-specific. Migration to other platforms (Pulsar, RabbitMQ) is non-trivial.', factors: ['Kafka protocol and clients', 'Partition model is Kafka-specific', 'Managed services (Confluent, MSK) add proprietary features'] },
      'Learning Curve': { reason: 'Steep learning curve: topics, partitions, consumer groups, offset management, exactly-once semantics.', factors: ['Kafka concepts are complex', 'Consumer group behavior is nuanced', 'Offset management and idempotency are advanced'] }
    },
    'rabbitmq': {
      'Throughput': { reason: 'Lower throughput than Kafka. Designed for reliability over raw speed.', factors: ['Acknowledgment-based delivery adds overhead', 'Not optimized for sequential writes', 'Max ~50K messages/sec per queue'] },
      'Ordering': { reason: 'FIFO ordering per queue. Multiple consumers can break order unless using single consumer.', factors: ['Single queue = FIFO order', 'Multiple consumers can process out-of-order', 'Priority queues break FIFO'] },
      'Scalability': { reason: 'Vertical scaling primarily. Clustering adds complexity. Sharding requires manual partitioning.', factors: ['Queue sharding is manual', 'Clustering requires careful configuration', 'Not designed for massive horizontal scale'] },
      'Op. Simplicity': { reason: 'Simpler than Kafka for basic use cases. Web UI for monitoring. But clustering is complex.', factors: ['Built-in management UI', 'Well-documented routing patterns', 'Clustering (for HA) requires careful setup'] },
      'Reliability': { reason: 'Message acknowledgments ensure delivery. Mirrored queues for HA. Durable queues survive restarts.', factors: ['Acknowledgment-based delivery guarantees', 'Mirrored queues replicate messages', 'Durable queues persist to disk'] },
      'Portability': { reason: 'AMQP standard protocol. Can migrate to other AMQP brokers (Azure Service Bus, AWS MQ).', factors: ['AMQP protocol is standard', 'Queue semantics are portable', 'Routing patterns are RabbitMQ-specific'] },
      'Learning Curve': { reason: 'Moderate. Exchange/queue/binding model requires understanding, but simpler than Kafka.', factors: ['Exchange types (direct, topic, fanout)', 'Queue bindings and routing keys', 'Acknowledgment modes'] }
    },
    'redis-pubsub': {
      'Throughput': { reason: 'Extremely fast for fire-and-forget pub/sub. No persistence overhead.', factors: ['In-memory pub/sub (no disk I/O)', 'No message acknowledgment', 'Minimal protocol overhead'] },
      'Ordering': { reason: 'Messages delivered in publish order to each subscriber. But no replay or catchup.', factors: ['FIFO delivery per channel', 'Subscribers receive in order', 'Offline subscribers miss messages'] },
      'Scalability': { reason: 'Scales with Redis capacity. No partitioning. All subscribers receive all messages.', factors: ['Single Redis instance handles pub/sub', 'No message partitioning', 'Broadcast model (all subscribers get all messages)'] },
      'Op. Simplicity': { reason: 'Simplest event bus. No topics, partitions, or consumer groups. Just publish and subscribe.', factors: ['No configuration needed (just channel names)', 'No offset management', 'Trivial to set up'] },
      'Reliability': { reason: 'Fire-and-forget. No persistence or delivery guarantees. Offline subscribers miss messages.', factors: ['No message durability (in-memory only)', 'Subscribers must be connected to receive', 'No replay or catchup mechanism'] },
      'Portability': { reason: 'Redis PUBLISH/SUBSCRIBE commands. Portable across Redis providers (ElastiCache, Upstash).', factors: ['Standard Redis protocol', 'No proprietary extensions', 'Widely supported'] },
      'Learning Curve': { reason: 'Trivial. PUBLISH and SUBSCRIBE commands. No complex concepts.', factors: ['Two commands: PUBLISH, SUBSCRIBE', 'No consumer groups or offsets', 'Immediate to understand'] }
    }
  }
};

// Component catalog — full list of available components grouped by category
const COMPONENT_CATALOG = {
  'Delivery/Network': [
    { name: 'Nginx', sub: 'Reverse proxy', connectsFrom: ['Clients', 'CDN'], connectsTo: ['Compute'] },
    { name: 'AWS API Gateway', sub: 'Managed gateway', connectsFrom: ['Clients'], connectsTo: ['Compute', 'Auth/Security'] },
    { name: 'Kong', sub: 'Plugin ecosystem', connectsFrom: ['Clients'], connectsTo: ['Compute', 'Auth/Security'] },
    { name: 'Traefik', sub: 'Cloud-native', connectsFrom: ['Clients', 'DevOps'], connectsTo: ['Compute'] },
    { name: 'HAProxy', sub: 'TCP/HTTP LB', connectsFrom: ['Clients'], connectsTo: ['Compute'] },
    { name: 'Envoy', sub: 'Service mesh', connectsFrom: ['Compute'], connectsTo: ['Compute'] },
    { name: 'CloudFront', sub: 'CDN + edge', connectsFrom: ['Clients'], connectsTo: ['Delivery/Network', 'Compute'] }
  ],
  'Compute': [
    { name: 'Node.js', sub: 'Event-driven I/O', connectsFrom: ['Delivery/Network'], connectsTo: ['Data Storage', 'Caching', 'Messaging', 'Search'] },
    { name: 'Go', sub: 'Concurrency', connectsFrom: ['Delivery/Network'], connectsTo: ['Data Storage', 'Caching', 'Messaging'] },
    { name: 'Python FastAPI', sub: 'ML-friendly', connectsFrom: ['Delivery/Network'], connectsTo: ['Data Storage', 'Caching', 'Messaging'] },
    { name: 'Rust Actix', sub: 'Max performance', connectsFrom: ['Delivery/Network'], connectsTo: ['Data Storage', 'Caching', 'Messaging'] },
    { name: 'Java Spring', sub: 'Enterprise', connectsFrom: ['Delivery/Network'], connectsTo: ['Data Storage', 'Caching', 'Messaging'] },
    { name: '.NET / C#', sub: 'Microsoft stack', connectsFrom: ['Delivery/Network'], connectsTo: ['Data Storage', 'Caching', 'Messaging'] }
  ],
  'Data Storage': [
    { name: 'PostgreSQL', sub: 'Relational ACID', connectsFrom: ['Compute'], connectsTo: ['Search', 'Monitoring'] },
    { name: 'MongoDB', sub: 'Document DB', connectsFrom: ['Compute'], connectsTo: ['Search'] },
    { name: 'MySQL', sub: 'Web standard', connectsFrom: ['Compute'], connectsTo: ['Search'] },
    { name: 'CockroachDB', sub: 'Distributed SQL', connectsFrom: ['Compute'], connectsTo: [] },
    { name: 'DynamoDB', sub: 'Serverless NoSQL', connectsFrom: ['Compute'], connectsTo: [] },
    { name: 'Cassandra', sub: 'Wide-column', connectsFrom: ['Compute'], connectsTo: [] }
  ],
  'Caching': [
    { name: 'Redis', sub: 'Data structures', connectsFrom: ['Compute'], connectsTo: ['Real-Time'] },
    { name: 'Memcached', sub: 'Simple cache', connectsFrom: ['Compute'], connectsTo: [] },
    { name: 'KeyDB', sub: 'Multi-thread Redis', connectsFrom: ['Compute'], connectsTo: [] },
    { name: 'Dragonfly', sub: 'Modern cache', connectsFrom: ['Compute'], connectsTo: [] },
    { name: 'Varnish', sub: 'HTTP cache', connectsFrom: ['Delivery/Network'], connectsTo: ['Compute'] }
  ],
  'Messaging': [
    { name: 'Kafka', sub: 'Event streaming', connectsFrom: ['Compute'], connectsTo: ['Compute', 'Data Storage', 'Real-Time'] },
    { name: 'RabbitMQ', sub: 'Classic MQ', connectsFrom: ['Compute'], connectsTo: ['Compute'] },
    { name: 'AWS SQS', sub: 'Managed queue', connectsFrom: ['Compute'], connectsTo: ['Compute'] },
    { name: 'Apache Pulsar', sub: 'Multi-tenant', connectsFrom: ['Compute'], connectsTo: ['Compute', 'Data Storage'] },
    { name: 'NATS', sub: 'Lightweight', connectsFrom: ['Compute'], connectsTo: ['Compute'] }
  ],
  'Real-Time': [
    { name: 'Socket.io', sub: 'WebSocket + fallback', connectsFrom: ['Compute', 'Caching'], connectsTo: ['Clients'] },
    { name: 'Pusher', sub: 'Managed realtime', connectsFrom: ['Compute'], connectsTo: ['Clients'] },
    { name: 'Ably', sub: 'Global pub/sub', connectsFrom: ['Compute'], connectsTo: ['Clients'] },
    { name: 'Centrifugo', sub: 'Self-hosted', connectsFrom: ['Compute', 'Messaging'], connectsTo: ['Clients'] },
    { name: 'SSE Endpoint', sub: 'Server-sent events', connectsFrom: ['Compute'], connectsTo: ['Clients'] }
  ],
  'Auth/Security': [
    { name: 'Auth0', sub: 'Managed auth', connectsFrom: ['Delivery/Network', 'Compute'], connectsTo: ['Data Storage'] },
    { name: 'Keycloak', sub: 'Self-hosted IAM', connectsFrom: ['Delivery/Network'], connectsTo: ['Data Storage'] },
    { name: 'AWS Cognito', sub: 'AWS auth', connectsFrom: ['Delivery/Network'], connectsTo: [] },
    { name: 'Custom JWT', sub: 'In-house', connectsFrom: ['Compute'], connectsTo: ['Caching', 'Data Storage'] },
    { name: 'OAuth2 Proxy', sub: 'Gateway auth', connectsFrom: ['Delivery/Network'], connectsTo: ['Compute'] }
  ],
  'Monitoring': [
    { name: 'Datadog', sub: 'Full observability', connectsFrom: ['All components'], connectsTo: ['Alerting'] },
    { name: 'Grafana + Prometheus', sub: 'OSS metrics', connectsFrom: ['Compute', 'Data Storage'], connectsTo: ['Alerting'] },
    { name: 'ELK Stack', sub: 'Log analytics', connectsFrom: ['All components'], connectsTo: [] },
    { name: 'Jaeger', sub: 'Distributed tracing', connectsFrom: ['Compute'], connectsTo: [] },
    { name: 'Sentry', sub: 'Error tracking', connectsFrom: ['Compute'], connectsTo: ['Alerting'] }
  ],
  'Search': [
    { name: 'Elasticsearch', sub: 'Full-text + analytics', connectsFrom: ['Data Storage', 'Compute'], connectsTo: ['Compute'] },
    { name: 'Algolia', sub: 'Managed search', connectsFrom: ['Compute'], connectsTo: [] },
    { name: 'Meilisearch', sub: 'Fast + simple', connectsFrom: ['Compute'], connectsTo: [] },
    { name: 'Typesense', sub: 'Typo-tolerant', connectsFrom: ['Compute'], connectsTo: [] }
  ],
  'DevOps': [
    { name: 'Docker', sub: 'Containers', connectsFrom: [], connectsTo: ['All components'] },
    { name: 'Kubernetes', sub: 'Orchestration', connectsFrom: ['DevOps'], connectsTo: ['All components'] },
    { name: 'Terraform', sub: 'IaC', connectsFrom: [], connectsTo: ['All components'] },
    { name: 'GitHub Actions', sub: 'CI/CD', connectsFrom: [], connectsTo: ['DevOps'] },
    { name: 'ArgoCD', sub: 'GitOps', connectsFrom: ['DevOps'], connectsTo: ['Compute'] }
  ]
};

// Swap icon SVG
const SWAP_ICON = '<svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M4 6l-2 2 2 2"/><path d="M2 8h10"/><path d="M12 10l2-2-2-2"/><path d="M14 8H4"/></svg>';

// Alternative components per category (for swap feature)
const ALTERNATIVES = {
  'api-gateway':  [
    { id: 'api-gateway', name: 'API Gateway', sub: 'Current' },
    { id: 'traefik', name: 'Traefik', sub: 'Cloud-native' },
    { id: 'envoy', name: 'Envoy Proxy', sub: 'Service mesh' },
    { id: 'haproxy', name: 'HAProxy', sub: 'TCP/HTTP LB' }
  ],
  'ticket-service': [
    { id: 'ticket-service', name: 'Ticket Service', sub: 'Current' },
    { id: 'go-service', name: 'Go Service', sub: 'Concurrency' },
    { id: 'java-service', name: 'Java Service', sub: 'Enterprise' },
    { id: 'python-service', name: 'Python Service', sub: 'ML-friendly' }
  ],
  'assignment-engine': [
    { id: 'assignment-engine', name: 'Assignment Engine', sub: 'Current' },
    { id: 'ml-engine', name: 'ML Engine', sub: 'AI-powered' },
    { id: 'rules-engine', name: 'Rules Engine', sub: 'Drools/DMN' },
    { id: 'lambda-engine', name: 'Lambda Engine', sub: 'Serverless' }
  ],
  'customer-service': [
    { id: 'customer-service', name: 'Customer Service', sub: 'Current' },
    { id: 'customer-microservice', name: 'Customer µService', sub: 'Independent' },
    { id: 'customer-lambda', name: 'Customer Lambda', sub: 'Serverless' },
    { id: 'customer-event', name: 'Event-Sourced', sub: 'CQRS' }
  ],
  'expert-service': [
    { id: 'expert-service', name: 'Expert Service', sub: 'Current' },
    { id: 'expert-microservice', name: 'Expert µService', sub: 'Independent' },
    { id: 'expert-lambda', name: 'Expert Lambda', sub: 'Serverless' }
  ],
  'notification-service': [
    { id: 'notification-service', name: 'Notification Service', sub: 'Current' },
    { id: 'sns-service', name: 'AWS SNS', sub: 'Managed' },
    { id: 'twilio-service', name: 'Twilio', sub: 'Multi-channel' },
    { id: 'sendgrid-service', name: 'SendGrid', sub: 'Email-focused' }
  ],
  'database': [
    { id: 'database', name: 'Database', sub: 'Current' },
    { id: 'mongodb', name: 'MongoDB', sub: 'Document DB' },
    { id: 'mysql', name: 'MySQL', sub: 'Web standard' },
    { id: 'cockroachdb', name: 'CockroachDB', sub: 'Distributed SQL' }
  ],
  'event-bus': [
    { id: 'event-bus', name: 'Event Bus', sub: 'Current' },
    { id: 'rabbitmq', name: 'RabbitMQ', sub: 'Classic MQ' },
    { id: 'aws-sqs', name: 'AWS SQS', sub: 'Managed queue' },
    { id: 'pulsar', name: 'Apache Pulsar', sub: 'Multi-tenant' }
  ]
};

// Connection type icons (SVG path data for canvas labels, viewBox 0 0 10 10)
const CONN_TYPE_DEFS = {
  http: { color: '#06b6d4', name: 'HTTP/REST',
    path: 'M1,5H9M7,3l2,2-2,2M3,7L1,5l2-2' },
  database: { color: '#22c55e', name: 'Database',
    path: 'M3,2.5C3,1.5,7,1.5,7,2.5V7.5C7,8.5,3,8.5,3,7.5ZM3,5C3,6,7,6,7,5' },
  cache: { color: '#f97316', name: 'Cache',
    path: 'M6,1L3,5.5H5.2L4,9L7.5,4.5H5.3Z' },
  queue: { color: '#a855f7', name: 'Message Queue',
    path: 'M1,3H6L4.5,1.5M6,3L4.5,4.5M1,7H6L4.5,5.5M6,7L4.5,8.5' }
};

// Category info for info popups
const CATEGORY_INFO = {
  'Compute': {
    desc: 'Application servers that handle business logic, request processing, and service orchestration.',
    role: 'The brain of your architecture — processes requests, runs business rules, and coordinates between services.',
    examples: 'Node.js, Go, Python FastAPI, Java Spring, Rust Actix',
    key: 'Choose based on I/O patterns (event-driven vs thread-per-request), ecosystem needs, and team expertise.'
  },
  'Data Storage': {
    desc: 'Persistent databases for structured data with ACID guarantees and complex query support.',
    role: 'The long-term memory — stores everything that needs to survive restarts: users, messages, settings.',
    examples: 'PostgreSQL, MongoDB, MySQL, CockroachDB, DynamoDB',
    key: 'Choose based on data model (relational vs document), consistency needs, and scaling requirements.'
  },
  'Caching': {
    desc: 'In-memory stores for fast data access, session management, and reducing database load.',
    role: 'The short-term memory — holds frequently accessed data close to compute for sub-millisecond reads.',
    examples: 'Redis, Memcached, KeyDB, Dragonfly',
    key: 'Choose based on data structure needs, persistence requirements, and cache invalidation strategy.'
  },
  'Messaging': {
    desc: 'Event streaming and message queue platforms for asynchronous, decoupled communication.',
    role: 'The nervous system — carries events between services without requiring them to be online simultaneously.',
    examples: 'Kafka, RabbitMQ, AWS SQS, Apache Pulsar, NATS',
    key: 'Choose based on ordering guarantees, throughput needs, and whether you need replay capability.'
  },
  'Delivery/Network': {
    desc: 'API gateways, load balancers, CDNs, and reverse proxies that route and manage network traffic.',
    role: 'The front door — manages how traffic enters your system, applies security policies, and distributes load.',
    examples: 'Nginx, AWS API Gateway, Kong, Traefik, CloudFront',
    key: 'Choose based on routing complexity, auth integration, and whether you need managed vs self-hosted.'
  },
  'Real-Time': {
    desc: 'WebSocket servers, SSE endpoints, and pub/sub systems for live data delivery to clients.',
    role: 'The live wire — pushes updates to clients instantly without polling, enabling chat and live dashboards.',
    examples: 'Socket.io, Pusher, Ably, Centrifugo, Phoenix Channels',
    key: 'Choose based on connection scale, message fanout patterns, and client platform requirements.'
  },
  'Auth/Security': {
    desc: 'Authentication providers, authorization engines, and security infrastructure.',
    role: 'The gatekeeper — verifies identity, enforces permissions, and protects data at rest and in transit.',
    examples: 'Auth0, Keycloak, AWS Cognito, custom JWT, OAuth2',
    key: 'Choose based on auth flow complexity (SSO, MFA), compliance requirements, and team capacity.'
  },
  'Monitoring': {
    desc: 'Observability platforms for metrics, logging, tracing, and alerting across your infrastructure.',
    role: 'The eyes and ears — shows what is happening, what broke, and why, before users report it.',
    examples: 'Datadog, Grafana, Prometheus, ELK Stack, Jaeger',
    key: 'Choose based on data volume, retention needs, and whether you need metrics, logs, traces, or all three.'
  },
  'Search': {
    desc: 'Full-text search engines and indexing systems for fast, relevance-ranked content retrieval.',
    role: 'The librarian — indexes your data for fast, fuzzy, and relevance-ranked search experiences.',
    examples: 'Elasticsearch, Algolia, Meilisearch, Typesense',
    key: 'Choose based on index size, query complexity, and whether you need analytics alongside search.'
  },
  'DevOps': {
    desc: 'CI/CD pipelines, container orchestration, infrastructure-as-code, and deployment automation.',
    role: 'The assembly line — automates building, testing, deploying, and scaling your applications.',
    examples: 'Docker, Kubernetes, Terraform, GitHub Actions, ArgoCD',
    key: 'Choose based on deployment frequency, infrastructure complexity, and team DevOps maturity.'
  }
};

// Dashboard metric category info
const DASHBOARD_INFO = {
  perf: {
    name: 'Performance',
    desc: 'How fast your architecture responds to requests and processes data.',
    metrics: 'Latency (p50/p95/p99), throughput (req/s), response time, TTFB',
    impact: 'Directly affects user experience. Every 100ms of added latency reduces conversion by ~1%. Bottlenecks cascade through connected components.',
    improve: 'Cache hot paths, reduce network hops, use connection pooling, optimize queries, consider async processing.'
  },
  cost: {
    name: 'Cost',
    desc: 'Total cost of ownership including infrastructure, licensing, operations, and engineering time.',
    metrics: 'Monthly infra cost, cost per request, license fees, maintenance hours',
    impact: 'Determines sustainability. Over-provisioning wastes money; under-provisioning causes outages.',
    improve: 'Right-size instances, use spot instances, optimize queries, consider serverless for bursty workloads.'
  },
  rel: {
    name: 'Reliability',
    desc: 'How well your architecture handles failures, maintains uptime, and recovers from incidents.',
    metrics: 'Uptime (99.9% = 8.7h/yr downtime), MTTR, error rates, failover success rate',
    impact: 'Trust and reputation. Every minute of downtime erodes user confidence. Requires redundancy.',
    improve: 'Add redundancy, circuit breakers, health checks, graceful degradation, chaos engineering.'
  },
  ops: {
    name: 'Operational Complexity',
    desc: 'How easy your architecture is to deploy, monitor, debug, and maintain day-to-day.',
    metrics: 'Deploy frequency, change failure rate, MTTR, on-call burden, runbook coverage',
    impact: 'Team productivity and morale. Complex ops mean slower shipping and more incidents.',
    improve: 'Automate deployments, improve observability, reduce moving parts, use managed services.'
  },
  scale: {
    name: 'Scalability',
    desc: 'How well your architecture grows with increasing users, data, and traffic.',
    metrics: 'Max concurrent users, horizontal scale factor, auto-scaling responsiveness',
    impact: 'Growth readiness. Non-scalable architectures force expensive rewrites.',
    improve: 'Stateless services, horizontal scaling, data partitioning, caching layers, queue decoupling.'
  },
  strat: {
    name: 'Strategic Flexibility',
    desc: 'Long-term flexibility including vendor independence, technology currency, and hiring.',
    metrics: 'Vendor lock-in score, technology freshness, community size, migration effort',
    impact: 'Future-proofing. Strategic debt accumulates silently until you need to pivot or hire.',
    improve: 'Use open standards, abstract vendor APIs, keep dependencies current, invest in documentation.'
  },
  dev: {
    name: 'Developer Experience',
    desc: 'How productive and happy developers are when building features and fixing bugs.',
    metrics: 'New dev setup time, build time, test feedback loop, debugging ease, docs quality',
    impact: 'Velocity and retention. Good DX means faster shipping. Bad DX means slow onboarding and turnover.',
    improve: 'Fast local setup, comprehensive tests, good docs, consistent patterns, fast CI/CD feedback.'
  }
};

// Code patterns per component + variant — shows WHAT changes at implementation level
const CODE_PATTERNS = {
  'api-gateway': {
    'nginx': `<span class="cm">// Nginx: config-based routing</span>
<span class="kw">upstream</span> ticket_api {
  <span class="kw">server</span> tickets:<span class="num">8080</span>;
}
<span class="kw">server</span> {
  <span class="kw">listen</span> <span class="num">443</span> ssl;
  <span class="kw">location</span> /api/tickets {
    <span class="fn">proxy_pass</span> http://ticket_api;
  }
}`,
    'kong': `<span class="cm">// Kong: plugin ecosystem</span>
services:
  - name: <span class="str">ticket-api</span>
    url: <span class="str">http://tickets:8080</span>
    plugins:
      - name: <span class="fn">jwt</span>
      - name: <span class="fn">rate-limiting</span>
        config: { hour: <span class="num">1000</span> }`,
    'aws-apigw': `<span class="cm">// AWS API Gateway: fully managed</span>
<span class="kw">const</span> api = <span class="kw">new</span> <span class="fn">RestApi</span>(this, <span class="str">'TicketApi'</span>)
api.<span class="fn">root</span>.<span class="fn">addResource</span>(<span class="str">'tickets'</span>)
  .<span class="fn">addMethod</span>(<span class="str">'POST'</span>, lambdaInteg, {
    <span class="fn">authorizer</span>: cognitoAuth
  })`
  },
  'ticket-service': {
    'monolith-module': `<span class="cm">// Monolith: all in one app</span>
<span class="kw">class</span> TicketController {
  <span class="fn">createTicket</span>(req) {
    <span class="kw">const</span> ticket = <span class="kw">this</span>.db.<span class="fn">insert</span>(req)
    <span class="kw">this</span>.assignment.<span class="fn">assign</span>(ticket)
    <span class="kw">return</span> ticket
  }
}`,
    'microservice': `<span class="cm">// Microservice: HTTP boundaries</span>
<span class="kw">async</span> <span class="fn">createTicket</span>(req) {
  <span class="kw">const</span> t = <span class="kw">await</span> db.<span class="fn">insert</span>(req)
  <span class="kw">await</span> http.<span class="fn">post</span>(<span class="str">'/assignment'</span>, t)
  <span class="kw">await</span> events.<span class="fn">publish</span>(<span class="str">'ticket.created'</span>)
  <span class="kw">return</span> t
}`,
    'serverless': `<span class="cm">// Serverless: stateless Lambda</span>
<span class="kw">exports</span>.<span class="fn">handler</span> = <span class="kw">async</span> (event) => {
  <span class="kw">const</span> ticket = <span class="fn">JSON.parse</span>(event.body)
  <span class="kw">await</span> dynamoDB.<span class="fn">put</span>(ticket)
  <span class="kw">await</span> sns.<span class="fn">publish</span>(<span class="str">'TicketCreated'</span>, ticket)
  <span class="kw">return</span> { statusCode: <span class="num">201</span> }
}`
  },
  'assignment-engine': {
    'rule-based': `<span class="cm">// Rule-Based: simple logic</span>
<span class="kw">function</span> <span class="fn">assignExpert</span>(ticket) {
  <span class="kw">const</span> experts = <span class="fn">getAvailable</span>(ticket.skill)
  <span class="kw">return</span> experts.<span class="fn">sort</span>(byLoad)[<span class="num">0</span>]
}`,
    'ml-based': `<span class="cm">// ML-Based: model prediction</span>
<span class="kw">async</span> <span class="fn">assignExpert</span>(ticket) {
  <span class="kw">const</span> prediction = <span class="kw">await</span> model.<span class="fn">predict</span>(ticket)
  <span class="kw">return</span> <span class="fn">getExpert</span>(prediction.expertId)
}`,
    'round-robin': `<span class="cm">// Round-Robin: fair distribution</span>
<span class="kw">let</span> index = <span class="num">0</span>
<span class="kw">function</span> <span class="fn">assignExpert</span>(ticket) {
  <span class="kw">const</span> experts = <span class="fn">getAvailable</span>()
  <span class="kw">return</span> experts[index++ % experts.length]
}`
  },
  'customer-service': {
    'shared-db': `<span class="cm">// Shared DB: direct access</span>
<span class="kw">SELECT</span> * <span class="kw">FROM</span> customers
<span class="kw">WHERE</span> id = <span class="num">?</span>
<span class="cm">-- Same DB as tickets</span>`,
    'separate-service': `<span class="cm">// Separate Service: HTTP API</span>
<span class="kw">const</span> customer = <span class="kw">await</span> http.<span class="fn">get</span>(
  <span class="str">'http://customer-svc/api/customers/'</span> + id
)`,
    'event-sourced': `<span class="cm">// Event-Sourced: replay events</span>
<span class="kw">const</span> events = <span class="fn">getEvents</span>(customerId)
<span class="kw">const</span> customer = events.<span class="fn">reduce</span>(applyEvent, {})
<span class="cm">// Rebuild state from event log</span>`
  },
  'expert-service': {
    'shared-db': `<span class="cm">// Shared DB: direct query</span>
<span class="kw">SELECT</span> * <span class="kw">FROM</span> experts
<span class="kw">WHERE</span> available = <span class="num">true</span>
  <span class="kw">AND</span> skills <span class="fn">@></span> <span class="str">'["networking"]'</span>`,
    'separate-service': `<span class="cm">// Separate Service: isolated DB</span>
<span class="kw">const</span> experts = <span class="kw">await</span> expertAPI.<span class="fn">find</span>({
  available: <span class="num">true</span>,
  skills: [<span class="str">'networking'</span>]
})`
  },
  'notification-service': {
    'sync-http': `<span class="cm">// Sync HTTP: blocking call</span>
<span class="kw">await</span> http.<span class="fn">post</span>(<span class="str">'/notify'</span>, {
  to: expert.email,
  message: <span class="str">'New ticket assigned'</span>
})`,
    'async-queue': `<span class="cm">// Async Queue: SQS/RabbitMQ</span>
<span class="kw">await</span> queue.<span class="fn">send</span>(<span class="str">'notifications'</span>, {
  type: <span class="str">'email'</span>,
  to: expert.email
})`,
    'event-driven': `<span class="cm">// Event-Driven: Kafka consumer</span>
consumer.<span class="fn">on</span>(<span class="str">'ticket.assigned'</span>, (evt) => {
  <span class="fn">sendEmail</span>(evt.expert, evt.ticket)
})`
  },
  'database': {
    'shared-postgresql': `<span class="cm">-- Shared DB: all tables together</span>
<span class="kw">SELECT</span> t.*, c.name, e.name
<span class="kw">FROM</span> tickets t
<span class="kw">JOIN</span> customers c <span class="kw">ON</span> t.customer_id = c.id
<span class="kw">JOIN</span> experts e <span class="kw">ON</span> t.expert_id = e.id
<span class="cm">-- Simple but coupled</span>`,
    'per-service-dbs': `<span class="cm">-- Per-Service DBs: isolated schemas</span>
<span class="cm">-- Ticket DB:</span>
<span class="kw">SELECT</span> * <span class="kw">FROM</span> tickets <span class="kw">WHERE</span> id = <span class="num">?</span>
<span class="cm">-- Customer DB (separate instance):</span>
<span class="kw">SELECT</span> * <span class="kw">FROM</span> customers <span class="kw">WHERE</span> id = <span class="num">?</span>
<span class="cm">-- Saga pattern needed for joins</span>`,
    'cqrs': `<span class="cm">-- CQRS: separate read/write models</span>
<span class="cm">-- Write: normalized</span>
<span class="kw">INSERT INTO</span> tickets (customer_id, ...) ...
<span class="cm">-- Read: denormalized view</span>
<span class="kw">SELECT</span> * <span class="kw">FROM</span> ticket_read_model
<span class="cm">-- Updated async via events</span>`
  },
  'event-bus': {
    'kafka': `<span class="cm">// Kafka: high-throughput streaming</span>
producer.<span class="fn">send</span>({
  topic: <span class="str">'ticket-events'</span>,
  key: ticketId,
  value: <span class="fn">JSON.stringify</span>(event)
})`,
    'rabbitmq': `<span class="cm">// RabbitMQ: classic messaging</span>
channel.<span class="fn">publish</span>(<span class="str">'ticket-exchange'</span>,
  <span class="str">'ticket.created'</span>,
  <span class="fn">Buffer.from</span>(<span class="fn">JSON.stringify</span>(event))
)`,
    'redis-pubsub': `<span class="cm">// Redis Pub/Sub: lightweight</span>
redis.<span class="fn">publish</span>(<span class="str">'ticket-events'</span>,
  <span class="fn">JSON.stringify</span>({
    type: <span class="str">'created'</span>, data: ticket
  })
)`
  }
};

// ═══════════════ DATA ═══════════════
const CATEGORIES = {
  'Compute':          { color: '#3b82f6', shape: 'rectangle' },
  'Data Storage':     { color: '#22c55e', shape: 'cylinder' },
  'Caching':          { color: '#f97316', shape: 'pill' },
  'Messaging':        { color: '#a855f7', shape: 'hexish' },
  'Delivery/Network': { color: '#06b6d4', shape: 'stadium' },
  'Real-Time':        { color: '#ec4899', shape: 'pill' },
  'Auth/Security':    { color: '#ef4444', shape: 'rectangle' },
  'Monitoring':       { color: '#eab308', shape: 'stadium' },
  'Search':           { color: '#14b8a6', shape: 'pill' },
  'DevOps':           { color: '#8b5cf6', shape: 'hexish' }
};

const components = {
  'api-gateway': {
    name: 'API Gateway', category: 'Delivery/Network',
    is: 'Routes and load-balances API traffic to Sysops Squad backend services',
    gain: 'Single entry point, SSL termination, rate limiting',
    cost: 'Additional network hop, config complexity',
    position: { x: 330, y: 20 },
    heatStatus: 'green',
    connections: [
      { target: 'ticket-service', label: 'HTTP', connType: 'http', protocol: 'HTTP/1.1 · HTTPS', pattern: 'Request → Response',
        direction: 'API Gateway forwards client ticket requests to the ticket service',
        role: 'Reverse Proxy',
        summary: 'All external traffic enters through the gateway, which terminates SSL, applies rate limiting, and proxies valid requests to the Ticket Service. The gateway shields the backend from direct internet exposure.',
        latency: '~1-5ms (reverse proxy hop)', colocatable: true,
        code: `<span class="cm">// Nginx proxies to Ticket Service</span>\n<span class="kw">upstream</span> ticket_api {\n  <span class="kw">server</span> <span class="str">127.0.0.1</span>:<span class="num">8080</span>;\n  <span class="fn">keepalive</span> <span class="num">32</span>;\n}\n<span class="kw">location</span> /api/tickets {\n  <span class="fn">proxy_pass</span> http://ticket_api;\n  <span class="fn">proxy_http_version</span> <span class="num">1.1</span>;\n}` }
    ],
    dataContext: [
      { name: 'SSL Termination', icon: 'ssl', behaviors: {
        'nginx': { fit: 'great', note: 'Native SSL support, near-zero overhead' },
        'kong': { fit: 'good', note: 'SSL via plugin, simple configuration' },
        'aws-apigw': { fit: 'great', note: 'Fully managed, auto-renewed certificates' }
      }},
      { name: 'Rate Limiting', icon: 'ratelimit', behaviors: {
        'nginx': { fit: 'tradeoff', note: 'Config-based only, no dynamic rules' },
        'kong': { fit: 'great', note: 'Rich rate-limiting plugin with policies' },
        'aws-apigw': { fit: 'great', note: 'Built-in throttling with usage plans' }
      }},
      { name: 'Request Routing', icon: 'route', behaviors: {
        'nginx': { fit: 'good', note: 'Manual proxy_pass rules, path-based routing' },
        'kong': { fit: 'great', note: 'Service mesh routing, version control' },
        'aws-apigw': { fit: 'great', note: 'Native route management, Lambda integration' }
      }}
    ],
    variants: {
      'nginx': { label: 'Nginx Reverse Proxy',
        metrics: { 'Latency': 88, 'Throughput': 92, 'Cost Efficiency': 85, 'Op. Simplicity': 55, 'Reliability': 70, 'Portability': 95, 'Learning Curve': 55 },
        pros: ['Ultra-low latency','High throughput','Battle-tested'], cons: ['Manual config','No built-in auth'] },
      'kong': { label: 'Kong Gateway',
        metrics: { 'Latency': 75, 'Throughput': 82, 'Cost Efficiency': 65, 'Op. Simplicity': 50, 'Reliability': 75, 'Portability': 80, 'Learning Curve': 45 },
        pros: ['Plugin ecosystem','Open source','Flexible routing'], cons: ['Operational overhead','Learning curve'] },
      'aws-apigw': { label: 'AWS API Gateway',
        metrics: { 'Latency': 60, 'Throughput': 70, 'Cost Efficiency': 45, 'Op. Simplicity': 90, 'Reliability': 92, 'Portability': 30, 'Learning Curve': 78 },
        pros: ['Fully managed','Built-in auth','Auto-scaling'], cons: ['Vendor lock-in','Higher latency','Cost at scale'] }
    },
    currentVariant: 'nginx'
  },
  'ticket-service': {
    name: 'Ticket Service', category: 'Compute',
    is: 'Handles ticket creation, lifecycle management, and status tracking',
    gain: 'Core business logic, ticket workflow engine',
    cost: 'Critical path — failure blocks all ticket operations',
    position: { x: 330, y: 170 },
    heatStatus: 'yellow',
    connections: [
      { target: 'database', label: 'TCP/pg', connType: 'database', protocol: 'PostgreSQL Wire Protocol (TCP:5432)', pattern: 'Connection Pool → Query → Response',
        direction: 'Ticket Service reads and writes ticket data, customer info, and status to the database',
        role: 'Primary Data Store',
        summary: 'The Ticket Service maintains a connection pool to the database for all ticket operations: create, update status, assign to expert, track SLA. Queries use parameterized SQL to prevent injection. This is the critical path for all ticket workflows.',
        latency: '~1-10ms (query dependent)', colocatable: true,
        code: `<span class="cm">// Ticket Service → Database via connection pool</span>\n<span class="kw">const</span> pool = <span class="kw">new</span> <span class="fn">Pool</span>({\n  host: <span class="str">'localhost'</span>,\n  port: <span class="num">5432</span>,\n  max: <span class="num">20</span>,\n  <span class="fn">idleTimeoutMillis</span>: <span class="num">30000</span>\n})\n<span class="kw">const</span> { rows } = <span class="kw">await</span> pool.<span class="fn">query</span>(\n  <span class="str">'UPDATE tickets SET status = $1 WHERE id = $2'</span>,\n  [newStatus, ticketId]\n)` },
      { target: 'assignment-engine', label: 'HTTP/gRPC', connType: 'http', protocol: 'HTTP/1.1 or gRPC', pattern: 'Request → Assignment Response',
        direction: 'Ticket Service calls Assignment Engine to match tickets to available experts',
        role: 'Expert Matching',
        summary: 'When a new ticket is created, the Ticket Service calls the Assignment Engine to find the best-fit expert based on skills, availability, and current workload. The engine returns the assigned expert ID, which the Ticket Service stores in the database.',
        latency: '~10-50ms (depends on assignment algorithm)', colocatable: true,
        code: `<span class="cm">// Ticket Service → Assignment Engine</span>\n<span class="kw">const</span> response = <span class="kw">await</span> <span class="fn">fetch</span>(\n  <span class="str">'http://assignment-engine/assign'</span>,\n  {\n    method: <span class="str">'POST'</span>,\n    body: <span class="fn">JSON.stringify</span>({\n      ticketId, skills, priority\n    })\n  }\n)\n<span class="kw">const</span> { expertId } = <span class="kw">await</span> response.<span class="fn">json</span>()` },
      { target: 'customer-service', label: 'HTTP', connType: 'http', protocol: 'HTTP/1.1', pattern: 'Request → Customer Data',
        direction: 'Ticket Service fetches customer profile and service history from Customer Service',
        role: 'Customer Data Lookup',
        summary: 'When processing a ticket, the Ticket Service retrieves customer contact info, service tier, and support history from the Customer Service. This data enriches the ticket context for experts and helps prioritize SLA requirements.',
        latency: '~5-20ms (HTTP call)', colocatable: true,
        code: `<span class="cm">// Ticket Service → Customer Service</span>\n<span class="kw">const</span> customer = <span class="kw">await</span> <span class="fn">fetch</span>(\n  <span class="str">'http://customer-service/customers/'</span> + customerId\n)\n<span class="kw">const</span> { tier, history } = <span class="kw">await</span> customer.<span class="fn">json</span>()\n<span class="cm">// Use tier to set SLA priority</span>\n<span class="kw">const</span> sla = tier === <span class="str">'premium'</span> ? <span class="num">2</span> : <span class="num">24</span>` },
      { target: 'event-bus', label: 'Kafka TCP', connType: 'queue', protocol: 'Kafka Binary Protocol (TCP:9092)', pattern: 'Produce → Ack (async)',
        direction: 'Ticket Service produces ticket events to Kafka for async processing by downstream consumers',
        role: 'Event Producer',
        summary: 'When ticket status changes (created, assigned, resolved, closed), the Ticket Service publishes an event to Kafka. This decouples notification delivery from the main workflow: Kafka delivers events to the Notification Service for alerting customers and experts.',
        latency: '~5-20ms (broker ack + replication)', colocatable: false,
        code: `<span class="cm">// Ticket Service → Kafka producer</span>\n<span class="kw">const</span> producer = kafka.<span class="fn">producer</span>()\n<span class="kw">await</span> producer.<span class="fn">send</span>({\n  topic: <span class="str">'ticket-events'</span>,\n  messages: [{\n    key: ticketId,\n    value: <span class="fn">JSON.stringify</span>({\n      event: <span class="str">'ticket.assigned'</span>,\n      ticketId, expertId\n    })\n  }]\n})` }
    ],
    dataContext: [
      { name: 'Ticket CRUD', icon: 'endpoint', behaviors: {
        'monolith-module': { fit: 'great', note: 'In-process calls, no network overhead, simple deployment' },
        'microservice': { fit: 'good', note: 'RESTful API, network hop adds latency but enables scaling' },
        'serverless': { fit: 'tradeoff', note: 'Cold start penalty, but auto-scales to zero when idle' }
      }},
      { name: 'Status Workflow', icon: 'endpoint', behaviors: {
        'monolith-module': { fit: 'great', note: 'Shared state machine, ACID transactions across status changes' },
        'microservice': { fit: 'tradeoff', note: 'Eventual consistency if distributed, saga patterns needed' },
        'serverless': { fit: 'poor', note: 'Stateless functions complicate workflow coordination' }
      }},
      { name: 'SLA Tracking', icon: 'endpoint', behaviors: {
        'monolith-module': { fit: 'good', note: 'Simple cron jobs or background workers within process' },
        'microservice': { fit: 'great', note: 'Dedicated SLA service, can scale independently' },
        'serverless': { fit: 'good', note: 'Scheduled Lambda or cloud functions check SLA violations' }
      }}
    ],
    variants: {
      'monolith-module': { label: 'Monolith Module',
        metrics: { 'Latency': 40, 'Throughput': 55, 'Cost Efficiency': 85, 'Op. Simplicity': 90, 'Scalability': 35, 'Reliability': 65, 'Learning Curve': 88 },
        pros: ['Simple deployment','No network overhead','ACID transactions'], cons: ['Vertical scaling only','Tight coupling','Single point of failure'] },
      'microservice': { label: 'Microservice',
        metrics: { 'Latency': 72, 'Throughput': 78, 'Cost Efficiency': 60, 'Op. Simplicity': 45, 'Scalability': 85, 'Reliability': 80, 'Learning Curve': 55 },
        pros: ['Horizontal scaling','Independent deployment','Team autonomy'], cons: ['Network latency','Distributed tracing needed','Eventual consistency'] },
      'serverless': { label: 'Serverless',
        metrics: { 'Latency': 55, 'Throughput': 65, 'Cost Efficiency': 75, 'Op. Simplicity': 70, 'Scalability': 90, 'Reliability': 72, 'Learning Curve': 62 },
        pros: ['Auto-scaling','Pay per invocation','No server management'], cons: ['Cold start latency','Vendor lock-in','Stateless constraints'] }
    },
    currentVariant: 'monolith-module'
  },
  'assignment-engine': {
    name: 'Assignment Engine', category: 'Compute',
    is: 'Matches incoming tickets to available experts based on skills and load',
    gain: 'Automated expert assignment, load balancing',
    cost: 'Assignment quality depends on algorithm choice',
    position: { x: 80, y: 320 },
    heatStatus: 'green',
    connections: [
      { target: 'expert-service', label: 'HTTP', connType: 'http', protocol: 'HTTP/1.1', pattern: 'Request → Expert Data',
        direction: 'Assignment Engine queries Expert Service for availability, skills, and current workload',
        role: 'Expert Data Lookup',
        summary: 'The Assignment Engine fetches the list of available experts, their skill sets, and current ticket load from the Expert Service. This data feeds the assignment algorithm to select the best-fit expert for each incoming ticket.',
        latency: '~5-15ms (HTTP call)', colocatable: true,
        code: `<span class="cm">// Assignment Engine → Expert Service</span>\n<span class="kw">const</span> experts = <span class="kw">await</span> <span class="fn">fetch</span>(\n  <span class="str">'http://expert-service/experts/available'</span>\n)\n<span class="kw">const</span> expertList = <span class="kw">await</span> experts.<span class="fn">json</span>()\n<span class="cm">// Filter by required skills</span>\n<span class="kw">const</span> matches = expertList.<span class="fn">filter</span>(\n  e => e.skills.<span class="fn">includes</span>(requiredSkill)\n)` },
      { target: 'database', label: 'TCP/pg', connType: 'database', protocol: 'PostgreSQL Wire Protocol (TCP:5432)', pattern: 'Connection Pool → Query → Response',
        direction: 'Assignment Engine may query database for historical assignment data and patterns',
        role: 'Historical Data Store',
        summary: 'For ML-based assignment, the engine queries historical ticket-to-expert assignment data to train or refine the model. For rule-based assignment, the database provides skill matrices and availability schedules.',
        latency: '~1-10ms (query dependent)', colocatable: true,
        code: `<span class="cm">// Assignment Engine → Database for historical data</span>\n<span class="kw">const</span> { rows } = <span class="kw">await</span> pool.<span class="fn">query</span>(\n  <span class="str">'SELECT expert_id, AVG(resolution_time) FROM assignments WHERE skill = $1 GROUP BY expert_id'</span>,\n  [skill]\n)\n<span class="cm">// Use stats to prioritize experts</span>` }
    ],
    dataContext: [
      { name: 'Skill Matching', icon: 'route', behaviors: {
        'rule-based': { fit: 'great', note: 'Simple if/else logic, fast, transparent to audit' },
        'ml-based': { fit: 'tradeoff', note: 'Better accuracy over time, but black-box decisions' },
        'round-robin': { fit: 'poor', note: 'Ignores skills entirely, only balances load' }
      }},
      { name: 'Load Balancing', icon: 'endpoint', behaviors: {
        'rule-based': { fit: 'good', note: 'Manual weight rules, static priorities' },
        'ml-based': { fit: 'great', note: 'Adaptive load distribution based on real-time patterns' },
        'round-robin': { fit: 'great', note: 'Perfect load distribution, but ignores skill fit' }
      }},
      { name: 'Priority Routing', icon: 'route', behaviors: {
        'rule-based': { fit: 'great', note: 'Explicit priority rules, SLA-driven assignment' },
        'ml-based': { fit: 'good', note: 'Learns priority patterns but may need tuning' },
        'round-robin': { fit: 'poor', note: 'No priority support, treats all tickets equally' }
      }}
    ],
    variants: {
      'rule-based': { label: 'Rule-Based Assignment',
        metrics: { 'Latency': 85, 'Throughput': 80, 'Cost Efficiency': 90, 'Op. Simplicity': 82, 'Reliability': 75, 'Portability': 88, 'Learning Curve': 85 },
        pros: ['Fast assignment','Transparent logic','Easy to debug'], cons: ['Static rules','No learning','Manual tuning needed'] },
      'ml-based': { label: 'ML-Based Assignment',
        metrics: { 'Latency': 55, 'Throughput': 50, 'Cost Efficiency': 40, 'Op. Simplicity': 25, 'Reliability': 68, 'Portability': 50, 'Learning Curve': 22 },
        pros: ['Adaptive learning','Improved accuracy over time','Pattern detection'], cons: ['Black-box decisions','Training data required','Model drift risk'] },
      'round-robin': { label: 'Round-Robin',
        metrics: { 'Latency': 92, 'Throughput': 90, 'Cost Efficiency': 95, 'Op. Simplicity': 95, 'Reliability': 70, 'Portability': 95, 'Learning Curve': 95 },
        pros: ['Ultra-simple','Perfect load balance','No configuration'], cons: ['Ignores skills','No priority support','Poor expert fit'] }
    },
    currentVariant: 'rule-based'
  },
  'customer-service': {
    name: 'Customer Service', category: 'Compute',
    is: 'Manages customer profiles, contact info, and service history',
    gain: 'Customer data isolation, reusable across services',
    cost: 'Adds network hop when separated, data duplication when event-sourced',
    position: { x: 580, y: 170 },
    heatStatus: 'green',
    connections: [
      { target: 'database', label: 'TCP/pg', connType: 'database', protocol: 'PostgreSQL Wire Protocol (TCP:5432)', pattern: 'Connection Pool → Query → Response',
        direction: 'Customer Service reads and writes customer profiles, contact info, and service tier data',
        role: 'Customer Data Store',
        summary: 'The Customer Service maintains customer profiles, contact information, and service history. When shared-db, it queries the same database as other services. When separated, it owns a dedicated customers database. Event-sourced mode stores all customer state changes as events.',
        latency: '~1-10ms (query dependent)', colocatable: true,
        code: `<span class="cm">// Customer Service → Database</span>\n<span class="kw">const</span> { rows } = <span class="kw">await</span> pool.<span class="fn">query</span>(\n  <span class="str">'SELECT tier, email, phone FROM customers WHERE id = $1'</span>,\n  [customerId]\n)\n<span class="kw">return</span> { tier: rows[<span class="num">0</span>].tier, contact: rows[<span class="num">0</span>] }` }
    ],
    dataContext: [
      { name: 'Customer Profile', icon: 'session', behaviors: {
        'shared-db': { fit: 'great', note: 'Simple joins to tickets table, ACID guarantees' },
        'separate-service': { fit: 'good', note: 'Service isolation, but network hop for data' },
        'event-sourced': { fit: 'tradeoff', note: 'Full audit trail, but query complexity increases' }
      }},
      { name: 'Contact Info', icon: 'endpoint', behaviors: {
        'shared-db': { fit: 'great', note: 'Single source of truth, easy updates' },
        'separate-service': { fit: 'good', note: 'REST API for contact data, versioned schema' },
        'event-sourced': { fit: 'poor', note: 'Contact changes as events — slow for simple lookups' }
      }},
      { name: 'Service History', icon: 'table', behaviors: {
        'shared-db': { fit: 'good', note: 'Historical ticket data via JOIN to tickets table' },
        'separate-service': { fit: 'tradeoff', note: 'Must aggregate across service boundaries' },
        'event-sourced': { fit: 'great', note: 'Full event history enables rich analysis and replay' }
      }}
    ],
    variants: {
      'shared-db': { label: 'Shared Database',
        metrics: { 'Latency': 90, 'Throughput': 85, 'Cost Efficiency': 88, 'Op. Simplicity': 92, 'Consistency': 95, 'Scalability': 35, 'Learning Curve': 90 },
        pros: ['Simple ACID joins','No network overhead','Easy to query'], cons: ['Tight coupling','Schema conflicts','Vertical scaling only'] },
      'separate-service': { label: 'Separate Service',
        metrics: { 'Latency': 65, 'Throughput': 70, 'Cost Efficiency': 55, 'Op. Simplicity': 50, 'Consistency': 72, 'Scalability': 80, 'Learning Curve': 60 },
        pros: ['Service isolation','Independent scaling','Clear API boundaries'], cons: ['Network latency','Eventual consistency','Distributed tracing needed'] },
      'event-sourced': { label: 'Event-Sourced',
        metrics: { 'Latency': 50, 'Throughput': 55, 'Cost Efficiency': 35, 'Op. Simplicity': 22, 'Consistency': 60, 'Scalability': 75, 'Learning Curve': 25 },
        pros: ['Full audit trail','Time-travel queries','Event replay'], cons: ['Complex reads','Storage overhead','Steep learning curve'] }
    },
    currentVariant: 'shared-db'
  },
  'expert-service': {
    name: 'Expert Service', category: 'Compute',
    is: 'Tracks expert availability, skills, and current workload',
    gain: 'Expert data management, availability tracking',
    cost: 'Must stay in sync with assignment engine decisions',
    position: { x: 80, y: 170 },
    heatStatus: 'green',
    connections: [
      { target: 'database', label: 'TCP/pg', connType: 'database', protocol: 'PostgreSQL Wire Protocol (TCP:5432)', pattern: 'Connection Pool → Query → Response',
        direction: 'Expert Service reads and writes expert profiles, skills, availability, and current ticket load',
        role: 'Expert Data Store',
        summary: 'The Expert Service maintains expert profiles, skill matrices, availability schedules, and real-time workload tracking. When shared-db, it queries the same database as other services. When separated, it owns a dedicated experts database.',
        latency: '~1-10ms (query dependent)', colocatable: true,
        code: `<span class="cm">// Expert Service → Database</span>\n<span class="kw">const</span> { rows } = <span class="kw">await</span> pool.<span class="fn">query</span>(\n  <span class="str">'SELECT id, skills, available, current_load FROM experts WHERE available = true'</span>\n)\n<span class="kw">return</span> rows.<span class="fn">map</span>(e => ({\n  id: e.id, skills: e.skills, load: e.current_load\n}))` }
    ],
    dataContext: [
      { name: 'Expert Skills', icon: 'route', behaviors: {
        'shared-db': { fit: 'great', note: 'Simple relational model, easy skill matching queries' },
        'separate-service': { fit: 'good', note: 'REST API for skill lookups, versioned schema' }
      }},
      { name: 'Availability', icon: 'endpoint', behaviors: {
        'shared-db': { fit: 'great', note: 'Real-time updates, ACID transactions for schedule changes' },
        'separate-service': { fit: 'tradeoff', note: 'API latency for availability checks, eventual consistency' }
      }},
      { name: 'Workload', icon: 'counter', behaviors: {
        'shared-db': { fit: 'good', note: 'Simple COUNT queries on tickets table, but tight coupling' },
        'separate-service': { fit: 'great', note: 'Independent workload tracking, can scale separately' }
      }}
    ],
    variants: {
      'shared-db': { label: 'Shared Database',
        metrics: { 'Latency': 90, 'Throughput': 85, 'Cost Efficiency': 88, 'Op. Simplicity': 92, 'Consistency': 95, 'Scalability': 35, 'Learning Curve': 90 },
        pros: ['Simple ACID joins','No network overhead','Easy to query'], cons: ['Tight coupling','Schema conflicts','Vertical scaling only'] },
      'separate-service': { label: 'Separate Service',
        metrics: { 'Latency': 65, 'Throughput': 70, 'Cost Efficiency': 55, 'Op. Simplicity': 50, 'Consistency': 72, 'Scalability': 80, 'Learning Curve': 60 },
        pros: ['Service isolation','Independent scaling','Clear API boundaries'], cons: ['Network latency','Eventual consistency','Distributed tracing needed'] }
    },
    currentVariant: 'shared-db'
  },
  'notification-service': {
    name: 'Notification Service', category: 'Compute',
    is: 'Sends notifications to customers and experts about ticket updates',
    gain: 'Multi-channel notifications, decoupled from core logic',
    cost: 'Delivery guarantees depend on architecture choice',
    position: { x: 580, y: 320 },
    heatStatus: 'yellow',
    connections: [
      { target: 'event-bus', label: 'Subscribe', connType: 'queue', protocol: 'Kafka Binary Protocol (TCP:9092)', pattern: 'Subscribe → Poll → Process',
        direction: 'Notification Service subscribes to ticket events from Kafka',
        role: 'Event Consumer',
        summary: 'The Notification Service subscribes to the ticket-events topic in Kafka. When ticket status changes (created, assigned, resolved, closed), it receives the event and sends email, SMS, or in-app notifications to the relevant customer or expert.',
        latency: '~10-100ms (poll interval + delivery)', colocatable: false,
        code: `<span class="cm">// Notification Service → Kafka consumer</span>\n<span class="kw">const</span> consumer = kafka.<span class="fn">consumer</span>({\n  groupId: <span class="str">'notification-service'</span>\n})\n<span class="kw">await</span> consumer.<span class="fn">subscribe</span>({\n  topic: <span class="str">'ticket-events'</span>\n})\n<span class="kw">await</span> consumer.<span class="fn">run</span>({\n  <span class="fn">eachMessage</span>: <span class="kw">async</span> ({ message }) => {\n    <span class="kw">await</span> <span class="fn">sendNotification</span>(message.value)\n  }\n})` }
    ],
    dataContext: [
      { name: 'Email Alerts', icon: 'message', behaviors: {
        'sync-http': { fit: 'poor', note: 'Blocks ticket workflow until email sent, slow SMTP' },
        'async-queue': { fit: 'great', note: 'Queue email jobs, process asynchronously, retry on failure' },
        'event-driven': { fit: 'great', note: 'Decoupled via events, no blocking, auto-scaling' }
      }},
      { name: 'SMS Notifications', icon: 'endpoint', behaviors: {
        'sync-http': { fit: 'poor', note: 'Blocks workflow, third-party API latency unpredictable' },
        'async-queue': { fit: 'great', note: 'Queued SMS jobs, batch delivery, cost-efficient' },
        'event-driven': { fit: 'good', note: 'Event-driven SMS, but event overhead for high volume' }
      }},
      { name: 'In-App Push', icon: 'presence', behaviors: {
        'sync-http': { fit: 'tradeoff', note: 'WebSocket push is fast, but sync blocks ticket updates' },
        'async-queue': { fit: 'good', note: 'Queue push notifications, but adds latency' },
        'event-driven': { fit: 'great', note: 'Event stream to WebSocket servers, real-time delivery' }
      }}
    ],
    variants: {
      'sync-http': { label: 'Synchronous HTTP',
        metrics: { 'Latency': 35, 'Throughput': 40, 'Cost Efficiency': 85, 'Op. Simplicity': 88, 'Reliability': 55, 'Scalability': 30, 'Learning Curve': 90 },
        pros: ['Simple implementation','Immediate feedback','No queue infrastructure'], cons: ['Blocks main workflow','Third-party latency','Poor error handling'] },
      'async-queue': { label: 'Async Queue',
        metrics: { 'Latency': 70, 'Throughput': 82, 'Cost Efficiency': 65, 'Op. Simplicity': 55, 'Reliability': 80, 'Scalability': 78, 'Learning Curve': 60 },
        pros: ['Non-blocking workflow','Retry on failure','Batch delivery'], cons: ['Queue infrastructure needed','Delivery delay','Eventual consistency'] },
      'event-driven': { label: 'Event-Driven',
        metrics: { 'Latency': 80, 'Throughput': 88, 'Cost Efficiency': 55, 'Op. Simplicity': 35, 'Reliability': 85, 'Scalability': 90, 'Learning Curve': 38 },
        pros: ['Fully decoupled','Auto-scaling','Event replay'], cons: ['Complex architecture','Event schema management','Operational overhead'] }
    },
    currentVariant: 'sync-http'
  },
  'database': {
    name: 'Database', category: 'Data Storage',
    is: 'Persistence layer for all Sysops Squad data — the central coupling point',
    gain: 'ACID guarantees, mature tooling, well-understood',
    cost: 'Shared DB creates tight coupling; per-service DBs need saga patterns',
    position: { x: 330, y: 470 },
    heatStatus: 'red',
    connections: [],
    dataContext: [
      { name: 'Tickets Table', icon: 'table', behaviors: {
        'shared-postgresql': { fit: 'great', note: 'Single source of truth, ACID across all services, easy JOINs' },
        'per-service-dbs': { fit: 'poor', note: 'Ticket data split across DBs, sagas for multi-service updates' },
        'cqrs': { fit: 'tradeoff', note: 'Write model optimized, read model denormalized, eventual consistency' }
      }},
      { name: 'Experts Table', icon: 'table', behaviors: {
        'shared-postgresql': { fit: 'great', note: 'Simple relational joins to tickets, availability tracking' },
        'per-service-dbs': { fit: 'good', note: 'Expert Service owns experts DB, isolated from ticket schema' },
        'cqrs': { fit: 'good', note: 'Event-sourced expert state, projections for read queries' }
      }},
      { name: 'Customers Table', icon: 'session', behaviors: {
        'shared-postgresql': { fit: 'great', note: 'Customer data easily joined to tickets, consistent views' },
        'per-service-dbs': { fit: 'good', note: 'Customer Service owns customers DB, API for lookups' },
        'cqrs': { fit: 'tradeoff', note: 'Event-sourced customer history, but complex for simple lookups' }
      }}
    ],
    variants: {
      'shared-postgresql': { label: 'Shared PostgreSQL',
        metrics: { 'Cost Efficiency': 90, 'Op. Simplicity': 92, 'Consistency': 95, 'Scalability': 30, 'Reliability': 85, 'Portability': 85, 'Learning Curve': 88 },
        pros: ['ACID transactions','Simple joins','Single schema','No distributed transactions'], cons: ['Tight coupling','Schema conflicts','Vertical scaling only','Single point of failure'] },
      'per-service-dbs': { label: 'Per-Service Databases',
        metrics: { 'Cost Efficiency': 40, 'Op. Simplicity': 30, 'Consistency': 55, 'Scalability': 88, 'Reliability': 72, 'Portability': 75, 'Learning Curve': 35 },
        pros: ['Service isolation','Independent scaling','Schema autonomy','Fault isolation'], cons: ['Saga patterns needed','Eventual consistency','Higher operational cost','Cross-service queries hard'] },
      'cqrs': { label: 'CQRS (Event Sourcing)',
        metrics: { 'Cost Efficiency': 25, 'Op. Simplicity': 18, 'Consistency': 45, 'Scalability': 92, 'Reliability': 68, 'Portability': 60, 'Learning Curve': 20 },
        pros: ['Event replay','Audit trail','Optimized read models','Horizontal scaling'], cons: ['Extremely complex','Eventual consistency','Storage overhead','Steep learning curve'] }
    },
    currentVariant: 'shared-postgresql'
  },
  'event-bus': {
    name: 'Event Bus', category: 'Messaging',
    is: 'Async communication backbone for decoupled service coordination',
    gain: 'Decoupled services, event replay, audit trail',
    cost: 'Operational complexity, eventual consistency, debugging harder',
    position: { x: 580, y: 470 },
    heatStatus: 'yellow',
    connections: [
      { target: 'notification-service', label: 'Deliver', connType: 'queue', protocol: 'Kafka Binary Protocol (TCP:9092)', pattern: 'Publish → Subscribe → Process',
        direction: 'Event Bus delivers ticket events to Notification Service for alerting',
        role: 'Event Distribution',
        summary: 'The Event Bus receives ticket events from Ticket Service and delivers them to subscribed consumers like Notification Service. Each event (ticket.created, ticket.assigned, ticket.resolved) triggers a notification to the relevant customer or expert.',
        latency: '~10-100ms (poll interval + delivery)', colocatable: false,
        code: `<span class="cm">// Event Bus → Notification Service delivery</span>\n<span class="cm">// Kafka topic: ticket-events</span>\n<span class="kw">const</span> consumer = kafka.<span class="fn">consumer</span>({\n  groupId: <span class="str">'notification-service'</span>\n})\n<span class="kw">await</span> consumer.<span class="fn">subscribe</span>({\n  topic: <span class="str">'ticket-events'</span>\n})\n<span class="kw">await</span> consumer.<span class="fn">run</span>({\n  <span class="fn">eachMessage</span>: <span class="kw">async</span> ({ message }) => {\n    <span class="kw">await</span> <span class="fn">handleTicketEvent</span>(message.value)\n  }\n})` },
      { target: 'ticket-service', label: 'Consumer', connType: 'queue', protocol: 'Kafka Binary Protocol (TCP:9092)', pattern: 'Publish → Ack',
        direction: 'Ticket Service publishes events to the Event Bus',
        role: 'Event Producer',
        summary: 'The Ticket Service publishes all ticket lifecycle events (created, assigned, in-progress, resolved, closed) to the Event Bus. This decouples the ticket workflow from downstream consumers like notifications, analytics, and audit logging.',
        latency: '~5-20ms (broker ack + replication)', colocatable: false,
        code: `<span class="cm">// Ticket Service → Event Bus producer</span>\n<span class="kw">const</span> producer = kafka.<span class="fn">producer</span>()\n<span class="kw">await</span> producer.<span class="fn">send</span>({\n  topic: <span class="str">'ticket-events'</span>,\n  messages: [{\n    key: ticketId,\n    value: <span class="fn">JSON.stringify</span>({\n      event: <span class="str">'ticket.assigned'</span>,\n      ticketId, expertId, timestamp\n    })\n  }]\n})` }
    ],
    dataContext: [
      { name: 'Ticket Events', icon: 'message', behaviors: {
        'kafka': { fit: 'great', note: 'High throughput, durable, ordered by partition key (ticketId)' },
        'rabbitmq': { fit: 'good', note: 'Flexible routing, but lower throughput than Kafka' },
        'redis-pubsub': { fit: 'poor', note: 'Fire-and-forget, no durability, lost if subscriber down' }
      }},
      { name: 'Assignment Events', icon: 'route', behaviors: {
        'kafka': { fit: 'great', note: 'Event replay enables reassignment analysis, audit trail' },
        'rabbitmq': { fit: 'good', note: 'Reliable delivery, but no replay capability' },
        'redis-pubsub': { fit: 'poor', note: 'No persistence, assignment events lost on failure' }
      }},
      { name: 'Status Changes', icon: 'presence', behaviors: {
        'kafka': { fit: 'great', note: 'Full status history via event log, temporal queries' },
        'rabbitmq': { fit: 'good', note: 'Reliable status delivery, but no historical replay' },
        'redis-pubsub': { fit: 'tradeoff', note: 'Real-time status updates, but no durability' }
      }}
    ],
    variants: {
      'kafka': { label: 'Kafka',
        metrics: { 'Throughput': 92, 'Ordering': 85, 'Scalability': 90, 'Op. Simplicity': 35, 'Reliability': 88, 'Portability': 75, 'Learning Curve': 32 },
        pros: ['High throughput','Event replay','Durable storage','Horizontal scaling'], cons: ['Complex setup','Zookeeper dependency','Steep learning curve','Operational overhead'] },
      'rabbitmq': { label: 'RabbitMQ',
        metrics: { 'Throughput': 72, 'Ordering': 70, 'Scalability': 65, 'Op. Simplicity': 70, 'Reliability': 78, 'Portability': 82, 'Learning Curve': 68 },
        pros: ['Flexible routing','Easy setup','Good tooling','AMQP standard'], cons: ['Lower throughput','No event replay','Vertical scaling limits'] },
      'redis-pubsub': { label: 'Redis Pub/Sub',
        metrics: { 'Throughput': 80, 'Ordering': 55, 'Scalability': 50, 'Op. Simplicity': 85, 'Reliability': 50, 'Portability': 88, 'Learning Curve': 82 },
        pros: ['Ultra-simple','Fast delivery','Low latency','Easy to debug'], cons: ['Fire-and-forget','No durability','Lost on subscriber failure','No ordering guarantees'] }
    },
    currentVariant: 'kafka'
  }
};

const dashboardCategories = [
  { name: 'Perf', key: 'perf', icon: 'perf' },
  { name: 'Cost', key: 'cost', icon: 'cost_dash' },
  { name: 'Reliab', key: 'rel', icon: 'rel' },
  { name: 'Ops', key: 'ops', icon: 'ops' },
  { name: 'Scale', key: 'scale', icon: 'scale' },
  { name: 'Strat', key: 'strat', icon: 'strat' },
  { name: 'Dev', key: 'dev', icon: 'dev_dash' }
];

// Maps each component metric to a dashboard category key
const METRIC_TO_CATEGORY = {
  'Latency': 'perf',
  'Throughput': 'perf',
  'Read Perf': 'perf',
  'Write Perf': 'perf',
  'Cost Efficiency': 'cost',
  'Reliability': 'rel',
  'Consistency': 'rel',
  'Ordering': 'rel',
  'Op. Simplicity': 'ops',
  'Scalability': 'scale',
  'Portability': 'strat',
  'Learning Curve': 'dev'
};

// ═══════════════ STATE ═══════════════
const state = {
  selectedNode: null,
  selectedConnection: null, // { sourceId, targetId }
  heatmapEnabled: false,
  toolboxTab: 'components',
  swapOpenNode: null,
  variantOpenNode: null,
  // Node drag state
  dragging: null,    // node id being dragged
  dragStart: null,   // { mx, my, nx, ny } mouse + node start positions
  dragMoved: false,  // true if mouse actually moved (to distinguish click vs drag)
  // Connection label drag state
  draggingConn: null,  // { sourceId, targetId, connIdx }
  connDragStart: null, // { mx, my, ox, oy } mouse + original offset
  // Collapsible section state
  collapsedSections: new Set(),
  lastDeltas: {},
  deltaTimeout: null,
  issuesOpen: false,
  flowParticles: [],
  flowAnimationId: null,
  hiddenMetrics: new Set(['Reliability', 'Portability', 'Learning Curve']),
  metricFilterOpen: false,
  inspSwapOpen: false,
  inspVariantOpen: false,
  dashboardExpanded: false
};
let connectionPathData = [];

// ═══════════════ HELPER FUNCTIONS ═══════════════

function getMetricColor(value) {
  if (value >= 70) return 'var(--green)';
  if (value >= 40) return 'var(--yellow)';
  return 'var(--red)';
}

function getHeatColor(status) {
  if (status === 'green') return 'var(--green)';
  if (status === 'yellow') return 'var(--yellow)';
  return 'var(--red)';
}

function getConnectionHealth(srcId, tgtId) {
  const src = components[srcId];
  const tgt = components[tgtId];
  // Worst of the two endpoints
  const priority = { 'red': 0, 'yellow': 1, 'green': 2 };
  return priority[src.heatStatus] <= priority[tgt.heatStatus] ? src.heatStatus : tgt.heatStatus;
}

const HEALTH_LABELS = {
  green: { label: 'Healthy', color: 'var(--green)', icon: 'gain',
    desc: 'Both endpoints are performing well. This connection is not a bottleneck — data flows efficiently between these components.' },
  yellow: { label: 'Warning', color: 'var(--yellow)', icon: 'Monitoring',
    desc: 'One or both endpoints have degraded metrics. This connection may become a bottleneck under load. Consider optimizing the weaker endpoint or adjusting its configuration variant.' },
  red: { label: 'Bottleneck', color: 'var(--red)', icon: 'cons',
    desc: 'One or both endpoints are critically underperforming. This connection is likely a system bottleneck. The weakest endpoint constrains the entire path — improving it will have the most impact.' }
};

function buildEndpointMetricDetail(nodeId, panelId) {
  const c = components[nodeId];
  const metrics = c.variants[c.currentVariant].metrics;
  const entries = Object.entries(metrics);
  const belowThreshold = entries.filter(([, v]) => v < 70);
  const causeText = belowThreshold.length === 0
    ? '<div style="font-size:10px;color:var(--green);margin-bottom:4px">All metrics above threshold</div>'
    : `<div class="conn-health-metrics-label">${belowThreshold.length} metric${belowThreshold.length > 1 ? 's' : ''} below threshold (70)</div>`;
  return `<div class="conn-health-metrics" id="${panelId}">
    ${causeText}
    ${entries.map(([name, val]) => {
      const color = getMetricColor(val);
      const isCause = val < 70;
      return `<div class="conn-health-metric-row">
        <span class="conn-health-metric-flag" style="color:${isCause ? 'var(--red)' : 'transparent'}">${isCause ? '!' : ''}</span>
        <span class="conn-health-metric-name" style="${isCause ? 'color:var(--text-primary);font-weight:500' : ''}">${name}</span>
        <div class="conn-health-metric-bar">
          <div class="conn-health-metric-fill" style="width:${val}%;background:${color}"></div>
        </div>
        <span class="conn-health-metric-val" style="color:${color}">${val}</span>
      </div>`;
    }).join('')}
  </div>`;
}

function toggleConnHealthDetail(panelId, event) {
  if (event) event.stopPropagation();
  const el = document.getElementById(panelId);
  if (el) el.classList.toggle('visible');
}

function renderConnectionHealth(srcId, tgtId) {
  const health = getConnectionHealth(srcId, tgtId);
  const h = HEALTH_LABELS[health];
  const src = components[srcId];
  const tgt = components[tgtId];
  const srcH = HEALTH_LABELS[src.heatStatus];
  const tgtH = HEALTH_LABELS[tgt.heatStatus];
  const infoIcon = `<svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><circle cx="8" cy="8" r="6"/><path d="M8 7v4M8 5v.5"/></svg>`;
  const content = `<div class="conn-health-indicator">
      <div class="conn-health-badge" style="background:${h.color}20;color:${h.color};border:1px solid ${h.color}40">
        <span class="conn-health-dot" style="background:${h.color}"></span> ${h.label}
      </div>
      <div class="conn-health-desc">${h.desc}</div>
      <div class="conn-health-endpoints">
        <div>
          <div class="conn-health-ep" style="cursor:pointer" title="Inspect ${src.name}">
            <span class="conn-health-dot" style="background:${srcH.color}"></span>
            <span onclick="selectNode('${srcId}')" style="text-decoration:underline;text-decoration-style:dotted;cursor:pointer">${src.name}</span>
            <span style="color:${srcH.color};font-weight:600;margin-left:auto">${srcH.label}</span>
            <button class="conn-health-info-btn" onclick="toggleConnHealthDetail('chd-${srcId}', event)" title="Show metric details">${infoIcon}</button>
          </div>
          ${buildEndpointMetricDetail(srcId, 'chd-' + srcId)}
        </div>
        <div>
          <div class="conn-health-ep" style="cursor:pointer" title="Inspect ${tgt.name}">
            <span class="conn-health-dot" style="background:${tgtH.color}"></span>
            <span onclick="selectNode('${tgtId}')" style="text-decoration:underline;text-decoration-style:dotted;cursor:pointer">${tgt.name}</span>
            <span style="color:${tgtH.color};font-weight:600;margin-left:auto">${tgtH.label}</span>
            <button class="conn-health-info-btn" onclick="toggleConnHealthDetail('chd-${tgtId}', event)" title="Show metric details">${infoIcon}</button>
          </div>
          ${buildEndpointMetricDetail(tgtId, 'chd-' + tgtId)}
        </div>
      </div>
      <div class="conn-health-rule">Health = worst of the two endpoints</div>
    </div>`;
  return collapsible('conn-health', 'Monitoring', 'var(--text-secondary)', 'Connection Health', content);
}

function icon(name, color) {
  const svg = ICONS[name] || '';
  if (color) return svg.replace(/stroke="currentColor"/g, `stroke="${color}"`);
  return svg;
}

// ═══════════════ COLLAPSIBLE HELPER ═══════════════

function toggleInspSwap(event) {
  if (event) event.stopPropagation();
  state.inspVariantOpen = false;
  state.inspSwapOpen = !state.inspSwapOpen;
  renderInspector();
  if (state.inspSwapOpen) positionInspDropdown('.insp-swap-btn', '.insp-header-dropdown.swap');
}

function toggleInspVariant(event) {
  if (event) event.stopPropagation();
  state.inspSwapOpen = false;
  state.inspVariantOpen = !state.inspVariantOpen;
  renderInspector();
  if (state.inspVariantOpen) positionInspDropdown('.insp-variant-btn', '.insp-header-dropdown.variant');
}

function positionInspDropdown(btnSelector, menuSelector) {
  const btn = document.querySelector(btnSelector);
  const menu = document.querySelector(menuSelector);
  if (!btn || !menu) return;
  const rect = btn.getBoundingClientRect();
  menu.style.top = (rect.bottom + 4) + 'px';
  // For swap dropdown, align left; for variant, align right
  if (menuSelector.includes('swap')) {
    menu.style.left = rect.left + 'px';
  } else {
    menu.style.right = (window.innerWidth - rect.right) + 'px';
  }
}

function inspSwapComponent(newId, event) {
  if (event) event.stopPropagation();
  state.inspSwapOpen = false;
  swapComponent(state.selectedNode, newId);
}

function inspChangeVariant(variantKey, event) {
  if (event) event.stopPropagation();
  state.inspVariantOpen = false;
  changeVariant(state.selectedNode, variantKey);
}

function toggleMetricFilter(event) {
  if (event) event.stopPropagation();
  state.metricFilterOpen = !state.metricFilterOpen;
  renderInspector();
  if (state.metricFilterOpen) {
    positionMetricFilterMenu();
  }
}

function positionMetricFilterMenu() {
  const btn = document.querySelector('.metric-filter-btn');
  const menu = document.querySelector('.metric-filter-menu');
  if (!btn || !menu) return;
  const rect = btn.getBoundingClientRect();
  menu.style.top = (rect.bottom + 4) + 'px';
  menu.style.right = (window.innerWidth - rect.right) + 'px';
}

function toggleMetricVisibility(metricName, event) {
  if (event) event.stopPropagation();
  if (state.hiddenMetrics.has(metricName)) {
    state.hiddenMetrics.delete(metricName);
  } else {
    state.hiddenMetrics.add(metricName);
  }
  renderInspector();
  if (state.metricFilterOpen) positionMetricFilterMenu();
}

function setAllMetrics(show, event) {
  if (event) event.stopPropagation();
  const c = components[state.selectedNode];
  const v = c.variants[c.currentVariant];
  if (show) {
    Object.keys(v.metrics).forEach(name => state.hiddenMetrics.delete(name));
  } else {
    Object.keys(v.metrics).forEach(name => state.hiddenMetrics.add(name));
  }
  renderInspector();
  if (state.metricFilterOpen) positionMetricFilterMenu();
}

function toggleMetricExplanation(panelId, event) {
  if (event) event.stopPropagation();
  const el = document.getElementById(panelId);
  if (!el) return;
  // Close other open metric explanations first
  document.querySelectorAll('.metric-explanation.visible').forEach(other => {
    if (other.id !== panelId) other.classList.remove('visible');
  });
  el.classList.toggle('visible');
}

function toggleSection(sectionId) {
  if (state.collapsedSections.has(sectionId)) {
    state.collapsedSections.delete(sectionId);
  } else {
    state.collapsedSections.add(sectionId);
  }
  const body = document.getElementById(sectionId);
  if (body) body.classList.toggle('collapsed');
  const title = document.querySelector(`[data-toggle="${sectionId}"]`);
  if (title) {
    const chev = title.querySelector('.section-chevron');
    if (chev) chev.classList.toggle('open');
  }
}

function collapsible(id, titleIcon, titleColor, titleText, content) {
  const isCollapsed = state.collapsedSections.has(id);
  return `<div class="insp-section">
    <div class="insp-section-title collapsible" data-toggle="${id}" onclick="toggleSection('${id}')">
      ${icon(titleIcon, titleColor)} ${titleText}
      <span class="section-chevron ${isCollapsed ? '' : 'open'}">${icon('chevron', 'var(--text-secondary)')}</span>
    </div>
    <div class="insp-section-body ${isCollapsed ? 'collapsed' : ''}" id="${id}">${content}</div>
  </div>`;
}

// ═══════════════ RENDER FUNCTIONS ═══════════════

function renderLegend() {
  const el = document.getElementById('canvasLegend');
  if (state.heatmapEnabled) {
    el.innerHTML = `
      <div class="legend-title">${icon('Monitoring', 'var(--text-secondary)')} Health Overlay</div>
      <div class="legend-item"><div class="legend-dot" style="border-color:var(--green)"></div> Healthy</div>
      <div class="legend-item"><div class="legend-dot" style="border-color:var(--yellow)"></div> Warning</div>
      <div class="legend-item"><div class="legend-dot" style="border-color:var(--red)"></div> Bottleneck</div>
      <div class="legend-divider"></div>
      <div class="legend-item"><div class="legend-swatch" style="background:var(--green)"></div> Line: healthy</div>
      <div class="legend-item"><div class="legend-swatch" style="background:var(--yellow);height:2px;border-top:1px dashed var(--yellow)"></div> Line: warning</div>
      <div class="legend-item"><div class="legend-swatch" style="background:var(--red);height:2px;border-top:1px dashed var(--red)"></div> Line: bottleneck</div>
    `;
  } else {
    // Show category legend for visible categories
    const usedCats = new Set(Object.values(components).map(c => c.category));
    el.innerHTML = `
      <div class="legend-title">${icon('Search', 'var(--text-secondary)')} Component Types</div>
      ${[...usedCats].map(cat => `<div class="legend-item clickable" onclick="showCategoryInfo('${cat}')" title="About ${cat}">${icon(cat, CATEGORIES[cat].color)} <span style="color:var(--text-secondary)">${cat}</span></div>`).join('')}
    `;
  }
}

function renderToolbox() {
  const el = document.getElementById('toolboxContent');
  if (state.toolboxTab === 'components') {
    // Build a set of component names currently on canvas
    const onCanvas = new Set(Object.values(components).map(c => c.name));

    el.innerHTML = Object.entries(COMPONENT_CATALOG).map(([catName, items]) => {
      const cat = CATEGORIES[catName];
      const info = CATEGORY_INFO[catName];
      const groupId = `catgrp-${catName.replace(/[^a-zA-Z]/g, '')}`;
      const isCollapsed = state.collapsedSections.has(groupId);
      const activeCount = items.filter(i => onCanvas.has(i.name)).length;

      return `<div class="cat-group">
        <div class="cat-group-header" onclick="toggleSection('${groupId}')" data-toggle="${groupId}">
          ${icon(catName, cat.color)}
          <span class="cat-group-name" style="color:${cat.color}">${catName}</span>
          ${activeCount ? `<span class="cat-item-active">${activeCount} in use</span>` : ''}
          <span class="cat-group-count">${items.length}</span>
          <span class="section-chevron ${isCollapsed ? '' : 'open'}">${icon('chevron', 'var(--text-secondary)')}</span>
        </div>
        <div class="cat-group-body ${isCollapsed ? 'collapsed' : ''}" id="${groupId}">
          ${info ? `<div class="cat-group-desc">${info.role}</div>` : ''}
          ${items.map(item => {
            const isActive = onCanvas.has(item.name);
            const fromTags = item.connectsFrom.map(t => `<span class="cat-item-tip-tag">${t}</span>`).join('');
            const toTags = item.connectsTo.map(t => `<span class="cat-item-tip-tag">${t}</span>`).join('');
            // Find the canvas node id if this component is on canvas
            const canvasId = Object.entries(components).find(([, c]) => c.name === item.name)?.[0];
            return `<div class="cat-item${isActive ? ' active-item' : ''}" ${canvasId ? `ondblclick="selectNode('${canvasId}')"` : ''}>
              <span class="cat-item-dot" style="background:${cat.color}${isActive ? '' : '60'}"></span>
              <span class="cat-item-name">${item.name}</span>
              ${isActive ? '<span class="cat-item-active">ON CANVAS</span>' : ''}
              <span class="cat-item-sub">${item.sub}</span>
              <div class="cat-item-tip">
                <strong>${item.name}</strong> <span style="color:var(--text-secondary)">· ${item.sub}</span>
                ${item.connectsFrom.length ? `<div class="cat-item-tip-label">Receives from</div><div class="cat-item-tip-list">${fromTags}</div>` : ''}
                ${item.connectsTo.length ? `<div class="cat-item-tip-label">Connects to</div><div class="cat-item-tip-list">${toTags}</div>` : ''}
              </div>
            </div>`;
          }).join('')}
        </div>
      </div>`;
    }).join('');
  } else if (state.toolboxTab === 'stacks') {
    el.innerHTML = `<div class="component-card" style="border-left-color:var(--accent)">
      <div class="card-header">
        <div class="card-icon">${icon('Messaging', 'var(--accent)')}</div>
        <div><div class="card-name">Real-Time Messaging Stack</div><div class="card-category">${icon('Messaging', 'var(--accent)')} 5 components</div></div></div>
      <div class="card-section"><div class="card-section-label card-is">${icon('is', 'var(--text-secondary)')} IS</div>Pre-wired stack for real-time message delivery with persistence and caching</div>
      <div class="card-section"><div class="card-section-label card-gain">${icon('gain', 'var(--green)')} GAIN</div>Complete messaging pipeline, proven pattern</div>
      <div class="card-section"><div class="card-section-label card-cost">${icon('cost', 'var(--yellow)')} COST</div>Full Kafka + Redis operational burden</div>
    </div>
    <div class="component-card" style="border-left-color:var(--cat-auth)">
      <div class="card-header">
        <div class="card-icon">${icon('Auth/Security', 'var(--cat-auth)')}</div>
        <div><div class="card-name">Auth Stack</div><div class="card-category">${icon('Auth/Security', 'var(--cat-auth)')} 3 components</div></div></div>
      <div class="card-section"><div class="card-section-label card-is">${icon('is', 'var(--text-secondary)')} IS</div>Authentication and authorization with JWT, rate limiting, and session store</div>
    </div>`;
  } else {
    el.innerHTML = `<div class="component-card" style="border-left-color:var(--accent)">
      <div class="card-header">
        <div class="card-icon">${icon('Delivery/Network', 'var(--accent)')}</div>
        <div><div class="card-name">Sysops Squad</div><div class="card-category">${icon('Monitoring', 'var(--accent)')} Tier 2 · 8 components</div></div></div>
      <div class="card-section"><div class="card-section-label card-is">${icon('is', 'var(--text-secondary)')} IS</div>Real-time messaging with persistent storage, caching layer, and event streaming</div>
    </div>
    <div class="component-card" style="border-left-color:var(--cat-realtime)">
      <div class="card-header">
        <div class="card-icon">${icon('Real-Time', 'var(--cat-realtime)')}</div>
        <div><div class="card-name">IT Service Desk (Lite)</div><div class="card-category">${icon('Monitoring', 'var(--cat-realtime)')} Tier 1 · 4 components</div></div></div>
      <div class="card-section"><div class="card-section-label card-is">${icon('is', 'var(--text-secondary)')} IS</div>Multi-datacenter messaging with MTProto, distributed file storage, and bot platform</div>
    </div>`;
  }
}

const VARIANT_ICON = '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.5"><circle cx="6" cy="6" r="2"/><path d="M6 1v2M6 9v2M1 6h2M9 6h2"/></svg>';

function renderNodes() {
  const container = document.getElementById('nodesContainer');
  container.innerHTML = Object.entries(components).map(([id, c]) => {
    const cat = CATEGORIES[c.category];
    const v = c.variants[c.currentVariant];
    const allMetrics = Object.entries(v.metrics);
    const visibleMetrics = allMetrics.filter(([k]) => !state.hiddenMetrics.has(k));
    const isSelected = state.selectedNode === id;
    let heatClass = '';
    if (state.heatmapEnabled) heatClass = `heatmap-${c.heatStatus}`;
    const alts = ALTERNATIVES[id] || [];
    const swapOpen = state.swapOpenNode === id;
    const variantOpen = state.variantOpenNode === id;
    const variantKeys = Object.keys(c.variants);
    const hasDropdown = swapOpen || variantOpen;
    return `<div class="node ${isSelected ? 'selected' : ''} ${heatClass}" id="node-${id}"
      data-shape="${cat.shape}" data-node-id="${id}"
      style="left:${c.position.x}px;top:${c.position.y}px;border-top:3px solid ${cat.color}${hasDropdown ? ';z-index:15' : ''}"
      onmousedown="startDrag(event, '${id}')">
      <div class="node-tooltip">
        <div class="tooltip-header">${icon(c.category, cat.color)} <strong>${c.name}</strong> · <span style="color:var(--text-secondary)">${c.category}</span></div>
        <div class="tooltip-metrics">
          ${visibleMetrics.slice(0,4).map(([k,val]) => `<div class="tooltip-metric">${k}: <span>${val}</span></div>`).join('')}
        </div>
      </div>
      <div class="node-body">
        <div class="node-header">
          <div class="node-icon clickable" onclick="event.stopPropagation(); ${alts.length > 1 ? `toggleSwapDropdown('${id}')` : `showCategoryInfo('${c.category}')`}" title="${alts.length > 1 ? 'Swap component' : 'About ' + c.category}">${icon(c.category, cat.color)}</div>
          <div class="node-name">${c.name}</div>
        </div>
        ${swapOpen ? `<div class="node-dropdown left" onclick="event.stopPropagation()">
          ${alts.map(a => `<div class="swap-option ${a.id === id ? 'current' : ''}" onclick="swapComponent('${id}', '${a.id}')">
            ${icon(c.category, cat.color)} ${a.name} <span class="swap-option-sub">${a.sub}</span>
          </div>`).join('')}
        </div>` : ''}
        ${variantKeys.length > 1 ? `<div class="node-variant-btn" onclick="event.stopPropagation(); toggleVariantDropdown('${id}')" title="Change configuration variant">${VARIANT_ICON}</div>` : ''}
        ${variantOpen ? `<div class="node-dropdown right" onclick="event.stopPropagation()">
          ${variantKeys.map(vk => {
            const vl = c.variants[vk];
            return `<div class="swap-option ${vk === c.currentVariant ? 'current' : ''}" onclick="changeVariantFromNode('${id}', '${vk}')">
              ${VARIANT_ICON} ${vl.label} ${vk === c.currentVariant ? '<span class="swap-option-sub">Current</span>' : ''}
            </div>`;
          }).join('')}
        </div>` : ''}
        <div class="node-variant">${v.label}</div>
        <div class="node-mini-metrics">
          ${visibleMetrics.map(([k,val]) => `<div class="node-mini-bar"><div class="node-mini-fill" style="width:${val}%;background:${getMetricColor(val)}"></div></div>`).join('')}
        </div>
      </div>
    </div>`;
  }).join('');
}

function renderConnections() {
  connectionPathData = [];
  const svg = document.getElementById('canvasSvg');
  let defs = `<defs>
    <marker id="arrowDefault" markerWidth="8" markerHeight="6" refX="8" refY="3" orient="auto"><path d="M0,0 L8,3 L0,6" fill="var(--border)"/></marker>
    <marker id="arrowGreen" markerWidth="8" markerHeight="6" refX="8" refY="3" orient="auto"><path d="M0,0 L8,3 L0,6" fill="var(--green)"/></marker>
    <marker id="arrowYellow" markerWidth="8" markerHeight="6" refX="8" refY="3" orient="auto"><path d="M0,0 L8,3 L0,6" fill="var(--yellow)"/></marker>
    <marker id="arrowRed" markerWidth="8" markerHeight="6" refX="8" refY="3" orient="auto"><path d="M0,0 L8,3 L0,6" fill="var(--red)"/></marker>
    <marker id="arrowAccent" markerWidth="8" markerHeight="6" refX="8" refY="3" orient="auto"><path d="M0,0 L8,3 L0,6" fill="var(--accent)"/></marker>
  </defs>`;
  let paths = '';
  let labels = '';
  Object.entries(components).forEach(([id, c]) => {
    c.connections.forEach((conn, ci) => {
      const targetId = conn.target;
      const src = c.position;
      const tgt = components[targetId].position;
      const sx = src.x + 76, sy = src.y + 50;
      const tx = tgt.x + 76, ty = tgt.y + 10;
      const baseMx = (sx + tx) / 2, baseMy = (sy + ty) / 2;
      // Offset defines where the LABEL sits (on the curve at t=0.5)
      if (!conn.offset) conn.offset = { x: 0, y: 0 };
      // Label position = midpoint + offset (this is where the curve passes at t=0.5)
      const lx = baseMx + conn.offset.x;
      const ly = baseMy + conn.offset.y;
      // Derive control point so curve passes through label at t=0.5
      // P(0.5) = 0.25*P0 + 0.5*Pc + 0.25*P1  →  Pc = 2*P(0.5) - 0.5*(P0+P1)
      const cpx = 2 * lx - 0.5 * (sx + tx);
      const cpy = 2 * ly - 0.5 * (sy + ty);
      const pathD = `M${sx},${sy} Q${cpx},${cpy} ${tx},${ty}`;
      const health = getConnectionHealth(id, targetId);
      connectionPathData.push({ sx, sy, cpx, cpy, tx, ty, health });
      let heatClass = '';
      let markerEnd = 'url(#arrowDefault)';
      if (state.heatmapEnabled) {
        heatClass = `heat-${health}`;
        markerEnd = `url(#arrow${health.charAt(0).toUpperCase() + health.slice(1)})`;
      }
      const isSelected = state.selectedConnection &&
        state.selectedConnection.sourceId === id && state.selectedConnection.targetId === targetId;
      if (isSelected) markerEnd = 'url(#arrowAccent)';
      paths += `<path id="conn-${id}-${targetId}" class="conn-path ${heatClass} ${isSelected ? 'conn-selected' : ''}" d="${pathD}" marker-end="${markerEnd}"/>`;
      // Label sits exactly on the curve at t=0.5
      const labelText = conn.label || '';
      const connType = conn.connType || 'http';
      const ctDef = CONN_TYPE_DEFS[connType];
      const iconSpace = 14; // 10px icon + 4px gap
      const labelW = labelText.length * 6 + 16 + iconSpace;
      const iconX = lx - labelW/2 + 4;
      const iconY = ly - 5;
      const textX = lx + iconSpace/2;
      labels += `<g class="conn-label-group ${isSelected ? 'selected' : ''}"
        onmousedown="event.stopPropagation(); startConnDrag(event, '${id}', '${targetId}', ${ci})"
        onclick="event.stopPropagation();">
        <rect class="conn-label-bg ${isSelected ? 'selected' : ''}" x="${lx - labelW/2}" y="${ly - 9}" width="${labelW}" height="18" />
        <g transform="translate(${iconX},${iconY}) scale(1)"><path d="${ctDef.path}" fill="none" stroke="${ctDef.color}" stroke-width="1.3"/></g>
        <text class="conn-label-text" x="${textX}" y="${ly}">${labelText}</text>
      </g>`;
    });
  });
  svg.innerHTML = defs + paths + labels;
}

function renderInspector() {
  const el = document.getElementById('inspectorContent');

  // Connection detail view
  if (state.selectedConnection) {
    const { sourceId, targetId } = state.selectedConnection;
    const conn = getConnectionData(sourceId, targetId);
    const srcComp = components[sourceId];
    const tgtComp = components[targetId];
    if (!conn || !srcComp || !tgtComp) { state.selectedConnection = null; return renderInspector(); }
    const srcCat = CATEGORIES[srcComp.category];
    const tgtCat = CATEGORIES[tgtComp.category];
    el.innerHTML = `
      <div class="conn-header">
        <div class="conn-endpoint" onclick="selectNode('${sourceId}')" title="Inspect ${srcComp.name}">
          <div class="conn-ep-icon" style="border-color:${srcCat.color}">${icon(srcComp.category, srcCat.color)}</div>
          <div class="conn-ep-name">${srcComp.name}</div>
        </div>
        <div class="conn-header-arrow">${icon('arrow_right', 'var(--text-secondary)')}</div>
        <div class="conn-endpoint" onclick="selectNode('${targetId}')" title="Inspect ${tgtComp.name}">
          <div class="conn-ep-icon" style="border-color:${tgtCat.color}">${icon(tgtComp.category, tgtCat.color)}</div>
          <div class="conn-ep-name">${tgtComp.name}</div>
        </div>
      </div>
      <div class="conn-meta">
        <span class="conn-protocol-badge">${conn.label}</span>
        ${conn.role ? `<span class="conn-role-tag">${conn.role}</span>` : ''}
      </div>
      ${conn.direction ? `<div class="conn-direction-text">${conn.direction}</div>` : ''}
      <div class="conn-props-strip">
        <div class="conn-prop-chip">
          ${icon('protocol', 'var(--text-secondary)')}
          <span class="conn-prop-chip-label">Protocol</span>
          <span class="conn-prop-chip-val">${conn.protocol}</span>
        </div>
        <div class="conn-prop-chip">
          ${icon('pattern', 'var(--text-secondary)')}
          <span class="conn-prop-chip-label">Pattern</span>
          <span class="conn-prop-chip-val">${conn.pattern}</span>
        </div>
        <div class="conn-prop-chip">
          ${icon('speed', 'var(--text-secondary)')}
          <span class="conn-prop-chip-label">Latency</span>
          <span class="conn-prop-chip-val">${conn.latency}</span>
        </div>
        <div class="conn-prop-chip ${conn.colocatable ? 'positive' : 'negative'}">
          ${icon('coloc', conn.colocatable ? 'var(--green)' : 'var(--red)')}
          <span class="conn-prop-chip-label">Co-locatable</span>
          <span class="conn-prop-chip-val">${conn.colocatable ? 'Yes' : 'No'}</span>
        </div>
      </div>
      ${conn.summary ? collapsible('conn-summary', 'is', 'var(--text-secondary)', 'What This Connection Does',
        `<div class="conn-summary">${conn.summary}</div>`) : ''}
      ${renderConnectionHealth(sourceId, targetId)}
      ${conn.code ? collapsible('conn-code', 'code', 'var(--text-secondary)', 'Connection Code',
        `<div class="conn-code-pattern">${conn.code}</div>`) : ''}
      <div class="conn-footer">
        <div class="conn-footer-link" onclick="selectNode('${sourceId}')">
          ${icon(srcComp.category, srcCat.color)} ${srcComp.name}
        </div>
        <div class="conn-footer-link" onclick="selectNode('${targetId}')">
          ${icon(tgtComp.category, tgtCat.color)} ${tgtComp.name}
        </div>
      </div>
    `;
    return;
  }

  if (!state.selectedNode) {
    el.innerHTML = `<div class="inspector-empty">
      <svg viewBox="0 0 32 32" fill="none" stroke="currentColor" stroke-width="1"><circle cx="16" cy="16" r="12"/><path d="M16 10v6M16 20v1"/></svg>
      Click a component or connection on the canvas to inspect it.
    </div>`;
    return;
  }
  const c = components[state.selectedNode];
  const cat = CATEGORIES[c.category];
  const v = c.variants[c.currentVariant];
  const alts = ALTERNATIVES[state.selectedNode] || [];
  const variantKeys = Object.keys(c.variants);
  const currentMetrics = v.metrics;
  const rec = getVariantRecommendation(state.selectedNode);

  // Build swap dropdown items with metric diffs
  const swapDropdownHTML = alts.length > 1 ? `<div class="insp-header-dropdown swap ${state.inspSwapOpen ? 'visible' : ''}">
    ${alts.map(a => {
      const isCurrent = a.id === state.selectedNode;
      const altComp = components[a.id];
      const altMetrics = altComp ? altComp.variants[altComp.currentVariant].metrics : {};
      const metricDiffs = !isCurrent ? Object.entries(currentMetrics).map(([mk, mv]) => {
        const altVal = altMetrics[mk];
        if (altVal === undefined || state.hiddenMetrics.has(mk)) return '';
        const diff = altVal - mv;
        if (diff === 0) return '';
        const mi = METRIC_ICON_MAP[mk] ? icon(METRIC_ICON_MAP[mk], diff > 0 ? 'var(--green)' : 'var(--red)') : '';
        return `<span class="insp-dd-metric ${diff > 0 ? 'positive' : 'negative'}">${mi}${diff > 0 ? '+' : ''}${diff}</span>`;
      }).filter(Boolean).join('') : '';
      return `<div class="insp-dd-item ${isCurrent ? 'current' : ''}" onclick="inspSwapComponent('${a.id}', event)">
        <div class="insp-dd-item-header">
          ${icon(c.category, cat.color)} ${a.name}
          <span class="insp-dd-item-sub">${a.sub}</span>
          ${isCurrent ? '<span class="insp-dd-item-current">Current</span>' : ''}
        </div>
        ${metricDiffs ? `<div class="insp-dd-metrics">${metricDiffs}</div>` : ''}
      </div>`;
    }).join('')}
  </div>` : '';

  // Build variant dropdown items with metric change previews
  const variantDropdownHTML = variantKeys.length > 1 ? `<div class="insp-header-dropdown variant ${state.inspVariantOpen ? 'visible' : ''}">
    ${variantKeys.map(vk => {
      const vv = c.variants[vk];
      const isCurrent = vk === c.currentVariant;
      const metricDiffs = !isCurrent ? Object.entries(vv.metrics).map(([mk, mv]) => {
        const diff = mv - currentMetrics[mk];
        if (diff === 0 || state.hiddenMetrics.has(mk)) return '';
        const mi = METRIC_ICON_MAP[mk] ? icon(METRIC_ICON_MAP[mk], diff > 0 ? 'var(--green)' : 'var(--red)') : '';
        return `<span class="insp-dd-metric ${diff > 0 ? 'positive' : 'negative'}">${mi}${diff > 0 ? '+' : ''}${diff}</span>`;
      }).filter(Boolean).join('') : '';
      return `<div class="insp-dd-item ${isCurrent ? 'current' : ''}" onclick="inspChangeVariant('${vk}', event)">
        <div class="insp-dd-item-header">
          ${VARIANT_ICON} ${vv.label}
          ${isCurrent ? '<span class="insp-dd-item-current">Current</span>' : ''}
        </div>
        ${metricDiffs ? `<div class="insp-dd-metrics">${metricDiffs}</div>` : ''}
      </div>`;
    }).join('')}
    ${rec ? `<div class="insp-dd-rec">${icon('gain', 'var(--accent)')} Try <strong>${rec.label}</strong> for <span class="delta-positive" style="margin-left:2px">+${rec.improvement} ${rec.metric}</span></div>` : ''}
  </div>` : '';
  const allMetricEntries = Object.entries(v.metrics);
  const visibleCount = allMetricEntries.filter(([name]) => !state.hiddenMetrics.has(name)).length;
  const checkSvg = '<svg viewBox="0 0 10 10" fill="none" stroke="white" stroke-width="2"><path d="M2 5l2 2 4-4"/></svg>';
  const filterMenuItems = allMetricEntries.map(([name, val]) => {
    const isVisible = !state.hiddenMetrics.has(name);
    const mi = METRIC_ICON_MAP[name] ? icon(METRIC_ICON_MAP[name], 'var(--text-secondary)') : '';
    return `<div class="metric-filter-item ${isVisible ? 'checked' : ''}" onclick="toggleMetricVisibility('${name}', event)">
      <div class="metric-filter-check">${isVisible ? checkSvg : ''}</div>
      <span class="metric-filter-name">${mi} ${name}</span>
      <span class="metric-filter-val" style="color:${getMetricColor(val)}">${val}</span>
    </div>`;
  }).join('');
  const filterMenu = `<div class="metric-filter-menu ${state.metricFilterOpen ? 'visible' : ''}">
    <div class="metric-filter-actions">
      <button class="metric-filter-action" onclick="setAllMetrics(true, event)">All</button>
      <button class="metric-filter-action" onclick="setAllMetrics(false, event)">None</button>
    </div>
    ${filterMenuItems}
  </div>`;
  const filterBtnLabel = visibleCount < allMetricEntries.length ? `${visibleCount}/${allMetricEntries.length}` : '';
  const filterBtn = `<div class="metric-filter-wrap">
    <button class="metric-filter-btn ${state.metricFilterOpen ? 'active' : ''}" onclick="toggleMetricFilter(event)" title="Choose which metrics to show">
      ${icon('filter', 'currentColor')} ${filterBtnLabel}
    </button>
    ${filterMenu}
  </div>`;

  const metricBars = allMetricEntries.filter(([name]) => !state.hiddenMetrics.has(name)).map(([name, val], idx) => {
    const metricIcon = METRIC_ICON_MAP[name] ? icon(METRIC_ICON_MAP[name], 'var(--text-secondary)') : '';
    const delta = state.lastDeltas[name];
    const deltaHTML = delta ? ` <span class="metric-delta ${delta > 0 ? 'positive' : delta < 0 ? 'negative' : 'neutral'}">${delta > 0 ? '+' : ''}${delta}</span>` : '';
    const explData = METRIC_EXPLANATIONS[state.selectedNode] && METRIC_EXPLANATIONS[state.selectedNode][c.currentVariant] && METRIC_EXPLANATIONS[state.selectedNode][c.currentVariant][name];
    const explId = `mexpl-${idx}`;
    const infoBtn = explData ? `<button class="metric-info-btn" onclick="toggleMetricExplanation('${explId}', event)" title="Why this score?">${icon('info', 'currentColor')}</button>` : '';
    const explPanel = explData ? `<div class="metric-explanation" id="${explId}"><div class="metric-expl-reason">${explData.reason}</div><ul class="metric-expl-factors">${explData.factors.map(f => `<li>${f}</li>`).join('')}</ul></div>` : '';
    return `<div class="metric-row-wrap">
      <div class="metric-row">
        <div class="metric-label"><span class="metric-name">${metricIcon} ${name}</span><span class="metric-value" style="color:${getMetricColor(val)}">${val}${deltaHTML}</span>${infoBtn}</div>
        <div class="metric-bar-track"><div class="metric-bar-fill" style="width:${val}%;background:${getMetricColor(val)}"></div><div class="metric-threshold" style="left:70%" title="Healthy threshold"></div></div>
      </div>
      ${explPanel}
    </div>`;
  }).join('');
  const metricsEmpty = visibleCount === 0 ? '<div style="font-size:11px;color:var(--text-secondary);padding:8px 0;text-align:center;">No metrics selected. Click the filter to add metrics.</div>' : '';

  const codePattern = CODE_PATTERNS[state.selectedNode] && CODE_PATTERNS[state.selectedNode][c.currentVariant];

  // Auto-open metrics for components with issues
  if (c.heatStatus !== 'green') {
    state.collapsedSections.delete('insp-metrics');
  }

  el.innerHTML = `
    <div class="insp-header">
      <div class="insp-header-btn insp-swap-btn ${state.inspSwapOpen ? 'active' : ''}" ${alts.length > 1 ? 'onclick="toggleInspSwap(event)"' : 'style="cursor:default;opacity:0.6"'} title="${alts.length > 1 ? 'Swap component' : c.category}">${icon(c.category, cat.color)}</div>
      <div class="insp-header-center">
        <div class="insp-name">${c.name}</div>
        <div class="insp-variant-label">${v.label}</div>
      </div>
      ${variantKeys.length > 1 ? `<div class="insp-header-btn insp-variant-btn ${state.inspVariantOpen ? 'active' : ''}" onclick="toggleInspVariant(event)" title="Change configuration variant">${VARIANT_ICON}</div>` : ''}
    </div>
    <div class="insp-category"><div class="insp-cat-dot" style="background:${cat.color}"></div>${c.category}</div>
    ${swapDropdownHTML}
    ${variantDropdownHTML}
    <div class="insp-section">
      <div class="insp-section-title collapsible" data-toggle="insp-metrics" onclick="toggleSection('insp-metrics')">
        <span class="metric-section-title-row">
          ${icon('metrics', 'var(--text-secondary)')} Metrics
          <span onclick="event.stopPropagation()">${filterBtn}</span>
        </span>
        <span class="section-chevron ${state.collapsedSections.has('insp-metrics') ? '' : 'open'}">${icon('chevron', 'var(--text-secondary)')}</span>
      </div>
      <div class="insp-section-body ${state.collapsedSections.has('insp-metrics') ? 'collapsed' : ''}" id="insp-metrics">${metricsEmpty}${metricBars}</div>
    </div>
    ${collapsible('insp-tradeoffs', 'cons', 'var(--text-secondary)', 'Pros & Cons',
      `<div class="pros-cons">${v.pros.map(p => `<div class="pro">${p}</div>`).join('')}${v.cons.map(cc => `<div class="con">${cc}</div>`).join('')}</div>`)}
    ${c.dataContext ? collapsible('insp-data', 'data_ctx', 'var(--accent)', 'Your Data Context',
      c.dataContext.map(item => {
        const behavior = item.behaviors[c.currentVariant];
        if (!behavior) return '';
        return `<div class="data-item fit-${behavior.fit}">
          <div class="data-item-header">
            ${icon(item.icon, 'var(--text-secondary)')}
            ${item.name}
            <span class="fit-badge ${behavior.fit}">${behavior.fit === 'tradeoff' ? 'trade-off' : behavior.fit}</span>
          </div>
          <div class="data-item-note">${behavior.note}</div>
        </div>`;
      }).join('')) : ''}
    ${codePattern ? collapsible('insp-code', 'code', 'var(--text-secondary)', 'Implementation Pattern',
      `<div class="code-pattern">${codePattern}</div>`) : ''}
  `;
}

function renderDashboard() {
  // Compact bottom bar
  const el = document.getElementById('dashboardBars');
  const { scores, breakdown } = calculateDashboardScores();
  el.innerHTML = dashboardCategories.map(cat => {
    const val = scores[cat.key];
    return `<div class="dash-bar-group">
      <div class="dash-bar-track clickable" onclick="highlightForDashboard('${cat.key}')"><div class="dash-bar-fill" style="width:${val}%;background:${getMetricColor(val)}">
        <span class="dash-bar-value">${val}</span>
      </div></div>
      <div class="dash-bar-label">${icon(cat.icon, 'var(--text-secondary)')} ${cat.name}</div>
    </div>`;
  }).join('');

  // Overlay grid (always update so it's ready when toggled)
  const overlayGrid = document.getElementById('dashOverlayGrid');
  overlayGrid.innerHTML = dashboardCategories.map(cat => {
    const val = scores[cat.key];
    const factors = breakdown[cat.key] || [];
    const info = DASHBOARD_INFO[cat.key];
    const catFullName = info ? info.name : cat.name;
    return `<div class="dash-card">
      <div class="dash-card-header">
        ${icon(cat.icon, getMetricColor(val))} ${catFullName}
        <span class="dash-card-score" style="color:${getMetricColor(val)}">${val}</span>
      </div>
      <div class="dash-card-bar"><div class="dash-card-fill" style="width:${val}%;background:${getMetricColor(val)}"></div></div>
      ${info ? `<div class="dash-card-desc">${info.desc}</div>` : ''}
      <div class="dash-card-factors">
        ${factors.map(f => {
          const mi = METRIC_ICON_MAP[f.metric] ? icon(METRIC_ICON_MAP[f.metric], getMetricColor(f.value)) : '';
          return `<div class="dash-card-factor">
            <span class="dash-card-factor-tip">${f.comp} — ${f.metric}: ${f.value}</span>
            <span class="dash-card-factor-comp">${f.comp}</span>
            <span class="dash-card-factor-icon">${mi}</span>
            <span class="dash-card-factor-bar"><span class="dash-card-factor-fill" style="width:${f.value}%;background:${getMetricColor(f.value)}"></span></span>
            <span class="dash-card-factor-val" style="color:${getMetricColor(f.value)}">${f.value}</span>
          </div>`;
        }).join('')}
      </div>
    </div>`;
  }).join('');

  // Sync overlay visibility
  document.getElementById('dashOverlay').classList.toggle('visible', state.dashboardExpanded);
  document.getElementById('dashboard').classList.toggle('expanded', state.dashboardExpanded);
}

function toggleDashboardExpand() {
  state.dashboardExpanded = !state.dashboardExpanded;
  document.getElementById('dashOverlay').classList.toggle('visible', state.dashboardExpanded);
  document.getElementById('dashboard').classList.toggle('expanded', state.dashboardExpanded);
  if (state.dashboardExpanded) renderDashboard(); // refresh overlay content
}

function calculateDashboardScores() {
  // Build breakdown: for each category, collect { comp, metric, value } entries
  const breakdown = {};
  dashboardCategories.forEach(cat => { breakdown[cat.key] = []; });

  Object.entries(components).forEach(([id, c]) => {
    const v = c.variants[c.currentVariant];
    Object.entries(v.metrics).forEach(([metricName, value]) => {
      const catKey = METRIC_TO_CATEGORY[metricName];
      if (catKey && breakdown[catKey]) {
        breakdown[catKey].push({ comp: c.name, metric: metricName, value });
      }
    });
  });

  // Score per category = average of all contributing metric values
  const scores = {};
  dashboardCategories.forEach(cat => {
    const factors = breakdown[cat.key];
    if (factors.length > 0) {
      scores[cat.key] = Math.round(factors.reduce((sum, f) => sum + f.value, 0) / factors.length);
    } else {
      scores[cat.key] = 50; // default if no data
    }
  });

  return { scores, breakdown };
}

// ═══════════════ INTERACTIONS ═══════════════

function selectNode(id) {
  if (state.selectedNode !== id) state.lastDeltas = {}; // clear deltas when switching components
  state.inspSwapOpen = false;
  state.inspVariantOpen = false;
  state.selectedNode = id;
  state.selectedConnection = null; // deselect connection when selecting node
  renderNodes();
  renderConnections();
  renderInspector();
  updatePrompt();
}

// ═══════════════ DRAG & DROP ═══════════════

function startDrag(e, nodeId) {
  // Ignore if clicking on interactive children (icon swap, variant btn, dropdowns, select)
  if (e.target.closest('.node-variant-btn') || e.target.closest('.node-dropdown') || e.target.closest('.swap-dropdown') || e.target.closest('.node-icon.clickable') || e.target.closest('select')) return;
  e.preventDefault();
  const c = components[nodeId];
  state.dragging = nodeId;
  state.dragMoved = false;
  state.dragStart = { mx: e.clientX, my: e.clientY, nx: c.position.x, ny: c.position.y };
}

function onDrag(e) {
  if (!state.dragging) return;
  const dx = e.clientX - state.dragStart.mx;
  const dy = e.clientY - state.dragStart.my;
  // Only count as drag if moved more than 4px (to allow click)
  if (Math.abs(dx) > 4 || Math.abs(dy) > 4) state.dragMoved = true;
  if (!state.dragMoved) return;
  const c = components[state.dragging];
  c.position.x = state.dragStart.nx + dx;
  c.position.y = state.dragStart.ny + dy;
  // Move the DOM element directly for performance (no full re-render)
  const nodeEl = document.getElementById(`node-${state.dragging}`);
  if (nodeEl) {
    nodeEl.style.left = c.position.x + 'px';
    nodeEl.style.top = c.position.y + 'px';
    nodeEl.classList.add('dragging');
  }
  // Update connection lines
  renderConnections();
}

function endDrag(e) {
  if (!state.dragging) return;
  const nodeId = state.dragging;
  const nodeEl = document.getElementById(`node-${nodeId}`);
  if (nodeEl) nodeEl.classList.remove('dragging');
  state.dragging = null;
  if (!state.dragMoved) {
    // It was a click, not a drag — select the node
    selectNode(nodeId);
  }
  state.dragStart = null;
  state.dragMoved = false;
}

// ═══════════════ CONNECTION LABEL DRAG ═══════════════

function startConnDrag(e, sourceId, targetId, connIdx) {
  e.preventDefault();
  const conn = components[sourceId].connections[connIdx];
  if (!conn.offset) conn.offset = { x: 0, y: 0 };
  state.draggingConn = { sourceId, targetId, connIdx };
  state.connDragStart = { mx: e.clientX, my: e.clientY, ox: conn.offset.x, oy: conn.offset.y };
  state.dragMoved = false;
}

function onConnDrag(e) {
  if (!state.draggingConn) return;
  const dx = e.clientX - state.connDragStart.mx;
  const dy = e.clientY - state.connDragStart.my;
  if (Math.abs(dx) > 3 || Math.abs(dy) > 3) state.dragMoved = true;
  if (!state.dragMoved) return;
  const { sourceId, connIdx } = state.draggingConn;
  const conn = components[sourceId].connections[connIdx];
  conn.offset.x = state.connDragStart.ox + dx;
  conn.offset.y = state.connDragStart.oy + dy;
  renderConnections();
}

function endConnDrag(e) {
  if (!state.draggingConn) return;
  const wasDrag = state.dragMoved;
  const { sourceId, targetId } = state.draggingConn;
  state.draggingConn = null;
  state.connDragStart = null;
  if (!wasDrag) {
    // It was a click, not a drag — select the connection
    selectConnection(sourceId, targetId);
  }
  state.dragMoved = false;
}

// Combined mouse handlers for both node and connection dragging
document.addEventListener('mousemove', function(e) { onDrag(e); onConnDrag(e); });
document.addEventListener('mouseup', function(e) { endDrag(e); endConnDrag(e); });

function changeVariant(nodeId, variantKey) {
  const c = components[nodeId];
  // Store previous metrics for delta display
  const prevMetrics = { ...c.variants[c.currentVariant].metrics };
  c.currentVariant = variantKey;

  // Calculate deltas for display
  const newMetrics = c.variants[variantKey].metrics;
  state.lastDeltas = {};
  Object.entries(newMetrics).forEach(([key, val]) => {
    if (prevMetrics[key] !== undefined) state.lastDeltas[key] = val - prevMetrics[key];
  });
  // Deltas persist until the next variant change (cleared at top of this function)

  // Update heatmap status based on new metrics
  const v = c.variants[variantKey];
  const avg = Object.values(v.metrics).reduce((a,b) => a+b, 0) / Object.values(v.metrics).length;
  c.heatStatus = avg >= 70 ? 'green' : avg >= 50 ? 'yellow' : 'red';

  // Immediate update on source
  renderInspector();
  renderNodes();
  renderConnections();

  // Sequential ripple through connections
  triggerRipple(nodeId);

  // Dashboard updates after ripple
  setTimeout(() => renderDashboard(), 300 + c.connections.length * 150);
  restartFlowIfActive();
  renderIssuesButton();
  updatePrompt();
}

function triggerRipple(sourceId) {
  const c = components[sourceId];
  const sourceNode = document.getElementById(`node-${sourceId}`);
  if (sourceNode) { sourceNode.classList.add('rippling'); setTimeout(() => sourceNode.classList.remove('rippling'), 400); }

  c.connections.forEach((conn, i) => {
    const targetId = conn.target;
    setTimeout(() => {
      // Flash the connection line
      const line = document.getElementById(`conn-${sourceId}-${targetId}`);
      if (line) { line.classList.add('ripple'); setTimeout(() => line.classList.remove('ripple'), 300); }

      // Ripple the target node
      const targetNode = document.getElementById(`node-${targetId}`);
      if (targetNode) {
        targetNode.classList.add('rippling');
        setTimeout(() => targetNode.classList.remove('rippling'), 400);
      }

      renderNodes();
      renderConnections();
      if (i === c.connections.length - 1) restartFlowIfActive();
    }, (i + 1) * 150);
  });
}

function toggleHeatmap() {
  state.heatmapEnabled = !state.heatmapEnabled;
  document.getElementById('heatmapToggle').classList.toggle('active', state.heatmapEnabled);
  renderNodes();
  renderConnections();
  renderLegend();
  if (state.heatmapEnabled) {
    startFlowAnimation();
  } else {
    stopFlowAnimation();
  }
  updatePrompt();
}

function togglePanel(panelId) {
  document.getElementById(panelId).classList.toggle('collapsed');
}

function switchTab(tabEl, tabName) {
  document.querySelectorAll('.toolbox-tab').forEach(t => t.classList.remove('active'));
  tabEl.classList.add('active');
  state.toolboxTab = tabName;
  renderToolbox();
}

// ═══════════════ CONNECTION SELECTION ═══════════════

function selectConnection(sourceId, targetId) {
  // Toggle selection
  if (state.selectedConnection &&
      state.selectedConnection.sourceId === sourceId &&
      state.selectedConnection.targetId === targetId) {
    state.selectedConnection = null;
  } else {
    state.selectedConnection = { sourceId, targetId };
    state.selectedNode = null; // deselect node when selecting connection
  }
  renderNodes();
  renderConnections();
  renderInspector();
  updatePrompt();
}

function getConnectionData(sourceId, targetId) {
  const c = components[sourceId];
  if (!c) return null;
  return c.connections.find(conn => conn.target === targetId) || null;
}

// ═══════════════ COMPONENT SWAP ═══════════════

function toggleSwapDropdown(nodeId) {
  state.variantOpenNode = null;
  state.swapOpenNode = state.swapOpenNode === nodeId ? null : nodeId;
  renderNodes();
  renderConnections();
}

function toggleVariantDropdown(nodeId) {
  state.swapOpenNode = null;
  state.variantOpenNode = state.variantOpenNode === nodeId ? null : nodeId;
  renderNodes();
  renderConnections();
}

function changeVariantFromNode(nodeId, variantKey) {
  state.variantOpenNode = null;
  changeVariant(nodeId, variantKey);
}

function swapComponent(currentId, newId) {
  if (currentId === newId) {
    state.swapOpenNode = null;
    renderNodes();
    renderConnections();
    return;
  }
  // In a real app this would replace the component entirely.
  // For this playground, show feedback that it would swap.
  const alt = (ALTERNATIVES[currentId] || []).find(a => a.id === newId);
  const node = document.getElementById(`node-${currentId}`);
  if (node) {
    node.style.transition = 'transform 0.2s, opacity 0.2s';
    node.style.transform = 'scale(0.9)';
    node.style.opacity = '0.5';
    setTimeout(() => {
      node.style.transform = 'scale(1)';
      node.style.opacity = '1';
    }, 200);
  }
  state.swapOpenNode = null;
  // Update the prompt to reflect the swap intention
  if (alt) {
    const c = components[currentId];
    c._swapTarget = alt;
  }
  renderNodes();
  renderConnections();
  renderInspector();
  updatePrompt();
}

// Close swap/variant dropdown on click outside
document.addEventListener('click', function(e) {
  if (state.swapOpenNode && !e.target.closest('.node-icon.clickable') && !e.target.closest('.node-dropdown') && !e.target.closest('.swap-dropdown')) {
    state.swapOpenNode = null;
    renderNodes();
    renderConnections();
  }
  if (state.variantOpenNode && !e.target.closest('.node-variant-btn') && !e.target.closest('.node-dropdown')) {
    state.variantOpenNode = null;
    renderNodes();
    renderConnections();
  }
  if (state.issuesOpen && !e.target.closest('#issuesBtn') && !e.target.closest('#issuesDropdown')) {
    state.issuesOpen = false;
    document.getElementById('issuesDropdown').classList.remove('visible');
  }
  if (state.metricFilterOpen && !e.target.closest('.metric-filter-wrap') && !e.target.closest('.metric-filter-menu')) {
    state.metricFilterOpen = false;
    const menu = document.querySelector('.metric-filter-menu');
    if (menu) menu.classList.remove('visible');
  }
  if (state.inspSwapOpen && !e.target.closest('.insp-swap-btn') && !e.target.closest('.insp-header-dropdown.swap')) {
    state.inspSwapOpen = false;
    renderInspector();
  }
  if (state.inspVariantOpen && !e.target.closest('.insp-variant-btn') && !e.target.closest('.insp-header-dropdown.variant')) {
    state.inspVariantOpen = false;
    renderInspector();
  }
});

// ═══════════════ PROMPT OUTPUT ═══════════════

function updatePrompt() {
  const el = document.getElementById('promptText');
  const parts = [];
  parts.push('Build the Archie architecture simulator interface with these specifications:');
  parts.push('');
  parts.push('LAYOUT: VS Code three-zone pattern — Toolbox sidebar (left, 270px), Canvas (center, dark bg #0f1117), Inspector panel (right, 310px). Dashboard bar at bottom (110px). Top bar with logo, architecture name, tier badge, and icon+label action buttons.');
  parts.push('');
  parts.push('THEME: Dark mode primary. Panel bg: #1a1d27, Surface: #242736, Border: #2e3348, Text: #e2e4eb / #8b8fa3, Accent: #6366f1 (indigo). Font: Inter, 13px base. 4px spacing unit.');
  parts.push('');
  parts.push('ICONOGRAPHY: Every category, action, metric, and label has an SVG icon. Icons are the primary visual communication — users identify component types by icon before text. 10 category icons: CPU (compute), Database cylinder (data storage), Lightning bolt (caching), Chat bubble (messaging), Globe (delivery/network), Signal waves (real-time), Shield (auth), Chart (monitoring), Magnifying glass (search), Gear (devops). Icons appear in nodes, toolbox cards, inspector, dashboard labels, tabs, and buttons.');
  parts.push('');
  parts.push('NODE SHAPES: Each component category has a distinct node shape: Compute = sharp rectangle (4px radius), Data Storage = bottom-rounded cylinder shape (4px top, 14px bottom radius), Caching = pill (16px radius), Messaging = alternating corners (12px/4px), Delivery = stadium (20px radius). Nodes show: category color top stripe, category icon + name, variant label, mini metric bars.');
  parts.push('');
  parts.push('COLOR SYSTEM: Two separate color layers — category colors (10 distinct hues) identify component TYPE via accent stripes and icon fills. Heatmap colors (green/yellow/red) show HEALTH status on borders and connection lines when heatmap is enabled. These never overlap — category = identity, heatmap = performance.');
  parts.push('');

  if (state.heatmapEnabled) {
    parts.push('HEATMAP: Enabled — node borders glow with health colors (green/yellow/red). Connection LINES also colored by health (worst of two endpoints). Dashed lines for warning/bottleneck connections. Legend visible in top-right corner of canvas.');
    parts.push('');
  }

  if (state.selectedNode) {
    const c = components[state.selectedNode];
    const v = c.variants[c.currentVariant];
    parts.push(`CURRENT SELECTION: ${c.name} (${c.category}) with "${v.label}" config variant.`);
    parts.push(`Metrics: ${Object.entries(v.metrics).map(([k,val]) => `${k}: ${val}/100`).join(', ')}`);
    parts.push('');
  }

  parts.push('CORE INTERACTION: Config variant dropdown in inspector. On change → metric bars animate (0.5s cubic-bezier), sequential ripple propagates through connections (~150ms per hop), heatmap colors shift on nodes AND lines, dashboard updates after ripple completes.');
  parts.push('');
  parts.push('TOOLBOX: Three tabs with icons (grid=Components | stack=Stacks | blueprint=Blueprints). Component cards in IS/GAIN/COST format with category icon + color left border. Section labels have micro-icons (circle=IS, up-arrow=GAIN, down-arrow=COST).');
  parts.push('');
  parts.push('DASHBOARD: 7 horizontal bars with category icons (rocket=Perf, dollar=Cost, shield=Reliab, gear=Ops, mountain=Scale, flag=Strat, code=Dev). Color-coded: green >70, yellow 40-70, red <40.');
  parts.push('');
  parts.push('DATA CONTEXT: Each component has user-defined data items (e.g., Redis: "User Sessions", "Rate Limits", "Message Cache"). When switching config variants, a "Your Data Context" section in the inspector shows how each data item behaves under that variant with fit indicators (great/good/trade-off/poor/risky) and specific notes. This makes abstract metrics concrete: "Your sessions are read-heavy → Cache-Aside is a great fit" vs "Your rate limit counters are write-heavy → Cache-Aside is a poor fit." Users can edit their data items to personalize the trade-off analysis.');
  parts.push('');
  parts.push('COMPONENT SWAP: Each node shows a swap button (arrows icon) on hover in the top-right corner. Clicking opens a dropdown with alternative components in the same category (e.g., Redis → Memcached, KeyDB, Dragonfly). The inspector also shows a "Swap to" dropdown below the component name. This enables quick comparison of alternative tools without rebuilding the architecture.');
  parts.push('');
  parts.push('IMPLEMENTATION PATTERNS: Below the config variant dropdown in the inspector, a code snippet panel shows the actual implementation pattern for the current variant. Syntax-highlighted (keywords purple, functions blue, strings green, comments gray). This makes the difference between variants tangible — users see HOW the code changes, not just abstract metric scores.');
  parts.push('');
  parts.push('CONNECTIONS AS FIRST-CLASS OBJECTS: Connections between components are not just lines — they have properties. Each connection specifies: protocol (HTTP, RESP, Kafka TCP, PostgreSQL Wire, etc.), communication pattern (request-response, pub-sub, poll-consume, fire-and-forget), typical latency, whether components can be co-located on the same machine, and implementation code showing HOW the connection works. Click any connection label on the canvas to inspect its properties. Connections show directional arrows. The Sysops Squad architecture has service-oriented flows: API Gateway→Services routes, Services→Database persists, Event Bus→Notification Service triggers alerts.');

  if (state.selectedConnection) {
    const conn = getConnectionData(state.selectedConnection.sourceId, state.selectedConnection.targetId);
    if (conn) {
      const src = components[state.selectedConnection.sourceId];
      const tgt = components[state.selectedConnection.targetId];
      parts.push('');
      parts.push(`SELECTED CONNECTION: ${src.name} → ${tgt.name} via ${conn.protocol}. Pattern: ${conn.pattern}. Latency: ${conn.latency}. Co-locatable: ${conn.colocatable ? 'Yes' : 'No'}.`);
    }
  }

  el.textContent = parts.join('\n');
}

function copyPrompt() {
  const text = document.getElementById('promptText').textContent;
  navigator.clipboard.writeText(text).then(() => {
    const btn = document.querySelector('.prompt-copy-btn');
    const original = btn.innerHTML;
    btn.innerHTML = '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 6l3 3 5-5"/></svg> Copied!';
    setTimeout(() => btn.innerHTML = original, 1500);
  });
}

// ═══════════════ INFO POPUPS ═══════════════

function showInfoPopup(headerHTML, bodyHTML) {
  const overlay = document.getElementById('infoPopupOverlay');
  document.getElementById('infoPopupHeader').innerHTML = headerHTML + `<button class="info-popup-close" onclick="hideInfoPopup()">${icon('close', 'var(--text-secondary)')}</button>`;
  document.getElementById('infoPopupBody').innerHTML = bodyHTML;
  overlay.classList.add('visible');
}

function hideInfoPopup() {
  document.getElementById('infoPopupOverlay').classList.remove('visible');
}

function showCategoryInfo(categoryName) {
  const info = CATEGORY_INFO[categoryName];
  if (!info) return;
  const cat = CATEGORIES[categoryName];
  const headerHTML = `${icon(categoryName, cat.color)} <span style="color:${cat.color}">${categoryName}</span>`;
  const bodyHTML = `
    <p><strong>${info.desc}</strong></p>
    <div class="info-popup-section">
      <div class="info-popup-section-title">Role in Architecture</div>
      <p>${info.role}</p>
    </div>
    <div class="info-popup-section">
      <div class="info-popup-section-title">Common Examples</div>
      <p>${info.examples}</p>
    </div>
    <div class="info-popup-section">
      <div class="info-popup-section-title">How to Choose</div>
      <p>${info.key}</p>
    </div>
  `;
  showInfoPopup(headerHTML, bodyHTML);
}

function showDashboardInfo(categoryKey) {
  const info = DASHBOARD_INFO[categoryKey];
  if (!info) return;
  const dashCat = dashboardCategories.find(c => c.key === categoryKey);
  const headerHTML = `${dashCat ? icon(dashCat.icon, 'var(--accent)') : ''} <span style="color:var(--accent)">${info.name}</span>`;
  const bodyHTML = `
    <p><strong>${info.desc}</strong></p>
    <div class="info-popup-section">
      <div class="info-popup-section-title">Key Metrics</div>
      <p>${info.metrics}</p>
    </div>
    <div class="info-popup-section">
      <div class="info-popup-section-title">Why It Matters</div>
      <p>${info.impact}</p>
    </div>
    <div class="info-popup-section">
      <div class="info-popup-section-title">How to Improve</div>
      <p>${info.improve}</p>
    </div>
  `;
  showInfoPopup(headerHTML, bodyHTML);
}

// Close popup on Escape key
document.addEventListener('keydown', function(e) {
  if (e.key === 'Escape') {
    hideInfoPopup();
    if (state.issuesOpen) { state.issuesOpen = false; document.getElementById('issuesDropdown').classList.remove('visible'); }
    if (state.swapOpenNode || state.variantOpenNode) { state.swapOpenNode = null; state.variantOpenNode = null; renderNodes(); renderConnections(); }
  }
});

// ═══════════════ ISSUES SUMMARY ═══════════════

function getIssues() {
  const issues = [];
  Object.entries(components).forEach(([id, c]) => {
    if (c.heatStatus !== 'green') {
      const v = c.variants[c.currentVariant];
      const avg = Math.round(Object.values(v.metrics).reduce((a,b) => a+b, 0) / Object.values(v.metrics).length);
      const worst = Object.entries(v.metrics).sort((a,b) => a[1] - b[1])[0];
      issues.push({ id, name: c.name, category: c.category, status: c.heatStatus, avg, worstMetric: worst[0], worstValue: worst[1] });
    }
  });
  const priority = { 'red': 0, 'yellow': 1 };
  issues.sort((a, b) => (priority[a.status] ?? 2) - (priority[b.status] ?? 2) || a.avg - b.avg);
  return issues;
}

function renderIssuesButton() {
  const issues = getIssues();
  const badge = document.getElementById('issuesBadge');
  if (issues.length === 0) {
    badge.classList.add('hidden');
  } else {
    badge.classList.remove('hidden');
    badge.textContent = issues.length;
    badge.className = 'issues-badge' + (issues.some(i => i.status === 'red') ? '' : ' warning');
  }
}

function toggleIssues() {
  state.issuesOpen = !state.issuesOpen;
  const dropdown = document.getElementById('issuesDropdown');
  const btn = document.getElementById('issuesBtn');
  if (state.issuesOpen) {
    const rect = btn.getBoundingClientRect();
    dropdown.style.top = (rect.bottom + 4) + 'px';
    dropdown.style.left = Math.max(8, rect.left - 80) + 'px';
    const issues = getIssues();
    if (issues.length === 0) {
      dropdown.innerHTML = `<div class="issues-dropdown-title">${icon('gain', 'var(--green)')} Architecture Health</div>
        <div class="issues-none">All components healthy — no issues detected</div>`;
    } else {
      dropdown.innerHTML = `<div class="issues-dropdown-title">${icon('cons', 'var(--red)')} ${issues.length} Issue${issues.length > 1 ? 's' : ''} Detected</div>
        ${issues.map(i => {
          const cat = CATEGORIES[i.category];
          const h = HEALTH_LABELS[i.status];
          return `<div class="issues-item" onclick="selectNode('${i.id}'); toggleIssues();">
            <span class="issues-item-dot" style="background:${h.color}"></span>
            ${icon(i.category, cat.color)}
            <span class="issues-item-name">${i.name}</span>
            <span class="issues-item-detail">${h.label} · worst: ${i.worstMetric} ${i.worstValue}</span>
          </div>`;
        }).join('')}`;
    }
    dropdown.classList.add('visible');
  } else {
    dropdown.classList.remove('visible');
  }
}

// ═══════════════ VARIANT RECOMMENDATION ═══════════════

function getVariantRecommendation(nodeId) {
  const c = components[nodeId];
  const currentMetrics = c.variants[c.currentVariant].metrics;
  const worst = Object.entries(currentMetrics).sort((a,b) => a[1] - b[1])[0];
  if (worst[1] >= 70) return null;
  let bestAlt = null;
  let bestImprovement = 0;
  Object.entries(c.variants).forEach(([vk, vv]) => {
    if (vk === c.currentVariant) return;
    const altValue = vv.metrics[worst[0]];
    if (altValue !== undefined && altValue > worst[1]) {
      const improvement = altValue - worst[1];
      if (improvement > bestImprovement) {
        bestImprovement = improvement;
        bestAlt = { key: vk, label: vv.label, metric: worst[0], from: worst[1], to: altValue, improvement };
      }
    }
  });
  if (!bestAlt) return null;
  const altMetrics = c.variants[bestAlt.key].metrics;
  let worstRegression = null;
  Object.entries(currentMetrics).forEach(([k, v]) => {
    if (k === worst[0]) return;
    const altV = altMetrics[k];
    if (altV !== undefined && altV < v) {
      const loss = v - altV;
      if (!worstRegression || loss > worstRegression.loss) worstRegression = { metric: k, loss };
    }
  });
  bestAlt.tradeoff = worstRegression;
  return bestAlt;
}

// ═══════════════ TIER INFO ═══════════════

function showTierInfo() {
  const headerHTML = `${icon('strat', 'var(--accent)')} <span style="color:var(--accent)">Architecture Tier System</span>`;
  const issues = getIssues();
  const redCount = issues.filter(i => i.status === 'red').length;
  const yellowCount = issues.filter(i => i.status === 'yellow').length;
  const bodyHTML = `
    <p><strong>Tiers measure how complete and production-ready your architecture is.</strong></p>
    <div class="info-popup-section">
      <div class="info-popup-section-title">Current: Tier 2 / 3</div>
      <p>Your architecture has core components with defined connections and configuration variants. Metrics are tracked and trade-offs are visible.</p>
    </div>
    <div class="info-popup-section">
      <div class="info-popup-section-title">Tier Criteria</div>
      <ul class="info-popup-list">
        <li><strong style="color:var(--green)">Tier 1:</strong> Components placed with basic connections defined</li>
        <li><strong style="color:var(--accent)">Tier 2 (current):</strong> Config variants selected, metrics profiled, trade-offs mapped</li>
        <li><strong style="color:var(--yellow)">Tier 3:</strong> All bottlenecks addressed, heatmap mostly green, data context personalized</li>
      </ul>
    </div>
    <div class="info-popup-section">
      <div class="info-popup-section-title">Gap to Tier 3</div>
      <ul class="info-popup-list">
        ${redCount > 0 ? `<li style="color:var(--red)">Resolve ${redCount} bottleneck${redCount > 1 ? 's' : ''} (red components)</li>` : `<li style="color:var(--green)">No bottlenecks — great!</li>`}
        ${yellowCount > 0 ? `<li style="color:var(--yellow)">Address ${yellowCount} warning${yellowCount > 1 ? 's' : ''} (yellow components)</li>` : `<li style="color:var(--green)">No warnings — great!</li>`}
        <li>Customize data context items for your specific use case</li>
        <li>Verify connection health across all paths</li>
      </ul>
    </div>
  `;
  showInfoPopup(headerHTML, bodyHTML);
}

// ═══════════════ DASHBOARD LINKING ═══════════════

function highlightForDashboard(catKey) {
  const issues = getIssues();
  if (issues.length > 0) {
    issues.forEach(issue => {
      const nodeEl = document.getElementById('node-' + issue.id);
      if (nodeEl) {
        nodeEl.classList.add('flash-highlight');
        setTimeout(() => nodeEl.classList.remove('flash-highlight'), 800);
      }
    });
  }
  showDashboardInfo(catKey);
}

// ═══════════════ FLOW PARTICLE ANIMATION ═══════════════
const FLOW_SPEEDS = { green: 0.014, yellow: 0.006, red: 0.0025 };
const FLOW_COLORS = { green: '#22c55e', yellow: '#eab308', red: '#ef4444' };

function startFlowAnimation() {
  stopFlowAnimation();
  if (connectionPathData.length === 0) return;
  state.flowParticles = [];
  connectionPathData.forEach((path, pi) => {
    const count = path.health === 'green' ? 3 : 2;
    for (let i = 0; i < count; i++) {
      state.flowParticles.push({
        pathIdx: pi,
        t: i / count + Math.random() * 0.1,
        speed: FLOW_SPEEDS[path.health] * (0.9 + Math.random() * 0.2)
      });
    }
  });
  const svg = document.getElementById('flowSvg');
  svg.innerHTML = '<defs><filter id="flowGlow"><feGaussianBlur stdDeviation="2" result="blur"/>' +
    '<feMerge><feMergeNode in="blur"/><feMergeNode in="SourceGraphic"/></feMerge></filter></defs>' +
    state.flowParticles.map((p, i) => {
      const color = FLOW_COLORS[connectionPathData[p.pathIdx].health];
      return `<circle id="fp${i}" cx="0" cy="0" r="3" fill="${color}" opacity="0.9" filter="url(#flowGlow)"/>`;
    }).join('');
  function tick() {
    if (!state.heatmapEnabled) return;
    for (let i = 0; i < state.flowParticles.length; i++) {
      const p = state.flowParticles[i];
      p.t += p.speed;
      if (p.t > 1) p.t -= 1;
      const pd = connectionPathData[p.pathIdx];
      if (!pd) continue;
      const mt = 1 - p.t;
      const x = mt * mt * pd.sx + 2 * mt * p.t * pd.cpx + p.t * p.t * pd.tx;
      const y = mt * mt * pd.sy + 2 * mt * p.t * pd.cpy + p.t * p.t * pd.ty;
      const el = document.getElementById(`fp${i}`);
      if (el) {
        el.setAttribute('cx', x);
        el.setAttribute('cy', y);
        el.setAttribute('r', 2.5 + Math.sin(p.t * Math.PI * 4) * 0.8);
      }
    }
    state.flowAnimationId = requestAnimationFrame(tick);
  }
  state.flowAnimationId = requestAnimationFrame(tick);
}

function stopFlowAnimation() {
  if (state.flowAnimationId) cancelAnimationFrame(state.flowAnimationId);
  state.flowAnimationId = null;
  state.flowParticles = [];
  const svg = document.getElementById('flowSvg');
  if (svg) svg.innerHTML = '';
}

function restartFlowIfActive() {
  if (state.heatmapEnabled) startFlowAnimation();
}

// ═══════════════ INIT ═══════════════
function init() {
  renderLegend();
  renderToolbox();
  renderNodes();
  renderConnections();
  renderDashboard();
  renderIssuesButton();
  updatePrompt();
}

init();
</script>
</body>
</html>
