<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Auction System — Archie Playground</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
<style>
/* ═══════════════ RESET & BASE ═══════════════ */
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
:root {
  --canvas-bg: #0f1117;
  --panel-bg: #1a1d27;
  --surface: #242736;
  --border: #2e3348;
  --text-primary: #e2e4eb;
  --text-secondary: #8b8fa3;
  --accent: #6366f1;
  --accent-hover: #818cf8;
  --green: #22c55e;
  --yellow: #eab308;
  --red: #ef4444;
  --cat-compute: #3b82f6;
  --cat-data: #22c55e;
  --cat-cache: #f97316;
  --cat-messaging: #a855f7;
  --cat-delivery: #06b6d4;
  --cat-realtime: #ec4899;
  --cat-auth: #ef4444;
  --cat-monitoring: #eab308;
  --cat-search: #14b8a6;
  --cat-devops: #8b5cf6;
  --radius: 6px;
  --space: 4px;
  --toolbox-w: 270px;
  --inspector-w: 310px;
  --topbar-h: 44px;
}
html, body { height: 100%; overflow: hidden; }
body {
  font-family: 'Inter', system-ui, -apple-system, sans-serif;
  background: var(--canvas-bg);
  color: var(--text-primary);
  font-size: 13px;
  line-height: 1.4;
}

/* ═══════════════ TOP BAR ═══════════════ */
.top-bar {
  height: var(--topbar-h);
  background: var(--panel-bg);
  border-bottom: 1px solid var(--border);
  display: flex;
  align-items: center;
  padding: 0 12px;
  gap: 12px;
  z-index: 100;
}
.logo {
  font-weight: 700;
  font-size: 15px;
  color: var(--accent);
  letter-spacing: -0.5px;
  display: flex;
  align-items: center;
  gap: 6px;
}
.logo svg { width: 18px; height: 18px; }
.arch-name {
  font-weight: 500;
  color: var(--text-secondary);
  flex: 1;
}
.tier-badge {
  background: var(--accent);
  color: white;
  font-size: 11px;
  font-weight: 600;
  padding: 3px 10px;
  border-radius: 12px;
  cursor: default;
  display: flex;
  align-items: center;
  gap: 4px;
}
.tier-badge svg { width: 12px; height: 12px; }
.tier-badge .tier-hint {
  font-weight: 400;
  opacity: 0.7;
  font-size: 10px;
}
.top-actions { display: flex; gap: 6px; }
.top-btn {
  background: var(--surface);
  border: 1px solid var(--border);
  color: var(--text-secondary);
  padding: 5px 10px;
  border-radius: var(--radius);
  font-size: 11px;
  font-family: inherit;
  cursor: pointer;
  transition: all 0.15s;
  display: flex;
  align-items: center;
  gap: 4px;
}
.top-btn svg { width: 14px; height: 14px; }
.top-btn:hover { color: var(--text-primary); border-color: var(--text-secondary); }
.top-btn.active { background: var(--accent); color: white; border-color: var(--accent); }

/* ═══════════════ MAIN LAYOUT ═══════════════ */
.main-layout {
  display: flex;
  height: calc(100vh - var(--topbar-h));
}

/* ═══════════════ TOOLBOX ═══════════════ */
.toolbox {
  width: var(--toolbox-w);
  min-width: var(--toolbox-w);
  background: var(--panel-bg);
  border-right: 1px solid var(--border);
  display: flex;
  flex-direction: column;
  transition: width 0.2s, min-width 0.2s, opacity 0.2s;
  overflow: hidden;
}
.toolbox.collapsed { width: 0; min-width: 0; opacity: 0; pointer-events: none; }
.toolbox-title {
  padding: 10px 12px;
  border-bottom: 1px solid var(--border);
  font-weight: 600;
  font-size: 12px;
  color: var(--text-secondary);
  text-transform: uppercase;
  letter-spacing: 0.5px;
  display: flex;
  align-items: center;
  gap: 6px;
}
.toolbox-title svg { width: 14px; height: 14px; }
.toolbox-tabs {
  display: flex;
  border-bottom: 1px solid var(--border);
}
.toolbox-tab {
  flex: 1;
  padding: 8px 4px;
  text-align: center;
  font-size: 11px;
  font-weight: 500;
  color: var(--text-secondary);
  cursor: pointer;
  border-bottom: 2px solid transparent;
  transition: all 0.15s;
  background: none;
  border-top: none;
  border-left: none;
  border-right: none;
  font-family: inherit;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 4px;
}
.toolbox-tab svg { width: 14px; height: 14px; }
.toolbox-tab:hover { color: var(--text-primary); }
.toolbox-tab.active { color: var(--accent); border-bottom-color: var(--accent); }
.toolbox-content {
  flex: 1;
  overflow-y: auto;
  padding: 8px;
}
.toolbox-content::-webkit-scrollbar { width: 4px; }
.toolbox-content::-webkit-scrollbar-track { background: transparent; }
.toolbox-content::-webkit-scrollbar-thumb { background: var(--border); border-radius: 2px; }
.component-card {
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 10px;
  margin-bottom: 8px;
  cursor: grab;
  transition: all 0.15s;
  border-left: 3px solid var(--cat-color);
}
.component-card:hover {
  border-color: var(--text-secondary);
  transform: translateY(-1px);
}
.card-header {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 6px;
}
.card-icon {
  width: 20px;
  height: 20px;
  flex-shrink: 0;
  display: flex;
  align-items: center;
  justify-content: center;
}
.card-icon svg { width: 18px; height: 18px; }
.card-name { font-weight: 600; font-size: 12px; }
.card-category { font-size: 10px; color: var(--text-secondary); display: flex; align-items: center; gap: 3px; }
.card-category svg { width: 10px; height: 10px; }
.card-section {
  font-size: 10px;
  margin-top: 4px;
  line-height: 1.5;
}
.card-section-label {
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  font-size: 9px;
  margin-bottom: 1px;
  display: flex;
  align-items: center;
  gap: 3px;
}
.card-section-label svg { width: 10px; height: 10px; }
.card-is { color: var(--text-secondary); }
.card-gain { color: var(--green); }
.card-cost { color: var(--yellow); }
/* ═══════════════ CATALOG CATEGORY GROUPS ═══════════════ */
.cat-group {
  margin-bottom: 4px;
}
.cat-group-header {
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 6px 8px;
  cursor: pointer;
  border-radius: var(--radius);
  transition: background 0.1s;
  user-select: none;
}
.cat-group-header:hover { background: var(--surface); }
.cat-group-header svg { width: 14px; height: 14px; flex-shrink: 0; }
.cat-group-name {
  font-weight: 600;
  font-size: 11px;
  flex: 1;
}
.cat-group-count {
  font-size: 9px;
  color: var(--text-secondary);
  background: var(--surface);
  padding: 1px 6px;
  border-radius: 8px;
}
.cat-group-header .section-chevron svg { width: 10px; height: 10px; }
.cat-group-body {
  padding: 0 0 4px 8px;
}
.cat-group-body.collapsed { display: none; }
.cat-group-desc {
  font-size: 10px;
  color: var(--text-secondary);
  line-height: 1.4;
  padding: 2px 8px 6px 20px;
  font-style: italic;
}
.cat-item {
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 5px 8px;
  border-radius: 4px;
  font-size: 11px;
  cursor: grab;
  transition: background 0.1s;
  position: relative;
}
.cat-item:hover { background: var(--surface); }
.cat-item-dot {
  width: 6px;
  height: 6px;
  border-radius: 50%;
  flex-shrink: 0;
}
.cat-item-name { font-weight: 500; }
.cat-item-sub { font-size: 9px; color: var(--text-secondary); margin-left: auto; }
.cat-item-active {
  font-size: 8px;
  color: var(--accent);
  font-weight: 600;
  margin-left: 4px;
}
/* Catalog item tooltip */
.cat-item-tip {
  display: none;
  position: absolute;
  left: calc(100% + 8px);
  top: 50%;
  transform: translateY(-50%);
  background: var(--panel-bg);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 8px 10px;
  font-size: 10px;
  min-width: 180px;
  z-index: 30;
  box-shadow: 0 4px 16px rgba(0,0,0,0.5);
  pointer-events: none;
  white-space: normal;
  line-height: 1.4;
}
.cat-item:hover .cat-item-tip { display: block; }
.cat-item-tip-label {
  font-size: 9px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  color: var(--text-secondary);
  margin-top: 4px;
}
.cat-item-tip-label:first-child { margin-top: 0; }
.cat-item-tip-list {
  display: flex;
  flex-wrap: wrap;
  gap: 3px;
  margin-top: 2px;
}
.cat-item-tip-tag {
  font-size: 9px;
  padding: 1px 5px;
  border-radius: 3px;
  background: var(--surface);
  border: 1px solid var(--border);
}

/* ═══════════════ CANVAS ═══════════════ */
.canvas {
  flex: 1;
  position: relative;
  background: var(--canvas-bg);
  overflow: hidden;
}
.canvas-svg {
  position: absolute;
  top: 0; left: 0;
  width: 100%; height: 100%;
  pointer-events: none;
  z-index: 1;
}
.canvas-svg .conn-label-group { pointer-events: all; cursor: grab; }
.canvas-svg .conn-label-group:active { cursor: grabbing; }
.canvas-svg .conn-path {
  stroke: var(--border);
  stroke-width: 2;
  fill: none;
  transition: stroke 0.4s, stroke-width 0.3s;
}
.canvas-svg .conn-path.heat-green { stroke: var(--green); stroke-width: 2.5; }
.canvas-svg .conn-path.heat-yellow { stroke: var(--yellow); stroke-width: 2.5; stroke-dasharray: 8 4; }
.canvas-svg .conn-path.heat-red { stroke: var(--red); stroke-width: 3; stroke-dasharray: 6 3; }
.canvas-svg .conn-path.ripple { stroke: var(--accent); stroke-width: 3; }
.canvas-svg .conn-path.conn-selected { stroke: var(--accent); stroke-width: 2.5; }

/* Canvas Legend */
.canvas-legend {
  position: absolute;
  top: 12px;
  right: 12px;
  background: var(--panel-bg);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 8px 10px;
  font-size: 10px;
  z-index: 5;
  opacity: 0.9;
  transition: opacity 0.2s;
}
.canvas-legend:hover { opacity: 1; }
.legend-title {
  font-weight: 600;
  font-size: 9px;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  color: var(--text-secondary);
  margin-bottom: 6px;
  display: flex;
  align-items: center;
  gap: 4px;
}
.legend-title svg { width: 12px; height: 12px; }
.legend-item {
  display: flex;
  align-items: center;
  gap: 6px;
  margin-bottom: 3px;
  color: var(--text-secondary);
}
.legend-item svg { width: 12px; height: 12px; }
.legend-swatch {
  width: 12px;
  height: 3px;
  border-radius: 2px;
  flex-shrink: 0;
}
.legend-dot {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  border: 2px solid;
  flex-shrink: 0;
}
.legend-divider {
  height: 1px;
  background: var(--border);
  margin: 5px 0;
}

/* Canvas Nodes */
.node {
  position: absolute;
  width: 152px;
  background: var(--surface);
  border: 2px solid var(--border);
  padding: 0;
  cursor: pointer;
  z-index: 2;
  transition: all 0.2s;
  user-select: none;
}
/* Shape variations per category */
.node[data-shape="rectangle"] { border-radius: 4px; }
.node[data-shape="cylinder"] { border-radius: 4px 4px 14px 14px; }
.node[data-shape="pill"] { border-radius: 16px; }
.node[data-shape="hexish"] { border-radius: 12px 4px 12px 4px; }
.node[data-shape="stadium"] { border-radius: 20px; }

.node:hover { border-color: var(--text-secondary); z-index: 3; }
.node.selected { border-color: var(--accent); box-shadow: 0 0 0 2px rgba(99,102,241,0.3); z-index: 4; }
.node.dragging { opacity: 0.85; z-index: 10; cursor: grabbing; box-shadow: 0 8px 32px rgba(0,0,0,0.5); transition: none; }

.node-body {
  padding: 8px 10px 10px;
  position: relative;
}
/* Variant button on node (right side) */
.node-variant-btn {
  position: absolute;
  top: 4px;
  right: 4px;
  width: 20px;
  height: 20px;
  background: var(--panel-bg);
  border: 1px solid var(--border);
  border-radius: 4px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  opacity: 0;
  transition: opacity 0.15s, background 0.15s;
  z-index: 5;
}
.node-variant-btn svg { width: 12px; height: 12px; }
.node:hover .node-variant-btn { opacity: 0.7; }
.node-variant-btn:hover { opacity: 1 !important; background: var(--accent); border-color: var(--accent); }
/* Node dropdown overlays (shared) */
.node-dropdown {
  position: absolute;
  margin-top: 4px;
  background: var(--panel-bg);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 4px;
  min-width: 160px;
  z-index: 20;
  box-shadow: 0 8px 24px rgba(0,0,0,0.4);
}
.node-dropdown.left { top: 100%; left: 0; }
.node-dropdown.right { top: 100%; right: 0; }
/* Legacy alias */
.swap-dropdown { position: absolute; top: 100%; right: 0; margin-top: 4px; background: var(--panel-bg); border: 1px solid var(--border); border-radius: var(--radius); padding: 4px; min-width: 160px; z-index: 20; box-shadow: 0 8px 24px rgba(0,0,0,0.4); }
.swap-option {
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 5px 8px;
  border-radius: 3px;
  font-size: 11px;
  cursor: pointer;
  transition: background 0.1s;
  color: var(--text-primary);
}
.swap-option:hover { background: var(--surface); }
.swap-option.current { color: var(--accent); font-weight: 600; }
.swap-option svg { width: 12px; height: 12px; }
.swap-option-sub { font-size: 9px; color: var(--text-secondary); margin-left: auto; }
.node-header {
  display: flex;
  align-items: center;
  gap: 6px;
  margin-bottom: 4px;
}
.node-icon {
  width: 20px;
  height: 20px;
  flex-shrink: 0;
  display: flex;
  align-items: center;
  justify-content: center;
}
.node-icon svg { width: 18px; height: 18px; }
.node-name { font-weight: 600; font-size: 12px; line-height: 1.2; }
.node-variant { font-size: 10px; color: var(--text-secondary); margin-left: 26px; }
.node-mini-metrics {
  display: flex;
  gap: 3px;
  margin-top: 6px;
}
.node-mini-bar {
  flex: 1;
  height: 3px;
  background: var(--border);
  border-radius: 2px;
  overflow: hidden;
}
.node-mini-fill {
  height: 100%;
  border-radius: 2px;
  transition: width 0.4s ease, background-color 0.4s ease;
}

/* Heatmap borders */
.node.heatmap-green { border-color: var(--green); box-shadow: 0 0 10px rgba(34,197,94,0.3); }
.node.heatmap-yellow { border-color: var(--yellow); box-shadow: 0 0 10px rgba(234,179,8,0.3); }
.node.heatmap-red { border-color: var(--red); box-shadow: 0 0 10px rgba(239,68,68,0.3); }
.node.selected.heatmap-green { box-shadow: 0 0 0 2px rgba(34,197,94,0.3), 0 0 10px rgba(34,197,94,0.2); }
.node.selected.heatmap-yellow { box-shadow: 0 0 0 2px rgba(234,179,8,0.3), 0 0 10px rgba(234,179,8,0.2); }
.node.selected.heatmap-red { box-shadow: 0 0 0 2px rgba(239,68,68,0.3), 0 0 10px rgba(239,68,68,0.2); }

/* Tooltip */
.node-tooltip {
  display: none;
  position: absolute;
  bottom: calc(100% + 8px);
  left: 50%;
  transform: translateX(-50%);
  background: var(--panel-bg);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 8px 10px;
  font-size: 11px;
  white-space: nowrap;
  z-index: 10;
  pointer-events: none;
  box-shadow: 0 4px 12px rgba(0,0,0,0.4);
}
.node:hover .node-tooltip { display: block; }
.tooltip-header { display: flex; align-items: center; gap: 5px; margin-bottom: 3px; }
.tooltip-header svg { width: 14px; height: 14px; }
.tooltip-metrics { display: flex; gap: 10px; margin-top: 4px; }
.tooltip-metric { color: var(--text-secondary); }
.tooltip-metric span { color: var(--text-primary); font-weight: 500; }

/* Canvas empty state hint */
.canvas-hint {
  position: absolute;
  bottom: 72px;
  left: 50%;
  transform: translateX(-50%);
  color: var(--text-secondary);
  font-size: 11px;
  opacity: 0.5;
  pointer-events: none;
  display: flex;
  align-items: center;
  gap: 6px;
}
.canvas-hint svg { width: 14px; height: 14px; }

/* ═══════════════ INSPECTOR ═══════════════ */
.inspector {
  width: var(--inspector-w);
  min-width: var(--inspector-w);
  background: var(--panel-bg);
  border-left: 1px solid var(--border);
  display: flex;
  flex-direction: column;
  transition: width 0.2s, min-width 0.2s, opacity 0.2s;
  overflow: hidden;
}
.inspector.collapsed { width: 0; min-width: 0; opacity: 0; pointer-events: none; }
.inspector-header {
  padding: 10px 12px;
  border-bottom: 1px solid var(--border);
  font-weight: 600;
  font-size: 12px;
  color: var(--text-secondary);
  text-transform: uppercase;
  letter-spacing: 0.5px;
  display: flex;
  align-items: center;
  gap: 6px;
}
.inspector-header svg { width: 14px; height: 14px; }
.inspector-content {
  flex: 1;
  overflow-y: auto;
  padding: 12px;
}
.inspector-content::-webkit-scrollbar { width: 4px; }
.inspector-content::-webkit-scrollbar-track { background: transparent; }
.inspector-content::-webkit-scrollbar-thumb { background: var(--border); border-radius: 2px; }
.inspector-empty {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 100%;
  color: var(--text-secondary);
  font-size: 12px;
  text-align: center;
  padding: 20px;
  gap: 8px;
}
.inspector-empty svg { width: 32px; height: 32px; opacity: 0.3; }
.insp-header {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 4px;
}
.insp-header-btn {
  width: 28px;
  height: 28px;
  display: flex;
  align-items: center;
  justify-content: center;
  border: 1px solid var(--border);
  border-radius: var(--radius);
  background: var(--surface);
  cursor: pointer;
  transition: all 0.15s;
  flex-shrink: 0;
}
.insp-header-btn:hover { border-color: var(--text-secondary); }
.insp-header-btn.active { border-color: var(--accent); background: rgba(99, 102, 241, 0.1); }
.insp-header-btn svg { width: 16px; height: 16px; }
.insp-header-center {
  flex: 1;
  min-width: 0;
}
.insp-name { font-size: 16px; font-weight: 700; }
.insp-variant-label { font-size: 11px; color: var(--text-secondary); }
.insp-category { font-size: 11px; color: var(--text-secondary); margin-bottom: 12px; display: flex; align-items: center; gap: 6px; }
.insp-cat-dot { width: 8px; height: 8px; border-radius: 50%; }
/* Inspector header dropdowns */
.insp-header-dropdown {
  display: none;
  position: fixed;
  background: var(--panel-bg);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 6px 0;
  min-width: 240px;
  max-width: 280px;
  z-index: 1000;
  box-shadow: 0 4px 16px rgba(0,0,0,0.4);
  animation: metricExpand 0.15s ease-out;
}
.insp-header-dropdown.visible { display: block; }
.insp-dd-item {
  padding: 8px 12px;
  cursor: pointer;
  transition: background 0.1s;
  border-left: 3px solid transparent;
}
.insp-dd-item:hover { background: var(--surface); }
.insp-dd-item.current {
  border-left-color: var(--accent);
  background: rgba(99, 102, 241, 0.05);
}
.insp-dd-item-header {
  display: flex;
  align-items: center;
  gap: 6px;
  font-size: 12px;
  font-weight: 500;
}
.insp-dd-item-header svg { width: 14px; height: 14px; }
.insp-dd-item-sub {
  font-size: 10px;
  color: var(--text-secondary);
  font-weight: 400;
}
.insp-dd-item-current {
  font-size: 9px;
  color: var(--accent);
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.3px;
}
.insp-dd-metrics {
  display: flex;
  gap: 4px;
  margin-top: 5px;
  flex-wrap: wrap;
}
.insp-dd-metric {
  font-size: 9px;
  padding: 1px 5px;
  border-radius: 3px;
  background: var(--surface);
  border: 1px solid var(--border);
  display: inline-flex;
  align-items: center;
  gap: 2px;
}
.insp-dd-metric svg { width: 10px; height: 10px; flex-shrink: 0; }
.insp-dd-metric.positive { color: var(--green); border-color: rgba(34,197,94,0.3); }
.insp-dd-metric.negative { color: var(--red); border-color: rgba(239,68,68,0.3); }
.insp-dd-metric.neutral { color: var(--text-secondary); }
.insp-dd-rec {
  padding: 6px 12px;
  margin-top: 2px;
  border-top: 1px solid var(--border);
  font-size: 10px;
  color: var(--text-secondary);
  display: flex;
  align-items: center;
  gap: 4px;
}
.insp-dd-rec svg { width: 10px; height: 10px; }
.insp-section { margin-bottom: 14px; }
.insp-section-title {
  font-size: 10px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  color: var(--text-secondary);
  margin-bottom: 6px;
  display: flex;
  align-items: center;
  gap: 5px;
}
.insp-section-title svg { width: 12px; height: 12px; }
.insp-select {
  width: 100%;
  background: var(--surface);
  border: 1px solid var(--border);
  color: var(--text-primary);
  padding: 6px 8px;
  border-radius: var(--radius);
  font-family: inherit;
  font-size: 12px;
  cursor: pointer;
  outline: none;
}
.insp-select:focus { border-color: var(--accent); }

/* Metric bars in inspector */
.metric-row { margin-bottom: 0; }
.metric-label {
  display: flex;
  justify-content: space-between;
  font-size: 11px;
  margin-bottom: 3px;
}
.metric-name { color: var(--text-secondary); display: flex; align-items: center; gap: 4px; }
.metric-name svg { width: 11px; height: 11px; }
.metric-value { font-weight: 600; }
.metric-bar-track {
  height: 6px;
  background: var(--surface);
  border-radius: 3px;
  overflow: hidden;
  position: relative;
}
.metric-bar-fill {
  height: 100%;
  border-radius: 3px;
  transition: width 0.5s cubic-bezier(0.4, 0, 0.2, 1), background-color 0.5s;
}

/* Metric filter dropdown */
.metric-filter-wrap {
  position: relative;
  display: inline-block;
}
.metric-filter-btn {
  background: none;
  border: 1px solid transparent;
  color: var(--text-secondary);
  cursor: pointer;
  padding: 2px 5px;
  border-radius: var(--radius);
  display: flex;
  align-items: center;
  gap: 3px;
  font-size: 10px;
  font-family: inherit;
  transition: all 0.15s;
  margin-left: auto;
}
.metric-filter-btn:hover { color: var(--accent); border-color: var(--border); }
.metric-filter-btn.active { color: var(--accent); background: rgba(99, 102, 241, 0.1); border-color: var(--accent); }
.metric-filter-btn svg { width: 10px; height: 10px; }
.metric-filter-menu {
  display: none;
  position: fixed;
  background: var(--panel-bg);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 6px 0;
  min-width: 200px;
  z-index: 1000;
  box-shadow: 0 4px 16px rgba(0,0,0,0.4);
  animation: metricExpand 0.15s ease-out;
}
.metric-filter-menu.visible { display: block; }
.metric-filter-actions {
  display: flex;
  gap: 4px;
  padding: 0 8px 6px;
  border-bottom: 1px solid var(--border);
  margin-bottom: 4px;
}
.metric-filter-action {
  background: none;
  border: none;
  color: var(--accent);
  font-size: 10px;
  font-family: inherit;
  cursor: pointer;
  padding: 2px 6px;
  border-radius: 3px;
  transition: background 0.15s;
}
.metric-filter-action:hover { background: rgba(99, 102, 241, 0.15); }
.metric-filter-item {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 4px 10px;
  cursor: pointer;
  font-size: 11px;
  color: var(--text-secondary);
  transition: background 0.1s;
}
.metric-filter-item:hover { background: var(--surface); }
.metric-filter-check {
  width: 14px;
  height: 14px;
  border: 1.5px solid var(--border);
  border-radius: 3px;
  display: flex;
  align-items: center;
  justify-content: center;
  flex-shrink: 0;
  transition: all 0.15s;
}
.metric-filter-item.checked .metric-filter-check {
  background: var(--accent);
  border-color: var(--accent);
}
.metric-filter-check svg { width: 10px; height: 10px; }
.metric-filter-name { display: flex; align-items: center; gap: 4px; flex: 1; }
.metric-filter-name svg { width: 11px; height: 11px; }
.metric-filter-val {
  font-size: 10px;
  font-weight: 600;
  margin-left: auto;
}
.metric-section-title-row {
  display: flex;
  align-items: center;
  width: 100%;
}

/* Metric explanation dropdown */
.metric-row-wrap { margin-bottom: 8px; }
.metric-info-btn {
  background: none;
  border: none;
  color: var(--text-secondary);
  cursor: pointer;
  padding: 0;
  width: 14px;
  height: 14px;
  display: flex;
  align-items: center;
  justify-content: center;
  opacity: 0.5;
  transition: opacity 0.15s, color 0.15s;
  flex-shrink: 0;
}
.metric-info-btn:hover { opacity: 1; color: var(--accent); }
.metric-info-btn svg { width: 11px; height: 11px; }
.metric-explanation {
  display: none;
  margin-top: 6px;
  padding: 8px 10px;
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  font-size: 11px;
  line-height: 1.5;
  animation: metricExpand 0.2s ease-out;
}
.metric-explanation.visible { display: block; }
@keyframes metricExpand {
  from { opacity: 0; transform: translateY(-4px); }
  to { opacity: 1; transform: translateY(0); }
}
.metric-expl-reason {
  color: var(--text-primary);
  margin-bottom: 6px;
}
.metric-expl-factors {
  list-style: none;
  padding: 0;
  margin: 0;
  display: flex;
  flex-direction: column;
  gap: 3px;
}
.metric-expl-factors li {
  color: var(--text-secondary);
  font-size: 10px;
  padding-left: 12px;
  position: relative;
}
.metric-expl-factors li::before {
  content: '›';
  position: absolute;
  left: 2px;
  color: var(--accent);
  font-weight: 600;
}

/* Pros/Cons */
.pros-cons { display: flex; flex-direction: column; gap: 4px; }
.pro, .con { font-size: 11px; display: flex; gap: 4px; align-items: flex-start; }
.pro::before { content: '+'; color: var(--green); font-weight: 700; flex-shrink: 0; }
.con::before { content: '−'; color: var(--red); font-weight: 700; flex-shrink: 0; }

/* Data Context */
.data-context-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
}
.data-context-edit {
  font-size: 9px;
  color: var(--accent);
  cursor: pointer;
  opacity: 0.7;
  display: flex;
  align-items: center;
  gap: 3px;
}
.data-context-edit:hover { opacity: 1; }
.data-context-edit svg { width: 10px; height: 10px; }
.data-item {
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: 4px;
  padding: 6px 8px;
  margin-bottom: 6px;
  transition: border-color 0.3s;
}
.data-item.fit-great { border-left: 3px solid var(--green); }
.data-item.fit-good { border-left: 3px solid var(--green); opacity: 0.85; }
.data-item.fit-tradeoff { border-left: 3px solid var(--yellow); }
.data-item.fit-poor { border-left: 3px solid var(--red); }
.data-item.fit-risky { border-left: 3px solid var(--red); }
.data-item-header {
  display: flex;
  align-items: center;
  gap: 5px;
  margin-bottom: 2px;
  font-size: 11px;
  font-weight: 500;
}
.data-item-header svg { width: 11px; height: 11px; }
.fit-badge {
  font-size: 9px;
  font-weight: 600;
  padding: 1px 5px;
  border-radius: 3px;
  margin-left: auto;
  text-transform: uppercase;
  letter-spacing: 0.3px;
}
.fit-badge.great { background: rgba(34,197,94,0.15); color: var(--green); }
.fit-badge.good { background: rgba(34,197,94,0.1); color: var(--green); }
.fit-badge.tradeoff { background: rgba(234,179,8,0.15); color: var(--yellow); }
.fit-badge.poor { background: rgba(239,68,68,0.15); color: var(--red); }
.fit-badge.risky { background: rgba(239,68,68,0.15); color: var(--red); }
.data-item-note {
  font-size: 10px;
  color: var(--text-secondary);
  line-height: 1.4;
  margin-left: 16px;
}

/* Code Pattern */
.code-pattern {
  background: var(--canvas-bg);
  border: 1px solid var(--border);
  border-radius: 4px;
  padding: 8px 10px;
  font-family: 'SF Mono', 'Fira Code', 'Cascadia Code', monospace;
  font-size: 10px;
  line-height: 1.5;
  color: var(--text-secondary);
  overflow-x: auto;
  white-space: pre;
  tab-size: 2;
}
.code-pattern .kw { color: #c084fc; }
.code-pattern .fn { color: #60a5fa; }
.code-pattern .str { color: #4ade80; }
.code-pattern .cm { color: #6b7280; font-style: italic; }
.code-pattern .num { color: #fbbf24; }

/* Connection Labels */
.conn-label-group { cursor: pointer; }
.conn-label-group:hover .conn-label-bg { fill: var(--surface); }
.conn-label-bg {
  fill: var(--panel-bg);
  stroke: var(--border);
  stroke-width: 1;
  rx: 4;
  transition: fill 0.15s;
}
.conn-label-bg.selected { stroke: var(--accent); stroke-width: 1.5; }
.conn-label-text {
  fill: var(--text-secondary);
  font-size: 9px;
  font-family: 'Inter', system-ui, sans-serif;
  font-weight: 500;
  text-anchor: middle;
  dominant-baseline: central;
  pointer-events: none;
}
.conn-label-icon {
  fill: none;
  stroke: var(--text-secondary);
  stroke-width: 1;
}
.conn-label-group.selected .conn-label-text { fill: var(--accent); }

/* Connection detail in inspector */
/* Connection inspector — header with clickable endpoints */
.conn-header {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 10px;
}
.conn-endpoint {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 4px;
  cursor: pointer;
  flex: 1;
  min-width: 0;
  padding: 6px 4px;
  border-radius: var(--radius);
  transition: background 0.15s;
}
.conn-endpoint:hover { background: var(--surface); }
.conn-ep-icon {
  width: 32px;
  height: 32px;
  display: flex;
  align-items: center;
  justify-content: center;
  border: 2px solid var(--border);
  border-radius: 50%;
  background: var(--surface);
}
.conn-ep-icon svg { width: 16px; height: 16px; }
.conn-ep-name {
  font-size: 11px;
  font-weight: 600;
  text-align: center;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  max-width: 100%;
}
.conn-header-arrow { flex-shrink: 0; color: var(--text-secondary); }
.conn-header-arrow svg { width: 14px; height: 14px; }
/* Connection metadata badges */
.conn-meta {
  display: flex;
  align-items: center;
  gap: 6px;
  margin-bottom: 8px;
}
.conn-protocol-badge {
  display: inline-flex;
  align-items: center;
  gap: 3px;
  background: rgba(99, 102, 241, 0.1);
  border: 1px solid rgba(99, 102, 241, 0.3);
  border-radius: 3px;
  padding: 2px 8px;
  font-size: 10px;
  font-weight: 600;
  color: var(--accent);
}
.conn-role-tag {
  font-size: 10px;
  font-weight: 500;
  color: var(--text-secondary);
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: 3px;
  padding: 2px 8px;
}
/* Connection direction text */
.conn-direction-text {
  font-size: 11px;
  color: var(--text-secondary);
  line-height: 1.5;
  margin-bottom: 10px;
  font-style: italic;
  padding-left: 2px;
}
/* Connection property chips */
.conn-props-strip {
  display: flex;
  flex-direction: column;
  gap: 4px;
  margin-bottom: 10px;
}
.conn-prop-chip {
  display: flex;
  align-items: center;
  gap: 6px;
  font-size: 11px;
  padding: 5px 8px;
  background: var(--surface);
  border-radius: 4px;
  border-left: 3px solid var(--border);
}
.conn-prop-chip svg { width: 11px; height: 11px; flex-shrink: 0; }
.conn-prop-chip-label {
  color: var(--text-secondary);
  font-weight: 500;
  min-width: 60px;
  flex-shrink: 0;
}
.conn-prop-chip-val { color: var(--text-primary); }
.conn-prop-chip.positive { border-left-color: var(--green); }
.conn-prop-chip.positive .conn-prop-chip-val { color: var(--green); }
.conn-prop-chip.negative { border-left-color: var(--red); }
.conn-prop-chip.negative .conn-prop-chip-val { color: var(--red); }
/* Code pattern block */
.conn-code-pattern {
  background: var(--canvas-bg);
  border: 1px solid var(--border);
  border-radius: 4px;
  padding: 8px 10px;
  font-family: 'SF Mono', 'Fira Code', 'Cascadia Code', monospace;
  font-size: 10px;
  line-height: 1.5;
  color: var(--text-secondary);
  overflow-x: auto;
  white-space: pre;
  tab-size: 2;
  margin-top: 8px;
}
.conn-code-pattern .kw { color: #c084fc; }
.conn-code-pattern .fn { color: #60a5fa; }
.conn-code-pattern .str { color: #4ade80; }
.conn-code-pattern .cm { color: #6b7280; font-style: italic; }
.conn-code-pattern .num { color: #fbbf24; }
/* Connection footer — quick links to endpoints */
.conn-footer {
  display: flex;
  gap: 6px;
  margin-top: 12px;
  padding-top: 10px;
  border-top: 1px solid var(--border);
}
.conn-footer-link {
  flex: 1;
  display: flex;
  align-items: center;
  gap: 4px;
  font-size: 10px;
  color: var(--text-secondary);
  cursor: pointer;
  padding: 5px 8px;
  border: 1px solid var(--border);
  border-radius: var(--radius);
  transition: all 0.15s;
  justify-content: center;
}
.conn-footer-link:hover { border-color: var(--accent); color: var(--text-primary); }
.conn-footer-link svg { width: 11px; height: 11px; }
.conn-summary {
  font-size: 11px;
  color: var(--text-secondary);
  line-height: 1.6;
  padding: 6px 0;
}


/* ═══════════════ DASHBOARD ═══════════════ */
.dashboard {
  position: absolute;
  bottom: 0;
  left: 0;
  right: 0;
  background: var(--panel-bg);
  border-top: 1px solid var(--border);
  padding: 6px 12px;
  display: flex;
  flex-direction: column;
  z-index: 10;
}
.dashboard-title {
  font-size: 10px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  color: var(--text-secondary);
  margin-bottom: 4px;
  display: flex;
  align-items: center;
  gap: 5px;
}
.dashboard-title svg { width: 13px; height: 13px; }
.dashboard-bars {
  display: flex;
  gap: 6px;
  align-items: center;
}
.dash-bar-group {
  flex: 1;
  display: flex;
  flex-direction: column;
  gap: 2px;
}
.dash-bar-label {
  font-size: 9px;
  color: var(--text-secondary);
  text-align: center;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 3px;
}
.dash-bar-label svg { width: 10px; height: 10px; }
.dash-bar-track {
  height: 16px;
  background: var(--surface);
  border-radius: 3px;
  overflow: hidden;
  position: relative;
}
.dash-bar-fill {
  height: 100%;
  border-radius: 3px;
  transition: width 0.6s cubic-bezier(0.4, 0, 0.2, 1), background-color 0.6s;
  position: relative;
}
.dash-bar-value {
  position: absolute;
  right: 4px;
  top: 50%;
  transform: translateY(-50%);
  font-size: 9px;
  font-weight: 600;
  color: rgba(255,255,255,0.8);
}

/* Dashboard expand toggle */
.dash-expand-btn {
  background: none;
  border: 1px solid var(--border);
  border-radius: 3px;
  cursor: pointer;
  padding: 1px 4px;
  margin-left: auto;
  display: flex;
  align-items: center;
  color: var(--text-secondary);
  transition: all 0.15s;
}
.dash-expand-btn:hover { border-color: var(--text-secondary); color: var(--text-primary); }
.dash-expand-chevron { width: 10px; height: 10px; transition: transform 0.2s; }
.dashboard.expanded .dash-expand-chevron { transform: rotate(180deg); }

/* ═══════════════ DASHBOARD OVERLAY ═══════════════ */
.dash-overlay {
  display: none;
  position: absolute;
  top: 0; left: 0; right: 0; bottom: 0;
  background: rgba(15, 17, 23, 0.97);
  z-index: 20;
  flex-direction: column;
  overflow-y: auto;
  padding: 20px 24px;
}
.dash-overlay.visible { display: flex; }
.dash-overlay::-webkit-scrollbar { width: 4px; }
.dash-overlay::-webkit-scrollbar-track { background: transparent; }
.dash-overlay::-webkit-scrollbar-thumb { background: var(--border); border-radius: 2px; }
.dash-overlay-header {
  font-size: 12px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  color: var(--text-secondary);
  margin-bottom: 16px;
  display: flex;
  align-items: center;
  gap: 6px;
}
.dash-overlay-header svg { width: 14px; height: 14px; }
.dash-overlay-close {
  margin-left: auto;
  background: none;
  border: 1px solid var(--border);
  border-radius: 3px;
  color: var(--text-secondary);
  font-size: 16px;
  cursor: pointer;
  width: 24px;
  height: 24px;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.15s;
}
.dash-overlay-close:hover { border-color: var(--text-primary); color: var(--text-primary); }
.dash-overlay-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
  gap: 16px;
  flex: 1;
}
/* Each category card in the overlay */
.dash-card {
  background: var(--panel-bg);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 12px;
  display: flex;
  flex-direction: column;
  gap: 8px;
}
.dash-card-header {
  display: flex;
  align-items: center;
  gap: 6px;
  font-size: 12px;
  font-weight: 600;
}
.dash-card-header svg { width: 14px; height: 14px; }
.dash-card-score {
  font-size: 20px;
  font-weight: 700;
  margin-left: auto;
}
.dash-card-bar {
  height: 8px;
  background: var(--surface);
  border-radius: 4px;
  overflow: hidden;
}
.dash-card-fill {
  height: 100%;
  border-radius: 4px;
  transition: width 0.6s cubic-bezier(0.4, 0, 0.2, 1);
}
.dash-card-desc {
  font-size: 10px;
  color: var(--text-secondary);
  line-height: 1.4;
}
.dash-card-factors {
  display: flex;
  flex-direction: column;
  gap: 4px;
  margin-top: 4px;
}
.dash-card-factor {
  display: flex;
  align-items: center;
  gap: 6px;
  font-size: 10px;
  color: var(--text-secondary);
  position: relative;
}
.dash-card-factor-comp {
  width: 72px;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  flex-shrink: 0;
}
.dash-card-factor-icon {
  width: 14px;
  flex-shrink: 0;
  display: flex;
  align-items: center;
}
.dash-card-factor-icon svg { width: 11px; height: 11px; }
.dash-card-factor-bar {
  flex: 1;
  height: 6px;
  background: var(--surface);
  border-radius: 3px;
  overflow: hidden;
  min-width: 30px;
  display: block;
}
.dash-card-factor-fill {
  display: block;
  height: 100%;
  border-radius: 3px;
  transition: width 0.4s;
}
.dash-card-factor-val {
  width: 22px;
  text-align: right;
  font-weight: 600;
  font-size: 10px;
  flex-shrink: 0;
}
/* Factor tooltip */
.dash-card-factor-tip {
  display: none;
  position: absolute;
  bottom: calc(100% + 4px);
  left: 0;
  background: var(--panel-bg);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 6px 10px;
  font-size: 10px;
  color: var(--text-primary);
  white-space: nowrap;
  z-index: 5;
  box-shadow: 0 2px 8px rgba(0,0,0,0.3);
  pointer-events: none;
}
.dash-card-factor:hover .dash-card-factor-tip { display: block; }

/* ═══════════════ PROMPT OUTPUT ═══════════════ */
.prompt-section {
  position: fixed;
  bottom: 0;
  left: 0;
  right: 0;
  z-index: 200;
  transform: translateY(calc(100% - 32px));
  transition: transform 0.3s;
}
.prompt-section.open { transform: translateY(0); }
.prompt-toggle {
  background: var(--accent);
  color: white;
  border: none;
  padding: 6px 16px;
  font-size: 11px;
  font-weight: 600;
  font-family: inherit;
  cursor: pointer;
  border-radius: var(--radius) var(--radius) 0 0;
  margin-left: 16px;
  display: flex;
  align-items: center;
  gap: 5px;
}
.prompt-toggle svg { width: 14px; height: 14px; }
.prompt-body {
  background: var(--panel-bg);
  border-top: 1px solid var(--accent);
  padding: 12px 16px;
  max-height: 180px;
  display: flex;
  gap: 12px;
}
.prompt-text {
  flex: 1;
  font-size: 12px;
  color: var(--text-secondary);
  line-height: 1.6;
  overflow-y: auto;
  font-family: 'Inter', system-ui, sans-serif;
}
.prompt-copy-btn {
  background: var(--accent);
  color: white;
  border: none;
  padding: 6px 14px;
  border-radius: var(--radius);
  font-size: 11px;
  font-weight: 600;
  font-family: inherit;
  cursor: pointer;
  align-self: flex-start;
  white-space: nowrap;
  transition: background 0.15s;
  display: flex;
  align-items: center;
  gap: 4px;
}
.prompt-copy-btn svg { width: 12px; height: 12px; }
.prompt-copy-btn:hover { background: var(--accent-hover); }

/* ═══════════════ RIPPLE ANIMATION ═══════════════ */
@keyframes ripplePulse {
  0% { box-shadow: 0 0 0 0 rgba(99,102,241,0.4); }
  70% { box-shadow: 0 0 0 10px rgba(99,102,241,0); }
  100% { box-shadow: 0 0 0 0 rgba(99,102,241,0); }
}
.node.rippling { animation: ripplePulse 0.4s ease-out; }

/* ═══════════════ INFO POPUP ═══════════════ */
.info-popup-overlay {
  display: none;
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  background: rgba(0,0,0,0.5);
  z-index: 300;
  align-items: center;
  justify-content: center;
}
.info-popup-overlay.visible { display: flex; }
.info-popup {
  background: var(--panel-bg);
  border: 1px solid var(--border);
  border-radius: 8px;
  padding: 20px;
  max-width: 420px;
  width: 90%;
  box-shadow: 0 16px 48px rgba(0,0,0,0.5);
}
.info-popup-header {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 12px;
  font-size: 15px;
  font-weight: 700;
}
.info-popup-header svg { width: 22px; height: 22px; }
.info-popup-close {
  margin-left: auto;
  background: none;
  border: none;
  color: var(--text-secondary);
  cursor: pointer;
  font-size: 18px;
  padding: 2px 6px;
  border-radius: 4px;
  display: flex;
  align-items: center;
  transition: color 0.15s, background 0.15s;
}
.info-popup-close:hover { color: var(--text-primary); background: var(--surface); }
.info-popup-close svg { width: 14px; height: 14px; }
.info-popup-body {
  font-size: 12px;
  line-height: 1.6;
  color: var(--text-secondary);
}
.info-popup-body strong { color: var(--text-primary); font-weight: 600; }
.info-popup-body p { margin: 0 0 8px; }
.info-popup-section {
  margin-bottom: 10px;
}
.info-popup-section-title {
  font-size: 10px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  color: var(--text-secondary);
  margin-bottom: 4px;
}
.info-popup-list {
  margin: 0;
  padding-left: 16px;
}
.info-popup-list li { margin-bottom: 3px; }

/* Dashboard info icon */
.dash-info-btn {
  background: none;
  border: none;
  color: var(--text-secondary);
  cursor: pointer;
  padding: 0;
  display: inline-flex;
  align-items: center;
  opacity: 0.4;
  transition: opacity 0.15s, color 0.15s;
}
.dash-info-btn:hover { opacity: 1; color: var(--accent); }
.dash-info-btn svg { width: 9px; height: 9px; }

/* Clickable category icon on nodes */
.node-icon.clickable { cursor: pointer; transition: transform 0.15s; z-index: 6; position: relative; }
.node-icon.clickable:hover { transform: scale(1.2); }
.legend-item.clickable { cursor: pointer; transition: color 0.15s; }
.legend-item.clickable:hover { color: var(--text-primary) !important; }

/* Connection Health Indicator */
.conn-health-indicator { margin-top: 4px; }
.conn-health-badge {
  display: inline-flex;
  align-items: center;
  gap: 6px;
  padding: 4px 10px;
  border-radius: 4px;
  font-size: 11px;
  font-weight: 600;
  margin-bottom: 6px;
}
.conn-health-dot {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  flex-shrink: 0;
}
.conn-health-desc {
  font-size: 11px;
  color: var(--text-secondary);
  line-height: 1.5;
  margin-bottom: 8px;
}
.conn-health-endpoints {
  display: flex;
  flex-direction: column;
  gap: 4px;
  margin-bottom: 6px;
}
.conn-health-ep {
  display: flex;
  align-items: center;
  gap: 6px;
  font-size: 11px;
  color: var(--text-primary);
  background: var(--surface);
  padding: 4px 8px;
  border-radius: 4px;
}
.conn-health-rule {
  font-size: 9px;
  color: var(--text-secondary);
  font-style: italic;
  opacity: 0.7;
}
/* ═══════════════ CONNECTION HEALTH DETAIL ═══════════════ */
.conn-health-info-btn {
  width: 18px; height: 18px;
  border: none; background: none; cursor: pointer;
  color: var(--text-secondary); padding: 0; margin-left: 4px;
  border-radius: 50%; display: flex; align-items: center; justify-content: center;
  flex-shrink: 0; transition: color 0.15s, background 0.15s;
}
.conn-health-info-btn:hover { color: var(--accent); background: var(--accent)15; }
.conn-health-info-btn svg { width: 14px; height: 14px; }
.conn-health-metrics {
  display: none; padding: 6px 8px; margin-top: 4px;
  background: var(--canvas-bg); border-radius: 4px;
  border: 1px solid var(--border);
}
.conn-health-metrics.visible { display: block; }
.conn-health-metric-row {
  display: flex; align-items: center; gap: 6px;
  font-size: 10px; padding: 2px 0;
}
.conn-health-metric-name {
  width: 90px; color: var(--text-secondary); flex-shrink: 0;
}
.conn-health-metric-bar {
  flex: 1; height: 4px; background: var(--surface);
  border-radius: 2px; overflow: hidden; position: relative;
}
.conn-health-metric-fill {
  height: 100%; border-radius: 2px; transition: width 0.3s ease;
}
.conn-health-metric-val {
  width: 28px; text-align: right; font-weight: 600; font-size: 10px; flex-shrink: 0;
}
.conn-health-metric-flag {
  font-size: 9px; font-weight: 600; width: 12px; text-align: center; flex-shrink: 0;
}
.conn-health-metrics-label {
  font-size: 9px; color: var(--text-secondary); margin-bottom: 4px;
  text-transform: uppercase; letter-spacing: 0.5px; font-weight: 600;
}

/* ═══════════════ COLLAPSIBLE SECTIONS ═══════════════ */
.insp-section-title.collapsible {
  cursor: pointer;
  user-select: none;
  transition: color 0.15s;
}
.insp-section-title.collapsible:hover { color: var(--text-primary); }
.section-chevron {
  margin-left: auto;
  display: inline-flex;
  transition: transform 0.2s ease;
}
.section-chevron svg { width: 10px; height: 10px; }
.section-chevron.open { transform: rotate(90deg); }
.insp-section-body.collapsed { display: none; }
/* Collapsible toolbox cards */
.card-header.collapsible {
  cursor: pointer;
  user-select: none;
  transition: opacity 0.15s;
}
.card-header.collapsible:hover { opacity: 1; }
.card-header.collapsible .section-chevron { margin-left: auto; }
.card-details.collapsed { display: none; }

/* ═══════════════ METRIC DELTAS ═══════════════ */
.metric-delta {
  font-size: 10px;
  font-weight: 600;
  margin-left: 4px;
  display: inline-block;
  animation: deltaFadeIn 0.3s ease;
}
@keyframes deltaFadeIn {
  from { opacity: 0; transform: translateY(-4px); }
  to { opacity: 1; transform: translateY(0); }
}
.metric-delta.positive { color: var(--green); }
.metric-delta.negative { color: var(--red); }
.metric-delta.neutral { color: var(--text-secondary); }

/* ═══════════════ ISSUES SUMMARY ═══════════════ */
.issues-badge {
  position: absolute;
  top: -4px;
  right: -4px;
  background: var(--red);
  color: white;
  font-size: 9px;
  font-weight: 700;
  width: 16px;
  height: 16px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  pointer-events: none;
  line-height: 1;
}
.issues-badge.warning { background: var(--yellow); color: #000; }
.issues-badge.hidden { display: none; }
.issues-dropdown {
  position: fixed;
  background: var(--panel-bg);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 4px;
  min-width: 300px;
  z-index: 150;
  box-shadow: 0 8px 24px rgba(0,0,0,0.4);
  display: none;
}
.issues-dropdown.visible { display: block; }
.issues-dropdown-title {
  font-size: 10px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  color: var(--text-secondary);
  padding: 6px 8px 4px;
  display: flex;
  align-items: center;
  gap: 4px;
}
.issues-dropdown-title svg { width: 12px; height: 12px; }
.issues-item {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 6px 8px;
  border-radius: 4px;
  cursor: pointer;
  transition: background 0.1s;
  font-size: 11px;
}
.issues-item:hover { background: var(--surface); }
.issues-item svg { width: 14px; height: 14px; }
.issues-item-dot {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  flex-shrink: 0;
}
.issues-item-name { font-weight: 500; flex: 1; }
.issues-item-detail { color: var(--text-secondary); font-size: 10px; }
.issues-none {
  padding: 12px 8px;
  text-align: center;
  color: var(--text-secondary);
  font-size: 11px;
}

/* ═══════════════ VARIANT HINT ═══════════════ */
.variant-hint {
  background: var(--surface);
  border: 1px solid var(--border);
  border-left: 3px solid var(--accent);
  border-radius: var(--radius);
  padding: 6px 8px;
  margin-top: 6px;
  font-size: 10px;
  color: var(--text-secondary);
  line-height: 1.4;
  display: flex;
  align-items: flex-start;
  gap: 4px;
}
.variant-hint svg { width: 12px; height: 12px; flex-shrink: 0; margin-top: 1px; }
.variant-hint strong { color: var(--accent); font-weight: 600; }
.variant-hint .delta-positive { color: var(--green); font-weight: 600; }
.variant-hint .delta-negative { color: var(--red); font-weight: 600; }

/* ═══════════════ METRIC THRESHOLD ═══════════════ */
.metric-threshold {
  position: absolute;
  top: -1px;
  bottom: -1px;
  width: 1px;
  background: var(--text-secondary);
  opacity: 0.25;
  z-index: 1;
}

/* ═══════════════ DASHBOARD CLICKABLE ═══════════════ */
.dash-bar-track.clickable { cursor: pointer; transition: opacity 0.15s; }
.dash-bar-track.clickable:hover { opacity: 0.85; }
.node.flash-highlight { animation: nodeFlash 0.8s ease; }
@keyframes nodeFlash {
  0%, 100% { box-shadow: 0 0 0 0 rgba(99,102,241,0); }
  50% { box-shadow: 0 0 20px 4px rgba(99,102,241,0.5); }
}
</style>
</head>
<body>

<!-- ═══════════════ TOP BAR ═══════════════ -->
<div class="top-bar">
  <div class="logo">
    <svg viewBox="0 0 18 18" fill="none" stroke="currentColor" stroke-width="1.5"><rect x="2" y="2" width="14" height="14" rx="3"/><circle cx="6" cy="7" r="1.5" fill="currentColor" stroke="none"/><circle cx="12" cy="7" r="1.5" fill="currentColor" stroke="none"/><path d="M6 7h6M9 7v5"/></svg>
    Archie
  </div>
  <div class="arch-name">Auction System Architecture</div>
  <div class="tier-badge" onclick="showTierInfo()" style="cursor:pointer" title="Click for tier details">
    <svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M8 1l2.5 4.5L16 6.5l-4 3.5 1 5.5L8 13l-5 2.5 1-5.5-4-3.5 5.5-1z"/></svg>
    Tier 2 <span class="tier-hint">/ 3</span>
  </div>
  <div class="top-actions">
    <button class="top-btn" id="heatmapToggle" onclick="toggleHeatmap()">
      <svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><circle cx="8" cy="8" r="6"/><circle cx="8" cy="8" r="3" opacity="0.5"/><circle cx="8" cy="8" r="1" fill="currentColor" stroke="none"/></svg>
      Heatmap
    </button>
    <button class="top-btn" id="issuesBtn" onclick="toggleIssues()" style="position:relative">
      <svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M8 2L1 14h14z"/><path d="M8 6v4M8 12v.5"/></svg>
      Issues
      <span class="issues-badge hidden" id="issuesBadge">0</span>
    </button>
    <button class="top-btn" onclick="togglePanel('toolbox')">
      <svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><rect x="2" y="2" width="5" height="12" rx="1"/><rect x="9" y="2" width="5" height="5" rx="1"/><rect x="9" y="9" width="5" height="5" rx="1"/></svg>
      Toolbox
    </button>
    <button class="top-btn" onclick="togglePanel('inspector')">
      <svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><rect x="2" y="2" width="12" height="12" rx="1"/><line x1="8" y1="2" x2="8" y2="14"/><line x1="8" y1="6" x2="14" y2="6"/><line x1="8" y1="10" x2="14" y2="10"/></svg>
      Inspector
    </button>
    <button class="top-btn">
      <svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M3 14V9l5-7 5 7v5"/><path d="M6 14v-3h4v3"/></svg>
      Import
    </button>
    <button class="top-btn">
      <svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M4 2h8l2 3v9H2V5z"/><path d="M5 2v3h6V2"/><circle cx="8" cy="10" r="2"/></svg>
      Export
    </button>
  </div>
</div>

<!-- ═══════════════ MAIN LAYOUT ═══════════════ -->
<div class="main-layout">
  <!-- TOOLBOX -->
  <aside class="toolbox" id="toolbox">
    <div class="toolbox-title">
      <svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><rect x="2" y="2" width="5" height="12" rx="1"/><rect x="9" y="2" width="5" height="5" rx="1"/><rect x="9" y="9" width="5" height="5" rx="1"/></svg>
      Toolbox
    </div>
    <div class="toolbox-tabs">
      <button class="toolbox-tab active" onclick="switchTab(this,'components')">
        <svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><rect x="2" y="2" width="5" height="5" rx="1"/><rect x="9" y="2" width="5" height="5" rx="1"/><rect x="2" y="9" width="5" height="5" rx="1"/><rect x="9" y="9" width="5" height="5" rx="1"/></svg>
        Components
      </button>
      <button class="toolbox-tab" onclick="switchTab(this,'stacks')">
        <svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><rect x="3" y="2" width="10" height="3" rx="1"/><rect x="3" y="7" width="10" height="3" rx="1"/><rect x="3" y="12" width="10" height="3" rx="1"/></svg>
        Stacks
      </button>
      <button class="toolbox-tab" onclick="switchTab(this,'blueprints')">
        <svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 2h12v12H2z"/><path d="M5 5h6M5 8h6M5 11h3"/><circle cx="12" cy="11" r="1" fill="currentColor" stroke="none"/></svg>
        Blueprints
      </button>
    </div>
    <div class="toolbox-content" id="toolboxContent"></div>
  </aside>

  <!-- CANVAS -->
  <main class="canvas" id="canvas">
    <svg class="canvas-svg" id="flowSvg" style="z-index:0"></svg>
    <svg class="canvas-svg" id="canvasSvg"></svg>
    <div id="nodesContainer"></div>
    <!-- Legend -->
    <div class="canvas-legend" id="canvasLegend"></div>
    <div class="canvas-hint">
      <svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><circle cx="8" cy="8" r="6"/><path d="M8 5v3M8 10v1"/></svg>
      Click a component to inspect &middot; Toggle heatmap to see health overlay
    </div>
    <!-- DASHBOARD — inside canvas, at bottom -->
    <div class="dashboard" id="dashboard">
      <div class="dashboard-title">
        <svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><rect x="1" y="8" width="3" height="6" rx="0.5"/><rect x="5.5" y="5" width="3" height="9" rx="0.5"/><rect x="10" y="2" width="3" height="12" rx="0.5"/></svg>
        Architecture Health
        <button class="dash-expand-btn" onclick="toggleDashboardExpand()" title="Show contributing factors">
          <svg class="dash-expand-chevron" viewBox="0 0 10 10" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2.5 4L5 6.5L7.5 4"/></svg>
        </button>
      </div>
      <div class="dashboard-bars" id="dashboardBars"></div>
    </div>
    <!-- DASHBOARD EXPANDED OVERLAY -->
    <div class="dash-overlay" id="dashOverlay">
      <div class="dash-overlay-header">
        <svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><rect x="1" y="8" width="3" height="6" rx="0.5"/><rect x="5.5" y="5" width="3" height="9" rx="0.5"/><rect x="10" y="2" width="3" height="12" rx="0.5"/></svg>
        Architecture Health — 7 Metric Categories
        <button class="dash-overlay-close" onclick="toggleDashboardExpand()" title="Close details">&times;</button>
      </div>
      <div class="dash-overlay-grid" id="dashOverlayGrid"></div>
    </div>
  </main>

  <!-- INSPECTOR -->
  <aside class="inspector" id="inspector">
    <div class="inspector-header">
      <svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><rect x="2" y="2" width="12" height="12" rx="1"/><line x1="8" y1="2" x2="8" y2="14"/><line x1="8" y1="6" x2="14" y2="6"/><line x1="8" y1="10" x2="14" y2="10"/></svg>
      Inspector
    </div>
    <div class="inspector-content" id="inspectorContent">
      <div class="inspector-empty">
        <svg viewBox="0 0 32 32" fill="none" stroke="currentColor" stroke-width="1"><circle cx="16" cy="16" r="12"/><path d="M16 10v6M16 20v1"/></svg>
        Click a component on the canvas to see its details, metrics, and configuration variants.
      </div>
    </div>
  </aside>
</div>

<!-- ═══════════════ PROMPT OUTPUT ═══════════════ -->
<div class="prompt-section" id="promptSection">
  <button class="prompt-toggle" onclick="document.getElementById('promptSection').classList.toggle('open')">
    <svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><rect x="2" y="2" width="12" height="12" rx="2"/><path d="M5 6h6M5 8h6M5 10h4"/></svg>
    Prompt Output
  </button>
  <div class="prompt-body">
    <div class="prompt-text" id="promptText"></div>
    <button class="prompt-copy-btn" onclick="copyPrompt()">
      <svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><rect x="5" y="5" width="9" height="9" rx="1"/><path d="M5 11H3a1 1 0 01-1-1V3a1 1 0 011-1h7a1 1 0 011 1v2"/></svg>
      Copy Prompt
    </button>
  </div>
</div>

<!-- ═══════════════ INFO POPUP ═══════════════ -->
<div class="info-popup-overlay" id="infoPopupOverlay" onclick="if(event.target===this)hideInfoPopup()">
  <div class="info-popup">
    <div class="info-popup-header" id="infoPopupHeader"></div>
    <div class="info-popup-body" id="infoPopupBody"></div>
  </div>
</div>

<!-- Issues Dropdown (fixed position, placed by JS) -->
<div class="issues-dropdown" id="issuesDropdown"></div>

<script>
// ═══════════════ SVG ICONS ═══════════════
const ICONS = {
  // Category icons
  'Compute': '<svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><rect x="4" y="4" width="8" height="8" rx="1"/><line x1="6" y1="2" x2="6" y2="4"/><line x1="10" y1="2" x2="10" y2="4"/><line x1="6" y1="12" x2="6" y2="14"/><line x1="10" y1="12" x2="10" y2="14"/><line x1="2" y1="6" x2="4" y2="6"/><line x1="2" y1="10" x2="4" y2="10"/><line x1="12" y1="6" x2="14" y2="6"/><line x1="12" y1="10" x2="14" y2="10"/></svg>',
  'Data Storage': '<svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><ellipse cx="8" cy="4" rx="5" ry="2"/><path d="M3 4v8c0 1.1 2.24 2 5 2s5-.9 5-2V4"/><path d="M3 8c0 1.1 2.24 2 5 2s5-.9 5-2" opacity="0.5"/></svg>',
  'Caching': '<svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M9 1L4 9h4l-1 6 5-8H8l1-6z" stroke-linejoin="round"/></svg>',
  'Messaging': '<svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 3h12v8H6l-4 3V3z" stroke-linejoin="round"/></svg>',
  'Delivery/Network': '<svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><circle cx="8" cy="8" r="6"/><ellipse cx="8" cy="8" rx="3" ry="6"/><line x1="2" y1="8" x2="14" y2="8"/></svg>',
  'Real-Time': '<svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 8h2l2-4 2 8 2-5 2 3h2"/></svg>',
  'Auth/Security': '<svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M8 1L2 4v4c0 4 2.5 6 6 7 3.5-1 6-3 6-7V4L8 1z"/></svg>',
  'Monitoring': '<svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><rect x="2" y="2" width="12" height="12" rx="1"/><path d="M4 10l3-4 2 2 3-4"/></svg>',
  'Search': '<svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><circle cx="7" cy="7" r="4"/><line x1="10" y1="10" x2="14" y2="14"/></svg>',
  'DevOps': '<svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><circle cx="8" cy="8" r="2"/><path d="M8 2v2M8 12v2M2 8h2M12 8h2M3.8 3.8l1.4 1.4M10.8 10.8l1.4 1.4M3.8 12.2l1.4-1.4M10.8 5.2l1.4-1.4"/></svg>',
  // UI icons
  'is': '<svg viewBox="0 0 10 10" fill="none" stroke="currentColor" stroke-width="1.5"><circle cx="5" cy="5" r="3.5"/></svg>',
  'gain': '<svg viewBox="0 0 10 10" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M5 2v6M2 5l3-3 3 3"/></svg>',
  'cost': '<svg viewBox="0 0 10 10" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M5 8V2M2 5l3 3 3-3"/></svg>',
  'config': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.5"><circle cx="6" cy="6" r="2"/><path d="M6 1v2M6 9v2M1 6h2M9 6h2"/></svg>',
  'metrics': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.5"><rect x="1" y="6" width="2" height="5" rx="0.5"/><rect x="5" y="3" width="2" height="8" rx="0.5"/><rect x="9" y="1" width="2" height="10" rx="0.5"/></svg>',
  'pros': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.5"><circle cx="6" cy="6" r="4.5"/><path d="M4 6h4M6 4v4"/></svg>',
  'cons': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.5"><circle cx="6" cy="6" r="4.5"/><path d="M4 6h4"/></svg>',
  // Dashboard category icons
  'perf': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M2 10l3-5 2 2 3-5"/><path d="M9 2h2v2"/></svg>',
  'cost_dash': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><circle cx="6" cy="6" r="4"/><path d="M6 3v6M4.5 4.5h3M4.5 7.5h3"/></svg>',
  'rel': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M6 1L1.5 4v3.5c0 2.5 1.8 4 4.5 4.5 2.7-.5 4.5-2 4.5-4.5V4L6 1z"/></svg>',
  'ops': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><circle cx="6" cy="6" r="2"/><path d="M6 1v1.5M6 9.5V11M1 6h1.5M9.5 6H11M2.8 2.8l1 1M8.2 8.2l1 1M2.8 9.2l1-1M8.2 3.8l1-1"/></svg>',
  'scale': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M2 10V6l4-4 4 4v4"/></svg>',
  'strat': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><circle cx="6" cy="4" r="2"/><path d="M6 6v4M3 8h6"/></svg>',
  'dev_dash': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M4 3L1 6l3 3M8 3l3 3-3 3"/></svg>',
  // Data context icons
  'data_ctx': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><rect x="1" y="1" width="10" height="10" rx="1"/><path d="M4 4h4M4 6h4M4 8h2"/></svg>',
  'edit': '<svg viewBox="0 0 10 10" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M1 9l6-6 1 1-6 6z"/><path d="M6 3l1-1 2 2-1 1"/></svg>',
  'session': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><circle cx="6" cy="4" r="2.5"/><path d="M2 10c0-2.2 1.8-4 4-4s4 1.8 4 4"/></svg>',
  'counter': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M2 10V5l2-3 2 4 2-2 2 3v3"/></svg>',
  'cache_item': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><rect x="2" y="2" width="8" height="8" rx="1"/><path d="M5 4v4M4 7l1 1 1-1"/></svg>',
  'table': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><rect x="1" y="1" width="10" height="10" rx="1"/><line x1="1" y1="4" x2="11" y2="4"/><line x1="5" y1="4" x2="5" y2="11"/></svg>',
  'message': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M2 2h8v6H5l-3 2V2z"/></svg>',
  'endpoint': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M1 6h4M7 6h4"/><circle cx="6" cy="6" r="2"/></svg>',
  'route': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M2 2l8 8M2 5h3M7 9h3"/></svg>',
  'event': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M7 1L3 7h3l-1 4 4-6H6l1-4z"/></svg>',
  'receipt': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M2 6l3 3 5-5"/></svg>',
  'presence': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><circle cx="6" cy="6" r="3"/><circle cx="6" cy="6" r="1" fill="currentColor" stroke="none"/></svg>',
  'ssl': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><rect x="3" y="5" width="6" height="5" rx="1"/><path d="M4 5V4a2 2 0 014 0v1"/></svg>',
  'ratelimit': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><circle cx="6" cy="6" r="4.5"/><path d="M6 3v3l2 1"/></svg>',
  // Metric-specific icons
  'latency': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><circle cx="6" cy="6" r="4.5"/><path d="M6 3.5v3l2 1.5"/></svg>',
  'throughput': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M1 6h10M8 3l3 3-3 3"/></svg>',
  'cost_eff': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><circle cx="6" cy="6" r="4"/><path d="M6 3v6M4.5 4.5h3M4.5 7.5h3"/></svg>',
  'simplicity': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M3 4h6M3 6h6M3 8h4"/></svg>',
  'read_perf': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><circle cx="6" cy="5" r="3"/><path d="M1 5c2-3 8-3 10 0M1 5c2 3 8 3 10 0"/></svg>',
  'write_perf': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M2 10l7-7 1 1-7 7z"/><path d="M8 3l1-1 2 2-1 1"/></svg>',
  'scalability': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M2 10V6l4-4 4 4v4"/></svg>',
  'consistency': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M2 6h8M4 3h4M4 9h4"/></svg>',
  'ordering': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M3 3h6M3 6h4M3 9h2"/></svg>',
  'code': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M4 3L1 6l3 3"/><path d="M8 3l3 3-3 3"/><line x1="7" y1="2" x2="5" y2="10"/></svg>',
  // Connection property icons
  'protocol': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M2 6h8"/><circle cx="2" cy="6" r="1.5"/><circle cx="10" cy="6" r="1.5"/></svg>',
  'pattern': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M2 6h2l1-3 2 6 1-3h2"/></svg>',
  'speed': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><circle cx="6" cy="7" r="4"/><path d="M6 7l2-3"/><path d="M3 7h1M8 7h1"/></svg>',
  'coloc': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><rect x="1" y="3" width="10" height="6" rx="1"/><line x1="6" y1="3" x2="6" y2="9"/></svg>',
  'conn': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M1 6h3M8 6h3"/><rect x="4" y="3" width="4" height="6" rx="1"/></svg>',
  'arrow_right': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M2 6h8M7 3l3 3-3 3"/></svg>',
  'arrow_bidir': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M2 6h8M4 3L1 6l3 3M8 3l3 3-3 3"/></svg>',
  'info': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><circle cx="6" cy="6" r="5"/><path d="M6 5.5v3"/><circle cx="6" cy="3.5" r="0.5" fill="currentColor" stroke="none"/></svg>',
  'close': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M3 3l6 6M9 3l-6 6"/></svg>',
  'chevron': '<svg viewBox="0 0 10 10" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M3 2l4 3-4 3"/></svg>',
  // New metric icons
  'reliability': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M6 1L1.5 4v3.5c0 2.5 1.8 4 4.5 4.5 2.7-.5 4.5-2 4.5-4.5V4L6 1z"/></svg>',
  'portability': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M6 1v10M1 6h10"/><circle cx="6" cy="6" r="4.5"/><path d="M2.5 4h7M2.5 8h7"/></svg>',
  'learning': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M1 4.5l5-2.5 5 2.5-5 2.5z"/><path d="M2.5 5.5v3c0 1 1.5 1.5 3.5 1.5s3.5-.5 3.5-1.5v-3"/></svg>',
  'filter': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M1.5 2h9L7.5 6v3.5L4.5 11V6z"/></svg>'
};

// Map metric names to icon keys
const METRIC_ICON_MAP = {
  'Latency': 'latency', 'Throughput': 'throughput', 'Cost Efficiency': 'cost_eff',
  'Op. Simplicity': 'simplicity', 'Read Perf': 'read_perf', 'Write Perf': 'write_perf',
  'Scalability': 'scalability', 'Consistency': 'consistency', 'Ordering': 'ordering',
  'Reliability': 'reliability', 'Portability': 'portability', 'Learning Curve': 'learning'
};

// Metric explanations — why each component+variant scores the way it does
const METRIC_EXPLANATIONS = {
  'bid-api': {
    'express': {
      'Latency': { reason: 'Minimal overhead for simple bid routing, but no schema compilation means validation happens at runtime.', factors: ['Middleware chain adds ~0.1ms per layer', 'JSON parsing on every request', 'No compiled validators — validation runs on each bid'] },
      'Throughput': { reason: 'Single-threaded event loop handles concurrent bids, but no optimization for serialization or validation.', factors: ['Event loop handles I/O efficiently', 'No schema-based serialization optimization', 'Manual validation logic for bid payloads'] },
      'Cost Efficiency': { reason: 'Tiny footprint (~30MB idle), runs anywhere Node.js runs. No license cost.', factors: ['Minimal dependencies (~200KB installed)', 'Low memory baseline', 'No runtime fees'] },
      'Op. Simplicity': { reason: 'Dead simple to start: 5 lines to a working API. No opinionated structure.', factors: ['Minimal boilerplate', 'Massive middleware ecosystem', 'No enforced project structure — good and bad'] },
      'Reliability': { reason: 'Uncaught exceptions crash the process. Manual error handling required for bid validation failures.', factors: ['No built-in error boundaries', 'Process crash on unhandled rejection', 'Manual try/catch in all async handlers'] },
      'Portability': { reason: 'Standard Node.js, MIT license. Runs everywhere. Minimal vendor lock-in.', factors: ['Open-source, no vendor tie-in', 'Standard HTTP API', 'Middleware patterns are universal'] },
      'Learning Curve': { reason: 'Most JavaScript developers productive in hours. Huge community and examples.', factors: ['Familiar patterns for JS devs', 'Millions of tutorials', 'Simple mental model'] }
    },
    'fastify': {
      'Latency': { reason: 'Compiles JSON schemas at startup for bid validation, reducing per-request overhead.', factors: ['Schema compilation eliminates runtime validation cost', 'Radix-tree router faster than Express', 'Optimized serializers for bid responses'] },
      'Throughput': { reason: '2-3x faster than Express in benchmarks — critical for high-frequency bid traffic.', factors: ['Compiled serialization avoids JSON.stringify', 'Efficient routing via find-my-way', 'Lower plugin overhead vs Express middleware'] },
      'Cost Efficiency': { reason: 'Higher throughput per instance means fewer servers needed for same bid load.', factors: ['More bids/sec per node', 'Similar memory to Express', 'Open-source, no license cost'] },
      'Op. Simplicity': { reason: 'Schema-first approach requires upfront design, but enforces validation automatically.', factors: ['Plugin system has learning curve', 'Schema-first mindset shift', 'Smaller community than Express'] },
      'Reliability': { reason: 'Schema validation rejects malformed bids early. Plugin encapsulation prevents cross-contamination.', factors: ['Invalid bids rejected before handler', 'Plugin isolation limits failure blast radius', 'Built-in error hooks for consistent handling'] },
      'Portability': { reason: 'Standard Node.js, MIT license. Plugin API is Fastify-specific but portable.', factors: ['Open-source, no vendor lock-in', 'Standard Node.js runtime', 'Plugin patterns differ from Express but portable'] },
      'Learning Curve': { reason: 'Requires understanding plugin system and schema-first design. Different mental model vs Express.', factors: ['Plugin encapsulation vs middleware', 'JSON Schema knowledge required', 'Fewer Stack Overflow answers'] }
    },
    'go-api': {
      'Latency': { reason: 'Compiled Go binary with lightweight goroutines handles bids with minimal per-request overhead.', factors: ['Native compiled code (no JIT warmup)', 'Goroutines are cheaper than Node event loop tasks', 'Built-in JSON decoder is fast'] },
      'Throughput': { reason: 'Goroutines scale to tens of thousands of concurrent bids with low memory per connection.', factors: ['Goroutines use ~2KB stack vs Node callback heap', 'True parallelism across CPU cores', 'No event loop contention'] },
      'Cost Efficiency': { reason: 'Single binary deployment, minimal runtime overhead. Runs on smaller instances than Node.', factors: ['No runtime (just binary)', 'Low memory footprint', 'Cross-compile for any platform'] },
      'Op. Simplicity': { reason: 'Single binary deployment is simple, but Go project structure and tooling have learning curve.', factors: ['Single binary = easy deploy', 'Go modules and project layout conventions', 'Manual dependency management'] },
      'Reliability': { reason: 'Statically typed with compile-time checks. Panic recovery requires explicit setup.', factors: ['Type safety catches errors at compile time', 'Explicit error handling (no try/catch)', 'Panic recovery middleware needed for graceful failures'] },
      'Portability': { reason: 'Fully open-source, cross-compiles to any platform. No runtime dependency.', factors: ['Open-source (BSD-style license)', 'Cross-compile to Linux/Mac/Windows', 'No external runtime needed'] },
      'Learning Curve': { reason: 'Go syntax is simple, but concurrency patterns (goroutines, channels) require learning.', factors: ['Simple syntax, small language', 'Goroutine/channel patterns unfamiliar to JS devs', 'Different error handling model (no exceptions)'] }
    }
  },
  'auction-engine': {
    'sync-validation': {
      'Latency': { reason: 'Every bid blocks until validation completes: balance check, auction state check, business rules. Latency spikes under load.', factors: ['Synchronous DB reads for balance/state', 'Sequential validation steps block response', 'Auction closing time = thundering herd of validations'] },
      'Throughput': { reason: 'Limited by synchronous validation speed. Single-threaded validation bottleneck at high bid rates.', factors: ['Each bid waits for full validation', 'DB contention on auction state reads', 'No parallelism in validation pipeline'] },
      'Consistency': { reason: 'Perfect consistency: no phantom bids, no double-wins. Validation ensures every accepted bid is valid.', factors: ['Strong consistency guarantees', 'No race conditions on bid acceptance', 'Auction state always reflects valid bids'] },
      'Reliability': { reason: 'Validation failures are immediate and clear. Easy to debug and retry.', factors: ['Synchronous errors easy to handle', 'No eventual consistency edge cases', 'Clear failure semantics'] },
      'Op. Simplicity': { reason: 'Simplest mental model: validate, accept or reject. Easy to reason about and debug.', factors: ['Linear code flow', 'No async coordination', 'Debugging is straightforward'] },
      'Scalability': { reason: 'Vertical scaling only — faster DB, more CPU. Horizontal scaling limited by shared auction state.', factors: ['Synchronous validation limits parallelism', 'Shared state prevents easy sharding', 'Auction closing time creates hot spot'] },
      'Learning Curve': { reason: 'Standard synchronous validation logic. No distributed systems complexity.', factors: ['Familiar imperative code', 'No event-driven patterns needed', 'Easy onboarding for junior devs'] }
    },
    'async-event': {
      'Latency': { reason: 'Bids accepted in <10ms, validation happens asynchronously. Users get instant feedback.', factors: ['Immediate bid acceptance (just write to queue)', 'Validation runs in background workers', 'No blocking DB reads on bid submission'] },
      'Throughput': { reason: 'Massive throughput: bid acceptance decoupled from validation. Queue absorbs bursts.', factors: ['Async workers scale independently', 'Queue buffers bid spikes', 'Parallel validation across workers'] },
      'Consistency': { reason: 'Eventual consistency: bids accepted now, rejected later if invalid. Risk of phantom bids in UI.', factors: ['Bid shown as "pending" until validated', 'Rejected bids removed after async check', 'Last-second bids may race and both appear to win'] },
      'Reliability': { reason: 'Queue provides durability, but failure recovery is complex. Retry logic and dead-letter queues needed.', factors: ['Queue ensures bids not lost', 'Validation failures require compensation logic', 'Monitoring must track validation lag'] },
      'Op. Simplicity': { reason: 'Complex: async workers, queue management, eventual consistency edge cases.', factors: ['Distributed workers need coordination', 'Queue depth monitoring critical', 'Compensating transactions for rejected bids'] },
      'Scalability': { reason: 'Horizontal scaling: add more validation workers. Near-linear scaling with worker count.', factors: ['Workers scale independently of bid API', 'Queue distributes load', 'Auction closing time handled by worker parallelism'] },
      'Learning Curve': { reason: 'Requires understanding async patterns, eventual consistency, and queue semantics.', factors: ['Event-driven architecture patterns', 'Eventual consistency mental model', 'Queue failure modes and retries'] }
    },
    'cqrs': {
      'Latency': { reason: 'Write path optimized for speed (append to event log), read path materialized for instant queries. Best of both.', factors: ['Write: append-only event log (fast)', 'Read: pre-materialized views (instant)', 'No read-write contention'] },
      'Throughput': { reason: 'Separate read/write models scale independently. Highest throughput potential.', factors: ['Write model: event log append-only', 'Read model: optimized projections', 'No shared locks between reads and writes'] },
      'Consistency': { reason: 'Eventual consistency between write and read models. Projections lag behind events.', factors: ['Events written immediately', 'Read projections updated asynchronously', 'Users see eventual state in UI'] },
      'Reliability': { reason: 'Event sourcing provides full audit trail and replay capability. Complex failure recovery.', factors: ['Event log is immutable (perfect audit)', 'Projection rebuild from events possible', 'Projection failures require careful recovery'] },
      'Op. Simplicity': { reason: 'Most complex: separate write/read databases, event handlers, projection updates, schema evolution.', factors: ['Dual database infrastructure', 'Event schema versioning required', 'Projection update logic must be maintained'] },
      'Scalability': { reason: 'Best scalability: read and write scale independently. Can optimize each side separately.', factors: ['Write DB optimized for appends', 'Read DB optimized for queries', 'Independent horizontal scaling'] },
      'Learning Curve': { reason: 'Steepest curve: event sourcing, CQRS patterns, projection management, schema evolution.', factors: ['CQRS pattern itself is advanced', 'Event sourcing mindset shift', 'Projection maintenance complexity'] }
    }
  },
  'payment-service': {
    'sync-stripe': {
      'Latency': { reason: 'Synchronous Stripe API call blocks until payment confirmed. Network latency + Stripe processing time.', factors: ['HTTP round-trip to Stripe (~100-300ms)', 'Payment processing time (card auth)', 'User waits for full payment before bid confirmation'] },
      'Reliability': { reason: 'Immediate payment confirmation. No orphaned bids if payment fails.', factors: ['Payment status known before bid finalized', 'No compensation logic needed', 'Clear error handling'] },
      'Consistency': { reason: 'Perfect consistency: bid and payment are atomic. Either both succeed or both fail.', factors: ['Synchronous flow ensures atomicity', 'No payment-bid mismatch', 'Simple rollback on failure'] },
      'Op. Simplicity': { reason: 'Simplest pattern: call Stripe, get result, accept or reject bid.', factors: ['Linear code flow', 'No async coordination', 'Easy debugging'] },
      'Scalability': { reason: 'Limited by Stripe API rate limits and synchronous blocking. Each bid waits for payment.', factors: ['Stripe API has rate limits', 'Blocking calls limit throughput', 'High-frequency auctions bottlenecked'] },
      'Cost Efficiency': { reason: 'Stripe fees per transaction (2.9% + 30¢). No additional infrastructure.', factors: ['Standard Stripe transaction fees', 'No queue or worker infrastructure', 'Simple cost model'] },
      'Portability': { reason: 'Tightly coupled to Stripe API. Switching payment providers requires rewriting integration.', factors: ['Stripe-specific API calls', 'Webhook format is proprietary', 'Payment flow tied to Stripe semantics'] }
    },
    'async-queue': {
      'Latency': { reason: 'Bid accepted immediately, payment processed asynchronously. Sub-10ms bid response.', factors: ['Payment queued, not blocking', 'User gets instant bid confirmation', 'Payment result arrives later via webhook'] },
      'Reliability': { reason: 'Queue provides durability, but async failures require compensating transactions.', factors: ['Payment failures detected later', 'Must refund or cancel bid after acceptance', 'Dead-letter queue for failed payments'] },
      'Consistency': { reason: 'Eventual consistency: bid accepted before payment confirmed. Risk of failed payment after bid shown as winning.', factors: ['Bid shown as "pending payment"', 'Payment failure requires bid cancellation', 'User may see "won" then "payment failed"'] },
      'Op. Simplicity': { reason: 'Complex: async workers, queue management, webhook handling, compensating transactions.', factors: ['Payment workers need monitoring', 'Webhook reliability critical', 'Failed payment compensation logic'] },
      'Scalability': { reason: 'Horizontal scaling: add more payment workers. Queue absorbs burst traffic.', factors: ['Workers scale independently', 'Queue buffers payment spikes', 'Stripe rate limits still apply per worker'] },
      'Cost Efficiency': { reason: 'Stripe fees unchanged, but queue infrastructure (SQS, workers) adds operational cost.', factors: ['Stripe fees same as sync', 'Queue and worker infrastructure', 'More complex monitoring'] },
      'Portability': { reason: 'Queue pattern is portable, but Stripe integration still vendor-specific.', factors: ['Queue pattern is universal', 'Stripe API still proprietary', 'Webhook handling requires Stripe SDK'] }
    },
    'saga-orchestrator': {
      'Latency': { reason: 'Orchestrator coordinates multi-step payment flow (reserve, charge, confirm). Adds coordination overhead.', factors: ['Multiple round-trips (reserve → charge → confirm)', 'Orchestrator state machine latency', 'Compensation steps if any phase fails'] },
      'Reliability': { reason: 'Saga pattern ensures eventual consistency with compensating transactions. Best for complex payment flows.', factors: ['Compensation logic handles failures', 'State machine tracks progress', 'Rollback on any step failure'] },
      'Consistency': { reason: 'Eventual consistency with compensating transactions. Complex but handles partial failures gracefully.', factors: ['Multi-step saga ensures atomicity over time', 'Compensation steps undo partial work', 'State machine prevents orphaned states'] },
      'Op. Simplicity': { reason: 'Most complex: orchestrator service, state machine, compensating transactions, saga monitoring.', factors: ['Orchestrator adds extra service', 'State machine logic to maintain', 'Saga monitoring and debugging'] },
      'Scalability': { reason: 'Orchestrator can be scaled horizontally, but adds latency to each payment.', factors: ['Orchestrator instances scale independently', 'State persistence (DB) is bottleneck', 'More moving parts than async-queue'] },
      'Cost Efficiency': { reason: 'Highest operational cost: orchestrator service, state DB, monitoring. Best for complex multi-party payments.', factors: ['Orchestrator infrastructure', 'State database for saga tracking', 'Worth it for multi-step payment flows'] },
      'Portability': { reason: 'Saga pattern is portable, but orchestrator implementation is custom code.', factors: ['Saga pattern is universal', 'Orchestrator logic is custom', 'Payment provider swapping still hard'] }
    }
  },
  'notification-service': {
    'email-smtp': {
      'Latency': { reason: 'SMTP handshake and email delivery adds 200-500ms per notification. Blocks if synchronous.', factors: ['SMTP connection establishment', 'Email queue at provider', 'Delivery confirmation if requested'] },
      'Reliability': { reason: 'Email delivery is best-effort. Bounces and spam filters cause silent failures.', factors: ['No guaranteed delivery', 'Spam filters may drop emails', 'Bounce handling requires webhook setup'] },
      'Cost Efficiency': { reason: 'Email providers (SendGrid, Mailgun) charge per email. Low cost at small scale.', factors: ['Per-email pricing ($0.001-$0.01)', 'Free tiers for low volume', 'No infrastructure beyond SMTP'] },
      'Op. Simplicity': { reason: 'Simple SMTP integration. Well-understood, but bounce handling adds complexity.', factors: ['Standard SMTP protocol', 'Bounce/spam handling manual', 'Email templates need maintenance'] },
      'Scalability': { reason: 'SMTP rate limits and connection pooling limit throughput. Not ideal for real-time auction updates.', factors: ['Provider rate limits', 'Connection pool bottleneck', 'High-frequency auctions overwhelm email'] },
      'Portability': { reason: 'SMTP is universal. Easy to switch providers (SendGrid, Mailgun, AWS SES).', factors: ['Standard SMTP protocol', 'Provider-agnostic', 'Templates may be provider-specific'] },
      'Learning Curve': { reason: 'SMTP is widely understood. Email templating and bounce handling require learning.', factors: ['SMTP basics are simple', 'Templating engines vary', 'Bounce/spam handling patterns'] }
    },
    'push-websocket': {
      'Latency': { reason: 'WebSocket push is instant (<10ms) once connection established. Perfect for real-time auction updates.', factors: ['Persistent connection (no handshake)', 'Direct push to client', 'Sub-10ms delivery'] },
      'Reliability': { reason: 'WebSocket connections can drop. Requires reconnect logic and message replay.', factors: ['Connection drops on network hiccup', 'Reconnect with exponential backoff', 'Message queue for offline clients'] },
      'Cost Efficiency': { reason: 'WebSocket infrastructure (load balancer, connection management) has fixed cost. Scales well.', factors: ['Persistent connections use memory', 'Load balancer sticky sessions', 'Better cost at scale than email'] },
      'Op. Simplicity': { reason: 'Complex: connection lifecycle, reconnect logic, message replay, load balancer affinity.', factors: ['Connection management code', 'Reconnect logic on client + server', 'Stateful load balancing required'] },
      'Scalability': { reason: 'Horizontal scaling requires sticky sessions or Redis pub/sub for connection fanout.', factors: ['Sticky sessions complicate scaling', 'Redis pub/sub for cross-server fanout', 'Memory per connection adds up'] },
      'Portability': { reason: 'WebSocket is standard protocol. Server implementation varies (Socket.io, ws, native).', factors: ['WebSocket protocol is standard', 'Library choice affects portability', 'Redis pub/sub adds dependency'] },
      'Learning Curve': { reason: 'WebSocket patterns require understanding connection lifecycle, reconnect, and message replay.', factors: ['Connection management patterns', 'Reconnect strategies', 'Message ordering and replay'] }
    },
    'multi-channel': {
      'Latency': { reason: 'Fan-out to multiple channels (email, SMS, push) adds latency. Parallel sending helps.', factors: ['Multiple provider API calls', 'Parallel dispatch reduces latency', 'Slowest channel determines total time'] },
      'Reliability': { reason: 'Redundancy: if one channel fails, others succeed. Best delivery guarantee.', factors: ['Multiple delivery paths', 'Fallback to other channels', 'Each channel has own failure mode'] },
      'Cost Efficiency': { reason: 'Highest cost: pay for email, SMS, push infrastructure. Best for critical notifications.', factors: ['Multiple provider fees', 'SMS is expensive ($0.01-$0.05/msg)', 'Worth it for critical auction events'] },
      'Op. Simplicity': { reason: 'Most complex: integrate multiple providers, handle per-channel failures, user preferences.', factors: ['Multiple provider integrations', 'Per-user channel preferences', 'Failure handling per channel'] },
      'Scalability': { reason: 'Each channel scales independently. Fan-out workers handle parallel dispatch.', factors: ['Parallel channel dispatch', 'Each provider has own rate limits', 'Worker pool handles fanout'] },
      'Portability': { reason: 'Each channel has vendor lock-in (Twilio for SMS, SendGrid for email). Harder to migrate.', factors: ['Multiple vendor dependencies', 'Each provider has proprietary API', 'User preference DB is custom'] },
      'Learning Curve': { reason: 'Requires understanding multiple notification patterns, provider APIs, and user preference management.', factors: ['Multiple provider SDKs', 'User preference logic', 'Channel-specific failure modes'] }
    }
  },
  'event-bus': {
    'kafka': {
      'Throughput': { reason: 'Partitioned topic allows parallel processing. Millions of events/sec with proper partitioning.', factors: ['Partition-level parallelism', 'Zero-copy disk I/O', 'Batch writes for efficiency'] },
      'Ordering': { reason: 'Ordering guaranteed per partition. Global ordering requires single partition (throughput hit).', factors: ['Per-partition ordering only', 'Partition key determines message placement', 'Single partition = total order but low throughput'] },
      'Reliability': { reason: 'Replicated partitions across brokers. Automatic failover. Mature and battle-tested.', factors: ['Configurable replication factor', 'Leader election on failure', 'Durable disk-backed log'] },
      'Op. Simplicity': { reason: 'Complex: partition management, consumer groups, rebalancing, offset tracking.', factors: ['Partition key design critical', 'Consumer group coordination', 'Monitoring lag and rebalancing'] },
      'Scalability': { reason: 'Horizontal scaling via partitions. Add brokers and partitions to scale.', factors: ['Add partitions for more parallelism', 'Broker cluster distributes load', 'Consumer groups scale processing'] },
      'Cost Efficiency': { reason: 'Self-hosted Kafka requires significant infrastructure. Managed services (MSK, Confluent) add cost.', factors: ['Broker cluster infrastructure', 'ZooKeeper or KRaft coordination', 'Managed services charge per GB/hour'] },
      'Portability': { reason: 'Open-source Apache Kafka. Runs self-hosted or managed (Confluent, MSK, Redpanda).', factors: ['Apache 2.0 license', 'Kafka protocol widely supported', 'Managed services add proprietary features'] }
    },
    'rabbitmq': {
      'Throughput': { reason: 'Lower raw throughput than Kafka, but flexible routing makes up for it in many use cases.', factors: ['Per-message routing overhead', 'Not optimized for disk persistence', 'Lower throughput ceiling than Kafka'] },
      'Ordering': { reason: 'Queue-level ordering. Easier to guarantee than Kafka partitions.', factors: ['Single queue = strict ordering', 'No partition key design needed', 'Consumer acknowledgment ensures order'] },
      'Reliability': { reason: 'Message acknowledgment and persistence. Clustering for HA. Mature and stable.', factors: ['Publisher confirms for durability', 'Consumer acks prevent message loss', 'Mirrored queues for HA'] },
      'Op. Simplicity': { reason: 'Simpler than Kafka for basic pub/sub. Management UI and well-documented patterns.', factors: ['Built-in management UI', 'Flexible exchange/queue model', 'Easier to get started than Kafka'] },
      'Scalability': { reason: 'Vertical scaling preferred. Horizontal scaling via federation or sharding is complex.', factors: ['Single-node performance decent', 'Clustering for HA, not throughput', 'Federation adds complexity'] },
      'Cost Efficiency': { reason: 'Lower infrastructure requirements than Kafka for moderate workloads. Managed options available.', factors: ['Smaller cluster footprint', 'CloudAMQP for managed hosting', 'Less disk I/O than Kafka'] },
      'Portability': { reason: 'Open-source AMQP protocol. Portable across RabbitMQ-compatible services.', factors: ['AMQP is open standard', 'Multiple provider support', 'CloudAMQP, AWS MQ'] }
    },
    'aws-eventbridge': {
      'Throughput': { reason: 'Managed service with built-in throttling. Suitable for moderate event rates, not millions/sec.', factors: ['Default 10,000 events/sec', 'Soft limits can be increased', 'Not for Kafka-scale throughput'] },
      'Ordering': { reason: 'No ordering guarantees by default. Requires custom logic or FIFO event buses.', factors: ['No built-in ordering', 'FIFO buses available (limited throughput)', 'Event replay not supported'] },
      'Reliability': { reason: 'AWS-managed with SLA. At-least-once delivery. Retry and dead-letter queue built-in.', factors: ['AWS 99.99% SLA', 'Automatic retries', 'DLQ for failed events'] },
      'Op. Simplicity': { reason: 'Simplest: fully managed, zero infrastructure. Event pattern matching via console.', factors: ['No servers to manage', 'Event pattern matching via UI', 'Built-in CloudWatch integration'] },
      'Scalability': { reason: 'Auto-scales within AWS limits. Good for variable workloads, not ultra-high throughput.', factors: ['Automatic scaling', 'Throttling on burst', 'Best for bursty, not sustained load'] },
      'Cost Efficiency': { reason: 'Pay-per-event pricing. Cheap at low scale, expensive at high volume.', factors: ['$1.00 per million events', 'No infrastructure cost', 'Expensive vs self-hosted Kafka at scale'] },
      'Portability': { reason: 'Deeply AWS-specific. Migration requires rewriting event routing and targets.', factors: ['Proprietary event pattern syntax', 'Lambda/SNS/SQS integrations AWS-only', 'No open standard'] }
    }
  },
  'bid-store': {
    'postgresql': {
      'Write Perf': { reason: 'ACID writes with fsync to disk. Slower than in-memory, but durable.', factors: ['Disk I/O on commit', 'WAL write before response', 'Index updates on bid insert'] },
      'Read Perf': { reason: 'Indexed reads are fast. Complex queries (top bidder, bid history) require JOINs.', factors: ['B-tree index lookups', 'JOINs for bid history', 'Query planner overhead'] },
      'Consistency': { reason: 'Full ACID. Serializable isolation prevents phantom bids.', factors: ['Serializable transactions', 'Row-level locking', 'Strong consistency guarantees'] },
      'Reliability': { reason: 'WAL ensures crash recovery. Streaming replication for HA. Decades of production use.', factors: ['WAL for durability', 'Replication for HA', 'PITR backup capability'] },
      'Scalability': { reason: 'Vertical scaling preferred. Read replicas help, but write scaling limited.', factors: ['Single-master writes', 'Read replicas for read scaling', 'Partitioning bids by auction is possible'] },
      'Cost Efficiency': { reason: 'Open-source, but requires infrastructure. Managed services (RDS) add cost.', factors: ['No license cost', 'Infrastructure for primary + replicas', 'RDS charges per instance'] },
      'Portability': { reason: 'Standard SQL, open-source. Highly portable across cloud providers.', factors: ['PostgreSQL is universal', 'Standard SQL queries', 'RDS, CloudSQL, Azure DB compatible'] }
    },
    'redis-postgresql': {
      'Write Perf': { reason: 'Writes go to Redis (fast), async persisted to PostgreSQL. Best of both.', factors: ['Redis write in <1ms', 'Async batch to PostgreSQL', 'Eventual persistence'] },
      'Read Perf': { reason: 'Recent bids in Redis (sub-ms). Historical queries hit PostgreSQL.', factors: ['Hot data in Redis', 'Cold data in PostgreSQL', 'Cache-aside pattern'] },
      'Consistency': { reason: 'Eventual consistency. Redis crash loses unpersisted bids.', factors: ['Async writes to PostgreSQL', 'Redis crash = data loss', 'TTL moves data to PostgreSQL'] },
      'Reliability': { reason: 'Redis persistence (AOF/RDB) required. Complex failure recovery.', factors: ['Redis AOF for crash safety', 'PostgreSQL as durable store', 'Dual failure modes'] },
      'Scalability': { reason: 'Redis handles hot auction data. PostgreSQL for historical queries. Best scaling profile.', factors: ['Redis scales horizontally (cluster)', 'PostgreSQL for cold data', 'Partitioning by auction'] },
      'Cost Efficiency': { reason: 'Higher cost: Redis + PostgreSQL infrastructure. Worth it for high-frequency auctions.', factors: ['Redis cluster cost', 'PostgreSQL for persistence', 'Operational complexity'] },
      'Portability': { reason: 'Dual-store pattern is custom logic. Harder to migrate than single DB.', factors: ['Custom sync logic', 'Both Redis and PostgreSQL dependencies', 'TTL and eviction rules are custom'] }
    },
    'event-store': {
      'Write Perf': { reason: 'Append-only event log is extremely fast. No updates, just appends.', factors: ['Append-only writes (no random I/O)', 'No index updates on write', 'Sequential disk writes'] },
      'Read Perf': { reason: 'Reading current state requires event replay. Projections speed up reads but add complexity.', factors: ['Event replay for current state', 'Projections for fast queries', 'Projection lag introduces staleness'] },
      'Consistency': { reason: 'Event log is append-only (immutable). Projections are eventually consistent.', factors: ['Event log is source of truth', 'Projections lag behind events', 'Projection updates are async'] },
      'Reliability': { reason: 'Immutable event log provides perfect audit trail. Replay capability for recovery.', factors: ['Events never deleted', 'Full audit trail', 'Rebuild projections from events'] },
      'Scalability': { reason: 'Event log scales well (append-only). Projection updates can bottleneck.', factors: ['Append-only log scales', 'Projection updates compete for resources', 'Sharding by auction ID possible'] },
      'Cost Efficiency': { reason: 'Dual storage (events + projections) increases cost. Best for audit/compliance needs.', factors: ['Store events + projections', 'Higher storage requirements', 'Worth it for full audit trail'] },
      'Portability': { reason: 'Event sourcing pattern is universal, but implementation is custom.', factors: ['Event sourcing is portable pattern', 'Projection logic is custom', 'EventStoreDB is one option, not only'] }
    }
  },
  'cache-layer': {
    'redis': {
      'Read Perf': { reason: 'In-memory, sub-millisecond reads. Perfect for hot auction data (active bids, current price).', factors: ['In-memory lookup (<1ms)', 'Single-threaded but event-driven', 'Excellent for hot data'] },
      'Write Perf': { reason: 'Single-threaded writes, but async replication keeps it fast. Pipelining helps throughput.', factors: ['Single-threaded write bottleneck', 'Async replication (fire-and-forget)', 'Pipelining batches commands'] },
      'Consistency': { reason: 'Async replication means replica lag. Failover can lose recent writes.', factors: ['Master-replica async replication', 'Replica lag on heavy write load', 'Failover may lose seconds of data'] },
      'Reliability': { reason: 'Persistence (AOF/RDB) provides crash recovery. Sentinel/Cluster for HA.', factors: ['AOF (append-only file) for durability', 'Sentinel for automatic failover', 'Cluster mode for sharding'] },
      'Op. Simplicity': { reason: 'Simple single-master setup, but Sentinel/Cluster add operational complexity.', factors: ['Single-master is simple', 'Sentinel requires 3+ nodes', 'Cluster mode has resharding complexity'] },
      'Scalability': { reason: 'Horizontal scaling via Redis Cluster. Sharding by key prefix (auction ID).', factors: ['Cluster mode shards data', 'Linear scaling with nodes', 'Single-threaded write per shard'] },
      'Cost Efficiency': { reason: 'Memory-intensive. Managed services (ElastiCache) charge per GB. High cost at scale.', factors: ['All data in RAM', 'ElastiCache charges per GB/hour', 'Replication doubles memory usage'] },
      'Portability': { reason: 'Open-source, widely supported. ElastiCache, Upstash, self-hosted all compatible.', factors: ['Standard RESP protocol', 'Redis Cluster is open standard', 'Managed services are Redis-compatible'] }
    },
    'memcached': {
      'Read Perf': { reason: 'In-memory, extremely fast reads. Slightly faster than Redis for pure key-value.', factors: ['In-memory, sub-ms reads', 'Multi-threaded (better CPU utilization)', 'No data structure overhead'] },
      'Write Perf': { reason: 'Multi-threaded writes scale with CPU cores. Better throughput than Redis for simple sets.', factors: ['Multi-threaded write handling', 'No persistence overhead', 'Simpler than Redis (just key-value)'] },
      'Consistency': { reason: 'No replication. Each node independent. Client-side hashing distributes keys.', factors: ['No replication (each node isolated)', 'Client hashing for distribution', 'Node failure = data loss for that node'] },
      'Reliability': { reason: 'No persistence or replication. Node failure loses all data on that node.', factors: ['No durability (pure cache)', 'Node failure = cache miss', 'Must rebuild cache from DB'] },
      'Op. Simplicity': { reason: 'Simpler than Redis: no persistence, no replication, just pure cache.', factors: ['No persistence config', 'No replication to manage', 'Simple LRU eviction'] },
      'Scalability': { reason: 'Horizontal scaling via consistent hashing. Add nodes to increase capacity.', factors: ['Consistent hashing for sharding', 'Add nodes for more capacity', 'Multi-threaded scales with cores'] },
      'Cost Efficiency': { reason: 'Memory-only, no persistence overhead. Cheaper than Redis for pure caching.', factors: ['No disk I/O for persistence', 'Lower per-node cost than Redis', 'No replication memory overhead'] },
      'Portability': { reason: 'Open-source, simple protocol. Widely supported (AWS ElastiCache, self-hosted).', factors: ['Memcached protocol is standard', 'ElastiCache supports it', 'Client libraries everywhere'] }
    },
    'local-cache': {
      'Read Perf': { reason: 'Fastest possible: in-process memory. No network hop, no serialization.', factors: ['In-process (no network)', 'No serialization overhead', 'Microsecond latency'] },
      'Write Perf': { reason: 'In-process write is instant. No replication, no network overhead.', factors: ['In-memory write (instant)', 'No replication', 'No network or serialization'] },
      'Consistency': { reason: 'Each server has independent cache. Invalidation broadcasts needed for consistency.', factors: ['Per-server cache isolation', 'Cache invalidation broadcasts required', 'Eventual consistency across servers'] },
      'Reliability': { reason: 'Process restart loses all cache. No durability. Graceful degradation on cache miss.', factors: ['No persistence (cache lost on restart)', 'Cache miss = DB read', 'Warm-up period after deploy'] },
      'Op. Simplicity': { reason: 'Simplest: no external service. Just in-memory Map or LRU cache. Invalidation adds complexity.', factors: ['No external dependency', 'Simple LRU in application code', 'Cache invalidation broadcast logic needed'] },
      'Scalability': { reason: 'Memory per server. Scales with application instances. No shared cache.', factors: ['Memory usage per app instance', 'Horizontal scaling = more cache copies', 'No cache coordination overhead'] },
      'Cost Efficiency': { reason: 'Zero external cost. Uses application server memory. Best cost profile.', factors: ['No Redis/Memcached infrastructure', 'Uses existing app server memory', 'Invalidation broadcasts add network cost'] },
      'Portability': { reason: 'Fully portable: just code. No external dependency.', factors: ['No external service dependency', 'Works anywhere (cloud, on-prem, edge)', 'Language-specific implementation'] }
    }
  }
};

// Component catalog — full list of available components grouped by category
const COMPONENT_CATALOG = {
  'Delivery/Network': [
    { name: 'Nginx', sub: 'Reverse proxy', connectsFrom: ['Clients', 'CDN'], connectsTo: ['Compute'] },
    { name: 'AWS API Gateway', sub: 'Managed gateway', connectsFrom: ['Clients'], connectsTo: ['Compute', 'Auth/Security'] },
    { name: 'Kong', sub: 'Plugin ecosystem', connectsFrom: ['Clients'], connectsTo: ['Compute', 'Auth/Security'] },
    { name: 'Traefik', sub: 'Cloud-native', connectsFrom: ['Clients', 'DevOps'], connectsTo: ['Compute'] },
    { name: 'HAProxy', sub: 'TCP/HTTP LB', connectsFrom: ['Clients'], connectsTo: ['Compute'] },
    { name: 'Envoy', sub: 'Service mesh', connectsFrom: ['Compute'], connectsTo: ['Compute'] },
    { name: 'CloudFront', sub: 'CDN + edge', connectsFrom: ['Clients'], connectsTo: ['Delivery/Network', 'Compute'] }
  ],
  'Compute': [
    { name: 'Node.js', sub: 'Event-driven I/O', connectsFrom: ['Delivery/Network'], connectsTo: ['Data Storage', 'Caching', 'Messaging', 'Search'] },
    { name: 'Go', sub: 'Concurrency', connectsFrom: ['Delivery/Network'], connectsTo: ['Data Storage', 'Caching', 'Messaging'] },
    { name: 'Python FastAPI', sub: 'ML-friendly', connectsFrom: ['Delivery/Network'], connectsTo: ['Data Storage', 'Caching', 'Messaging'] },
    { name: 'Rust Actix', sub: 'Max performance', connectsFrom: ['Delivery/Network'], connectsTo: ['Data Storage', 'Caching', 'Messaging'] },
    { name: 'Java Spring', sub: 'Enterprise', connectsFrom: ['Delivery/Network'], connectsTo: ['Data Storage', 'Caching', 'Messaging'] },
    { name: '.NET / C#', sub: 'Microsoft stack', connectsFrom: ['Delivery/Network'], connectsTo: ['Data Storage', 'Caching', 'Messaging'] }
  ],
  'Data Storage': [
    { name: 'PostgreSQL', sub: 'Relational ACID', connectsFrom: ['Compute'], connectsTo: ['Search', 'Monitoring'] },
    { name: 'MongoDB', sub: 'Document DB', connectsFrom: ['Compute'], connectsTo: ['Search'] },
    { name: 'MySQL', sub: 'Web standard', connectsFrom: ['Compute'], connectsTo: ['Search'] },
    { name: 'CockroachDB', sub: 'Distributed SQL', connectsFrom: ['Compute'], connectsTo: [] },
    { name: 'DynamoDB', sub: 'Serverless NoSQL', connectsFrom: ['Compute'], connectsTo: [] },
    { name: 'Cassandra', sub: 'Wide-column', connectsFrom: ['Compute'], connectsTo: [] }
  ],
  'Caching': [
    { name: 'Redis', sub: 'Data structures', connectsFrom: ['Compute'], connectsTo: ['Real-Time'] },
    { name: 'Memcached', sub: 'Simple cache', connectsFrom: ['Compute'], connectsTo: [] },
    { name: 'KeyDB', sub: 'Multi-thread Redis', connectsFrom: ['Compute'], connectsTo: [] },
    { name: 'Dragonfly', sub: 'Modern cache', connectsFrom: ['Compute'], connectsTo: [] },
    { name: 'Varnish', sub: 'HTTP cache', connectsFrom: ['Delivery/Network'], connectsTo: ['Compute'] }
  ],
  'Messaging': [
    { name: 'Kafka', sub: 'Event streaming', connectsFrom: ['Compute'], connectsTo: ['Compute', 'Data Storage', 'Real-Time'] },
    { name: 'RabbitMQ', sub: 'Classic MQ', connectsFrom: ['Compute'], connectsTo: ['Compute'] },
    { name: 'AWS SQS', sub: 'Managed queue', connectsFrom: ['Compute'], connectsTo: ['Compute'] },
    { name: 'Apache Pulsar', sub: 'Multi-tenant', connectsFrom: ['Compute'], connectsTo: ['Compute', 'Data Storage'] },
    { name: 'NATS', sub: 'Lightweight', connectsFrom: ['Compute'], connectsTo: ['Compute'] }
  ],
  'Real-Time': [
    { name: 'Socket.io', sub: 'WebSocket + fallback', connectsFrom: ['Compute', 'Caching'], connectsTo: ['Clients'] },
    { name: 'Pusher', sub: 'Managed realtime', connectsFrom: ['Compute'], connectsTo: ['Clients'] },
    { name: 'Ably', sub: 'Global pub/sub', connectsFrom: ['Compute'], connectsTo: ['Clients'] },
    { name: 'Centrifugo', sub: 'Self-hosted', connectsFrom: ['Compute', 'Messaging'], connectsTo: ['Clients'] },
    { name: 'SSE Endpoint', sub: 'Server-sent events', connectsFrom: ['Compute'], connectsTo: ['Clients'] }
  ],
  'Auth/Security': [
    { name: 'Auth0', sub: 'Managed auth', connectsFrom: ['Delivery/Network', 'Compute'], connectsTo: ['Data Storage'] },
    { name: 'Keycloak', sub: 'Self-hosted IAM', connectsFrom: ['Delivery/Network'], connectsTo: ['Data Storage'] },
    { name: 'AWS Cognito', sub: 'AWS auth', connectsFrom: ['Delivery/Network'], connectsTo: [] },
    { name: 'Custom JWT', sub: 'In-house', connectsFrom: ['Compute'], connectsTo: ['Caching', 'Data Storage'] },
    { name: 'OAuth2 Proxy', sub: 'Gateway auth', connectsFrom: ['Delivery/Network'], connectsTo: ['Compute'] }
  ],
  'Monitoring': [
    { name: 'Datadog', sub: 'Full observability', connectsFrom: ['All components'], connectsTo: ['Alerting'] },
    { name: 'Grafana + Prometheus', sub: 'OSS metrics', connectsFrom: ['Compute', 'Data Storage'], connectsTo: ['Alerting'] },
    { name: 'ELK Stack', sub: 'Log analytics', connectsFrom: ['All components'], connectsTo: [] },
    { name: 'Jaeger', sub: 'Distributed tracing', connectsFrom: ['Compute'], connectsTo: [] },
    { name: 'Sentry', sub: 'Error tracking', connectsFrom: ['Compute'], connectsTo: ['Alerting'] }
  ],
  'Search': [
    { name: 'Elasticsearch', sub: 'Full-text + analytics', connectsFrom: ['Data Storage', 'Compute'], connectsTo: ['Compute'] },
    { name: 'Algolia', sub: 'Managed search', connectsFrom: ['Compute'], connectsTo: [] },
    { name: 'Meilisearch', sub: 'Fast + simple', connectsFrom: ['Compute'], connectsTo: [] },
    { name: 'Typesense', sub: 'Typo-tolerant', connectsFrom: ['Compute'], connectsTo: [] }
  ],
  'DevOps': [
    { name: 'Docker', sub: 'Containers', connectsFrom: [], connectsTo: ['All components'] },
    { name: 'Kubernetes', sub: 'Orchestration', connectsFrom: ['DevOps'], connectsTo: ['All components'] },
    { name: 'Terraform', sub: 'IaC', connectsFrom: [], connectsTo: ['All components'] },
    { name: 'GitHub Actions', sub: 'CI/CD', connectsFrom: [], connectsTo: ['DevOps'] },
    { name: 'ArgoCD', sub: 'GitOps', connectsFrom: ['DevOps'], connectsTo: ['Compute'] }
  ]
};

// Swap icon SVG
const SWAP_ICON = '<svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M4 6l-2 2 2 2"/><path d="M2 8h10"/><path d="M12 10l2-2-2-2"/><path d="M14 8H4"/></svg>';

// Alternative components per category (for swap feature)
const ALTERNATIVES = {
  'bid-api': [
    { id: 'bid-api', name: 'Bid API', sub: 'Current' },
    { id: 'go-api', name: 'Go API', sub: 'Concurrency' },
    { id: 'python-api', name: 'Python FastAPI', sub: 'ML-friendly' },
    { id: 'rust-api', name: 'Rust Actix', sub: 'Max perf' }
  ],
  'auction-engine': [
    { id: 'auction-engine', name: 'Auction Engine', sub: 'Current' },
    { id: 'lambda-step', name: 'Lambda + Step Fn', sub: 'Serverless' },
    { id: 'temporal', name: 'Temporal', sub: 'Workflow Engine' },
    { id: 'microservices', name: 'Microservices', sub: 'Distributed' }
  ],
  'payment-service': [
    { id: 'payment-service', name: 'Payment Service', sub: 'Current' },
    { id: 'stripe-sdk', name: 'Stripe SDK', sub: 'Direct Integration' },
    { id: 'payment-gateway', name: 'Payment Gateway', sub: 'Multi-provider' },
    { id: 'blockchain', name: 'Blockchain', sub: 'Crypto payments' }
  ],
  'notification-service': [
    { id: 'notification-service', name: 'Notification Service', sub: 'Current' },
    { id: 'sns-ses', name: 'AWS SNS/SES', sub: 'Managed' },
    { id: 'sendgrid', name: 'SendGrid', sub: 'Email platform' },
    { id: 'twilio', name: 'Twilio', sub: 'Multi-channel' }
  ],
  'event-bus': [
    { id: 'event-bus', name: 'Event Bus', sub: 'Current' },
    { id: 'rabbitmq', name: 'RabbitMQ', sub: 'Classic MQ' },
    { id: 'aws-sqs', name: 'AWS SQS', sub: 'Managed queue' },
    { id: 'pulsar', name: 'Apache Pulsar', sub: 'Multi-tenant' }
  ],
  'bid-store': [
    { id: 'bid-store', name: 'Bid Store', sub: 'Current' },
    { id: 'mongodb', name: 'MongoDB', sub: 'Document DB' },
    { id: 'mysql', name: 'MySQL', sub: 'Web standard' },
    { id: 'cockroachdb', name: 'CockroachDB', sub: 'Distributed SQL' }
  ],
  'cache-layer': [
    { id: 'cache-layer', name: 'Cache Layer', sub: 'Current' },
    { id: 'memcached', name: 'Memcached', sub: 'Simple cache' },
    { id: 'keydb', name: 'KeyDB', sub: 'Multi-thread Redis' },
    { id: 'dragonfly', name: 'Dragonfly', sub: 'Modern cache' }
  ]
};

// Connection type icons (SVG path data for canvas labels, viewBox 0 0 10 10)
const CONN_TYPE_DEFS = {
  http: { color: '#06b6d4', name: 'HTTP/REST',
    path: 'M1,5H9M7,3l2,2-2,2M3,7L1,5l2-2' },
  database: { color: '#22c55e', name: 'Database',
    path: 'M3,2.5C3,1.5,7,1.5,7,2.5V7.5C7,8.5,3,8.5,3,7.5ZM3,5C3,6,7,6,7,5' },
  cache: { color: '#f97316', name: 'Cache',
    path: 'M6,1L3,5.5H5.2L4,9L7.5,4.5H5.3Z' },
  queue: { color: '#a855f7', name: 'Message Queue',
    path: 'M1,3H6L4.5,1.5M6,3L4.5,4.5M1,7H6L4.5,5.5M6,7L4.5,8.5' }
};

// Category info for info popups
const CATEGORY_INFO = {
  'Compute': {
    desc: 'Application servers that handle business logic, request processing, and service orchestration.',
    role: 'The brain of your architecture — processes requests, runs business rules, and coordinates between services.',
    examples: 'Node.js, Go, Python FastAPI, Java Spring, Rust Actix',
    key: 'Choose based on I/O patterns (event-driven vs thread-per-request), ecosystem needs, and team expertise.'
  },
  'Data Storage': {
    desc: 'Persistent databases for structured data with ACID guarantees and complex query support.',
    role: 'The long-term memory — stores everything that needs to survive restarts: users, messages, settings.',
    examples: 'PostgreSQL, MongoDB, MySQL, CockroachDB, DynamoDB',
    key: 'Choose based on data model (relational vs document), consistency needs, and scaling requirements.'
  },
  'Caching': {
    desc: 'In-memory stores for fast data access, session management, and reducing database load.',
    role: 'The short-term memory — holds frequently accessed data close to compute for sub-millisecond reads.',
    examples: 'Redis, Memcached, KeyDB, Dragonfly',
    key: 'Choose based on data structure needs, persistence requirements, and cache invalidation strategy.'
  },
  'Messaging': {
    desc: 'Event streaming and message queue platforms for asynchronous, decoupled communication.',
    role: 'The nervous system — carries events between services without requiring them to be online simultaneously.',
    examples: 'Kafka, RabbitMQ, AWS SQS, Apache Pulsar, NATS',
    key: 'Choose based on ordering guarantees, throughput needs, and whether you need replay capability.'
  },
  'Delivery/Network': {
    desc: 'API gateways, load balancers, CDNs, and reverse proxies that route and manage network traffic.',
    role: 'The front door — manages how traffic enters your system, applies security policies, and distributes load.',
    examples: 'Nginx, AWS API Gateway, Kong, Traefik, CloudFront',
    key: 'Choose based on routing complexity, auth integration, and whether you need managed vs self-hosted.'
  },
  'Real-Time': {
    desc: 'WebSocket servers, SSE endpoints, and pub/sub systems for live data delivery to clients.',
    role: 'The live wire — pushes updates to clients instantly without polling, enabling chat and live dashboards.',
    examples: 'Socket.io, Pusher, Ably, Centrifugo, Phoenix Channels',
    key: 'Choose based on connection scale, message fanout patterns, and client platform requirements.'
  },
  'Auth/Security': {
    desc: 'Authentication providers, authorization engines, and security infrastructure.',
    role: 'The gatekeeper — verifies identity, enforces permissions, and protects data at rest and in transit.',
    examples: 'Auth0, Keycloak, AWS Cognito, custom JWT, OAuth2',
    key: 'Choose based on auth flow complexity (SSO, MFA), compliance requirements, and team capacity.'
  },
  'Monitoring': {
    desc: 'Observability platforms for metrics, logging, tracing, and alerting across your infrastructure.',
    role: 'The eyes and ears — shows what is happening, what broke, and why, before users report it.',
    examples: 'Datadog, Grafana, Prometheus, ELK Stack, Jaeger',
    key: 'Choose based on data volume, retention needs, and whether you need metrics, logs, traces, or all three.'
  },
  'Search': {
    desc: 'Full-text search engines and indexing systems for fast, relevance-ranked content retrieval.',
    role: 'The librarian — indexes your data for fast, fuzzy, and relevance-ranked search experiences.',
    examples: 'Elasticsearch, Algolia, Meilisearch, Typesense',
    key: 'Choose based on index size, query complexity, and whether you need analytics alongside search.'
  },
  'DevOps': {
    desc: 'CI/CD pipelines, container orchestration, infrastructure-as-code, and deployment automation.',
    role: 'The assembly line — automates building, testing, deploying, and scaling your applications.',
    examples: 'Docker, Kubernetes, Terraform, GitHub Actions, ArgoCD',
    key: 'Choose based on deployment frequency, infrastructure complexity, and team DevOps maturity.'
  }
};

// Dashboard metric category info
const DASHBOARD_INFO = {
  perf: {
    name: 'Performance',
    desc: 'How fast your architecture responds to requests and processes data.',
    metrics: 'Latency (p50/p95/p99), throughput (req/s), response time, TTFB',
    impact: 'Directly affects user experience. Every 100ms of added latency reduces conversion by ~1%. Bottlenecks cascade through connected components.',
    improve: 'Cache hot paths, reduce network hops, use connection pooling, optimize queries, consider async processing.'
  },
  cost: {
    name: 'Cost',
    desc: 'Total cost of ownership including infrastructure, licensing, operations, and engineering time.',
    metrics: 'Monthly infra cost, cost per request, license fees, maintenance hours',
    impact: 'Determines sustainability. Over-provisioning wastes money; under-provisioning causes outages.',
    improve: 'Right-size instances, use spot instances, optimize queries, consider serverless for bursty workloads.'
  },
  rel: {
    name: 'Reliability',
    desc: 'How well your architecture handles failures, maintains uptime, and recovers from incidents.',
    metrics: 'Uptime (99.9% = 8.7h/yr downtime), MTTR, error rates, failover success rate',
    impact: 'Trust and reputation. Every minute of downtime erodes user confidence. Requires redundancy.',
    improve: 'Add redundancy, circuit breakers, health checks, graceful degradation, chaos engineering.'
  },
  ops: {
    name: 'Operational Complexity',
    desc: 'How easy your architecture is to deploy, monitor, debug, and maintain day-to-day.',
    metrics: 'Deploy frequency, change failure rate, MTTR, on-call burden, runbook coverage',
    impact: 'Team productivity and morale. Complex ops mean slower shipping and more incidents.',
    improve: 'Automate deployments, improve observability, reduce moving parts, use managed services.'
  },
  scale: {
    name: 'Scalability',
    desc: 'How well your architecture grows with increasing users, data, and traffic.',
    metrics: 'Max concurrent users, horizontal scale factor, auto-scaling responsiveness',
    impact: 'Growth readiness. Non-scalable architectures force expensive rewrites.',
    improve: 'Stateless services, horizontal scaling, data partitioning, caching layers, queue decoupling.'
  },
  strat: {
    name: 'Strategic Flexibility',
    desc: 'Long-term flexibility including vendor independence, technology currency, and hiring.',
    metrics: 'Vendor lock-in score, technology freshness, community size, migration effort',
    impact: 'Future-proofing. Strategic debt accumulates silently until you need to pivot or hire.',
    improve: 'Use open standards, abstract vendor APIs, keep dependencies current, invest in documentation.'
  },
  dev: {
    name: 'Developer Experience',
    desc: 'How productive and happy developers are when building features and fixing bugs.',
    metrics: 'New dev setup time, build time, test feedback loop, debugging ease, docs quality',
    impact: 'Velocity and retention. Good DX means faster shipping. Bad DX means slow onboarding and turnover.',
    improve: 'Fast local setup, comprehensive tests, good docs, consistent patterns, fast CI/CD feedback.'
  }
};

// Code patterns per component + variant — shows WHAT changes at implementation level
const CODE_PATTERNS = {
  'bid-api': {
    'express': `<span class="cm">// Express: simple bid endpoint</span>
app.<span class="fn">post</span>(<span class="str">'/bid'</span>,
  <span class="fn">authMiddleware</span>,
  <span class="fn">validate</span>(bidSchema),
  <span class="kw">async</span> (req, res) => {
    <span class="kw">const</span> result = <span class="kw">await</span> engine.<span class="fn">validate</span>(req.body)
    res.<span class="fn">json</span>(result)
  })`,
    'fastify': `<span class="cm">// Fastify: schema-validated bids</span>
fastify.<span class="fn">post</span>(<span class="str">'/bid'</span>, {
  schema: { body: <span class="fn">bidSchema</span> },
  preHandler: [<span class="fn">authHook</span>]
}, <span class="kw">async</span> (req) => {
  <span class="kw">return</span> engine.<span class="fn">validate</span>(req.body)
  <span class="cm">// 2-3x faster than Express</span>
})`,
    'go-api': `<span class="cm">// Go: concurrent bid handling</span>
<span class="kw">func</span> <span class="fn">handleBid</span>(w http.ResponseWriter, r *http.Request) {
  <span class="kw">var</span> bid Bid
  json.<span class="fn">NewDecoder</span>(r.Body).<span class="fn">Decode</span>(&bid)
  result := engine.<span class="fn">Validate</span>(bid)
  json.<span class="fn">NewEncoder</span>(w).<span class="fn">Encode</span>(result)
}`
  },
  'auction-engine': {
    'sync-validation': `<span class="cm">// Sync: strong consistency, slow</span>
<span class="kw">async function</span> <span class="fn">validateBid</span>(bid) {
  <span class="kw">const</span> current = <span class="kw">await</span> db.<span class="fn">getCurrentBid</span>(bid.auctionId)
  <span class="kw">if</span> (bid.amount <= current.amount) {
    <span class="kw">throw</span> <span class="kw">new</span> <span class="fn">Error</span>(<span class="str">'Bid too low'</span>)
  }
  <span class="kw">await</span> db.<span class="fn">saveBid</span>(bid)
}`,
    'async-event': `<span class="cm">// Async: fast accept, eventual consistency</span>
<span class="kw">async function</span> <span class="fn">acceptBid</span>(bid) {
  <span class="kw">await</span> cache.<span class="fn">set</span>(bid.auctionId, bid)
  eventBus.<span class="fn">emit</span>(<span class="str">'bid.received'</span>, bid)
  <span class="cm">// Validation happens async</span>
  <span class="kw">return</span> { status: <span class="str">'accepted'</span> }
}`,
    'cqrs': `<span class="cm">// CQRS: write model + read model</span>
<span class="kw">async function</span> <span class="fn">handleCommand</span>(cmd) {
  <span class="kw">const</span> event = aggregate.<span class="fn">process</span>(cmd)
  <span class="kw">await</span> eventStore.<span class="fn">append</span>(event)
  <span class="kw">await</span> readModel.<span class="fn">update</span>(event)
  <span class="cm">// Separate read/write paths</span>
}`
  },
  'payment-service': {
    'sync-stripe': `<span class="cm">// Sync Stripe: immediate response</span>
<span class="kw">const</span> charge = <span class="kw">await</span> stripe.charges.<span class="fn">create</span>({
  amount: bid.amount,
  currency: <span class="str">'usd'</span>,
  source: user.paymentMethod
})
<span class="kw">return</span> { status: <span class="str">'charged'</span>, id: charge.id }`,
    'async-queue': `<span class="cm">// Async: queue payment, webhook confirm</span>
<span class="kw">await</span> queue.<span class="fn">publish</span>(<span class="str">'payment.pending'</span>, {
  bidId: bid.id,
  amount: bid.amount
})
<span class="cm">// Webhook handles confirmation</span>
<span class="kw">return</span> { status: <span class="str">'pending'</span> }`,
    'saga-orchestrator': `<span class="cm">// Saga: centralized coordination</span>
<span class="kw">const</span> saga = <span class="kw">new</span> <span class="fn">PaymentSaga</span>(bid)
<span class="kw">await</span> saga.<span class="fn">reserve</span>()
<span class="kw">await</span> saga.<span class="fn">charge</span>()
<span class="kw">await</span> saga.<span class="fn">confirm</span>()
<span class="cm">// Rollback on any failure</span>`
  },
  'notification-service': {
    'email-smtp': `<span class="cm">// Email: SMTP delivery</span>
<span class="kw">await</span> transporter.<span class="fn">sendMail</span>({
  to: user.email,
  subject: <span class="str">'Bid Confirmation'</span>,
  html: template.<span class="fn">render</span>(bid)
})`,
    'push-websocket': `<span class="cm">// WebSocket: real-time push</span>
<span class="kw">const</span> socket = sockets.<span class="fn">get</span>(user.id)
<span class="kw">if</span> (socket) {
  socket.<span class="fn">emit</span>(<span class="str">'bid.confirmed'</span>, bid)
}`,
    'multi-channel': `<span class="cm">// Multi-channel: email + SMS + push</span>
<span class="kw">await</span> Promise.<span class="fn">all</span>([
  email.<span class="fn">send</span>(user.email, bid),
  sms.<span class="fn">send</span>(user.phone, bid),
  push.<span class="fn">send</span>(user.deviceId, bid)
])`
  },
  'event-bus': {
    'kafka': `<span class="cm">// Kafka: durable event streaming</span>
producer.<span class="fn">send</span>({
  topic: <span class="str">'bids'</span>,
  key: bid.auctionId,
  value: <span class="fn">JSON.stringify</span>(bid)
})`,
    'rabbitmq': `<span class="cm">// RabbitMQ: routing + fanout</span>
channel.<span class="fn">publish</span>(
  <span class="str">'bids'</span>,
  <span class="str">'bid.created'</span>,
  Buffer.<span class="fn">from</span>(<span class="fn">JSON.stringify</span>(bid))
)`,
    'aws-eventbridge': `<span class="cm">// EventBridge: managed routing</span>
<span class="kw">await</span> events.<span class="fn">putEvents</span>({
  Entries: [{
    Source: <span class="str">'auction.bids'</span>,
    DetailType: <span class="str">'BidCreated'</span>,
    Detail: <span class="fn">JSON.stringify</span>(bid)
  }]
})`
  },
  'bid-store': {
    'postgresql': `<span class="cm">-- PostgreSQL: relational bids</span>
<span class="kw">INSERT INTO</span> bids (auction_id, bidder_id, amount)
<span class="kw">VALUES</span> (<span class="num">?</span>, <span class="num">?</span>, <span class="num">?</span>)
<span class="kw">RETURNING</span> *`,
    'redis-postgresql': `<span class="cm">// Redis + PostgreSQL: hybrid</span>
<span class="kw">await</span> redis.<span class="fn">zadd</span>(
  <span class="str">\`auction:\${id}:bids\`</span>,
  bid.amount, bid.id
)
<span class="kw">await</span> db.<span class="fn">saveBid</span>(bid)`,
    'event-store': `<span class="cm">// Event Store: append-only log</span>
<span class="kw">await</span> eventStore.<span class="fn">appendToStream</span>(
  <span class="str">\`auction-\${id}\`</span>,
  [{ type: <span class="str">'BidPlaced'</span>, data: bid }]
)`
  },
  'cache-layer': {
    'redis': `<span class="cm">// Redis: sorted set for top bids</span>
<span class="kw">await</span> redis.<span class="fn">zadd</span>(
  <span class="str">\`auction:\${id}:bids\`</span>,
  bid.amount, bid.id
)`,
    'memcached': `<span class="cm">// Memcached: simple key-value</span>
<span class="kw">await</span> cache.<span class="fn">set</span>(
  <span class="str">\`bid:\${id}\`</span>,
  bid, <span class="num">300</span>
)`,
    'local-cache': `<span class="cm">// Local: in-memory Map</span>
<span class="kw">const</span> cache = <span class="kw">new</span> <span class="fn">Map</span>()
cache.<span class="fn">set</span>(bid.id, bid)`
  }
};

// ═══════════════ DATA ═══════════════
const CATEGORIES = {
  'Compute':          { color: '#3b82f6', shape: 'rectangle' },
  'Data Storage':     { color: '#22c55e', shape: 'cylinder' },
  'Caching':          { color: '#f97316', shape: 'pill' },
  'Messaging':        { color: '#a855f7', shape: 'hexish' },
  'Delivery/Network': { color: '#06b6d4', shape: 'stadium' },
  'Real-Time':        { color: '#ec4899', shape: 'pill' },
  'Auth/Security':    { color: '#ef4444', shape: 'rectangle' },
  'Monitoring':       { color: '#eab308', shape: 'stadium' },
  'Search':           { color: '#14b8a6', shape: 'pill' },
  'DevOps':           { color: '#8b5cf6', shape: 'hexish' }
};

const components = {
  'bid-api': {
    name: 'Bid API', category: 'Compute',
    is: 'HTTP API accepting bid submissions from clients',
    gain: 'Fast request handling, low latency, familiar patterns',
    cost: 'Coordination complexity with auction engine',
    position: { x: 330, y: 20 },
    heatStatus: 'green',
    connections: [
      { target: 'auction-engine', label: 'HTTP', connType: 'http', protocol: 'HTTP/1.1', pattern: 'Request → Validate → Response',
        direction: 'Bid API forwards bids to auction engine for validation',
        role: 'API Gateway',
        summary: 'The Bid API receives POST /bid requests, validates authentication and schema, then forwards to the auction engine for bid validation. The engine returns accept/reject immediately (sync) or via event (async).',
        latency: '~2-10ms (depends on engine variant)', colocatable: true,
        code: `<span class="cm">// Bid API → Auction Engine</span>\n<span class="kw">const</span> result = <span class="kw">await</span> axios.<span class="fn">post</span>(\n  <span class="str">'http://engine:3001/validate'</span>,\n  { auctionId, bidderId, amount }\n)\n<span class="kw">return</span> result.data` },
      { target: 'cache-layer', label: 'RESP', connType: 'cache', protocol: 'RESP (Redis)', pattern: 'GET/SET → Cache',
        direction: 'Bid API caches current highest bid for quick lookups',
        role: 'Read Cache',
        summary: 'Before validating a bid, the API checks Redis for the current highest bid to provide instant feedback. This reduces database load and speeds up the hot path.',
        latency: '~0.5ms (co-located)', colocatable: true,
        code: `<span class="cm">// Bid API → Redis Cache</span>\n<span class="kw">const</span> current = <span class="kw">await</span> redis.<span class="fn">get</span>(\n  <span class="str">\`auction:\${id}:top\`</span>\n)\n<span class="kw">if</span> (bid.amount <= current) {\n  <span class="kw">return</span> { error: <span class="str">'Too low'</span> }\n}` },
      { target: 'event-bus', label: 'Produce', connType: 'queue', protocol: 'Kafka Binary', pattern: 'Produce → Ack',
        direction: 'Bid API produces bid events to event bus',
        role: 'Event Producer',
        summary: 'After accepting a bid, the API publishes a bid.received event to Kafka for async processing by payment, notification, and analytics services.',
        latency: '~5-15ms (broker ack)', colocatable: false,
        code: `<span class="cm">// Bid API → Kafka</span>\n<span class="kw">await</span> producer.<span class="fn">send</span>({\n  topic: <span class="str">'bids'</span>,\n  key: auctionId,\n  value: <span class="fn">JSON.stringify</span>(bid)\n})` }
    ],
    dataContext: [
      { name: 'POST /bid', icon: 'endpoint', behaviors: {
        'express': { fit: 'good', note: 'Simple routing, manual validation' },
        'fastify': { fit: 'great', note: 'Schema-validated, 2-3x faster' },
        'go-api': { fit: 'great', note: 'Concurrent, low overhead' }
      }},
      { name: 'GET /auction/:id', icon: 'endpoint', behaviors: {
        'express': { fit: 'good', note: 'Straightforward REST endpoint' },
        'fastify': { fit: 'great', note: 'Optimized serialization' },
        'go-api': { fit: 'good', note: 'Fast JSON encoding' }
      }},
      { name: 'WebSocket /live', icon: 'websocket', behaviors: {
        'express': { fit: 'tradeoff', note: 'Socket.io works but adds overhead' },
        'fastify': { fit: 'good', note: 'WebSocket plugin available' },
        'go-api': { fit: 'great', note: 'Gorilla WebSocket, excellent concurrency' }
      }}
    ],
    variants: {
      'express': { label: 'Express.js',
        metrics: { 'Latency': 72, 'Throughput': 68, 'Cost Efficiency': 90, 'Op. Simplicity': 85, 'Reliability': 65, 'Portability': 95, 'Learning Curve': 90 },
        pros: ['Minimal footprint','Huge ecosystem','Easy to learn'], cons: ['No built-in validation','Manual structure'] },
      'fastify': { label: 'Fastify',
        metrics: { 'Latency': 88, 'Throughput': 85, 'Cost Efficiency': 88, 'Op. Simplicity': 70, 'Reliability': 72, 'Portability': 92, 'Learning Curve': 70 },
        pros: ['2-3x faster','Schema validation','Plugin system'], cons: ['Smaller ecosystem','Different patterns'] },
      'go-api': { label: 'Go API',
        metrics: { 'Latency': 92, 'Throughput': 90, 'Cost Efficiency': 85, 'Op. Simplicity': 65, 'Reliability': 78, 'Portability': 88, 'Learning Curve': 60 },
        pros: ['Concurrent','Low latency','Type-safe'], cons: ['Steeper learning curve','Less flexible'] }
    },
    currentVariant: 'fastify'
  },
  'auction-engine': {
    name: 'Auction Engine', category: 'Compute',
    is: 'Core bid validation and auction state management — STAR COMPONENT',
    gain: 'Centralized validation, consistent rules, state machine control',
    cost: 'Sync vs async trade-off: consistency vs speed, orchestration vs choreography complexity',
    position: { x: 330, y: 170 },
    heatStatus: 'red',
    connections: [
      { target: 'bid-store', label: 'TCP/pg', connType: 'database', protocol: 'PostgreSQL Wire Protocol', pattern: 'Persist Bid → Ack',
        direction: 'Auction engine persists validated bids to the bid store',
        role: 'Durable Storage',
        summary: 'After validating a bid (sync mode) or processing an event (async mode), the engine writes the bid to PostgreSQL for permanent storage. Sync variant blocks on DB write, async variant writes after event processing.',
        latency: '~2-8ms (write + index update)', colocatable: true,
        code: `<span class="cm">// Auction Engine → Bid Store</span>\n<span class="kw">await</span> db.<span class="fn">query</span>(\n  <span class="str">'INSERT INTO bids (auction_id, bidder_id, amount) VALUES ($1, $2, $3)'</span>,\n  [bid.auctionId, bid.bidderId, bid.amount]\n)` },
      { target: 'event-bus', label: 'Produce', connType: 'queue', protocol: 'Kafka Binary', pattern: 'Emit Event → Ack',
        direction: 'Auction engine emits auction events (bid.validated, auction.closed)',
        role: 'Event Emitter',
        summary: 'The engine publishes events for downstream services: bid.validated triggers payment processing, auction.closed triggers winner notification. Event-driven variant emits continuously, sync variant emits only after DB commit.',
        latency: '~5-15ms (broker ack)', colocatable: false,
        code: `<span class="cm">// Auction Engine → Event Bus</span>\n<span class="kw">await</span> producer.<span class="fn">send</span>({\n  topic: <span class="str">'auction-events'</span>,\n  key: bid.auctionId,\n  value: <span class="fn">JSON.stringify</span>({ type: <span class="str">'bid.validated'</span>, bid })\n})` }
    ],
    dataContext: [
      { name: 'Bid Validation', icon: 'endpoint', behaviors: {
        'sync-validation': { fit: 'great', note: 'Strong consistency, no phantom bids, but latency spike under load' },
        'async-event': { fit: 'tradeoff', note: 'Sub-10ms response, but eventual consistency — last-second conflicts possible' },
        'cqrs': { fit: 'good', note: 'Optimized reads, event sourcing, but operational complexity' }
      }},
      { name: 'Auction State Machine', icon: 'state', behaviors: {
        'sync-validation': { fit: 'good', note: 'State transitions are ACID-compliant' },
        'async-event': { fit: 'tradeoff', note: 'State eventually consistent, compensating actions needed' },
        'cqrs': { fit: 'great', note: 'Event-sourced state, full audit trail' }
      }},
      { name: 'Winner Determination', icon: 'winner', behaviors: {
        'sync-validation': { fit: 'great', note: 'Deterministic, immediate DB query for highest bid' },
        'async-event': { fit: 'tradeoff', note: 'May need conflict resolution if async bids collide' },
        'cqrs': { fit: 'great', note: 'Read model pre-computed, instant winner lookup' }
      }}
    ],
    variants: {
      'sync-validation': { label: 'Synchronous Validation',
        metrics: { 'Latency': 40, 'Throughput': 55, 'Scalability': 45, 'Consistency': 95, 'Op. Simplicity': 70, 'Reliability': 85, 'Learning Curve': 72 },
        pros: ['Strong consistency','No phantom bids','Simple reasoning'], cons: ['Latency spike under load','Lower throughput','DB becomes bottleneck'] },
      'async-event': { label: 'Async Event-Driven',
        metrics: { 'Latency': 90, 'Throughput': 88, 'Scalability': 85, 'Consistency': 40, 'Op. Simplicity': 45, 'Reliability': 60, 'Learning Curve': 45 },
        pros: ['Sub-10ms bid acceptance','High throughput','Decoupled services'], cons: ['Eventual consistency','Last-second conflicts','Compensating transactions needed'] },
      'cqrs': { label: 'CQRS Pattern',
        metrics: { 'Latency': 75, 'Throughput': 82, 'Scalability': 80, 'Consistency': 65, 'Op. Simplicity': 25, 'Reliability': 70, 'Learning Curve': 25 },
        pros: ['Optimized reads','Event sourcing','Audit trail'], cons: ['Operational complexity','Read/write lag','Steep learning curve'] }
    },
    currentVariant: 'sync-validation'
  },
  'payment-service': {
    name: 'Payment Service', category: 'Compute',
    is: 'Handles payment processing, escrow, and refunds',
    gain: 'Decoupled payment logic, saga coordination, failure recovery',
    cost: 'Orchestration vs choreography trade-off, distributed transaction complexity',
    position: { x: 80, y: 320 },
    heatStatus: 'yellow',
    connections: [
      { target: 'event-bus', label: 'Consume', connType: 'queue', protocol: 'Kafka Binary', pattern: 'Poll → Process → Ack',
        direction: 'Payment service consumes payment events from event bus',
        role: 'Event Consumer',
        summary: 'The payment service subscribes to bid.validated events, processes Stripe charges, and emits payment.confirmed or payment.failed events back to the bus. Saga orchestrator variant centralizes this flow.',
        latency: '~50-200ms (Stripe API call)', colocatable: false,
        code: `<span class="cm">// Payment Service ← Event Bus</span>\n<span class="kw">await</span> consumer.<span class="fn">run</span>({\n  <span class="fn">eachMessage</span>: <span class="kw">async</span> ({ message }) => {\n    <span class="kw">const</span> bid = <span class="fn">JSON.parse</span>(message.value)\n    <span class="kw">await</span> stripe.charges.<span class="fn">create</span>(bid)\n  }\n})` }
    ],
    dataContext: [
      { name: 'Payment Processing', icon: 'payment', behaviors: {
        'sync-stripe': { fit: 'good', note: 'Immediate confirmation, but blocks caller' },
        'async-queue': { fit: 'great', note: 'Fast async, webhook confirms, eventual consistency' },
        'saga-orchestrator': { fit: 'great', note: 'Centralized control, easy debug, but SPOF risk' }
      }},
      { name: 'Refund Handling', icon: 'refund', behaviors: {
        'sync-stripe': { fit: 'good', note: 'Immediate refund API call' },
        'async-queue': { fit: 'tradeoff', note: 'Async refund, compensating transaction needed' },
        'saga-orchestrator': { fit: 'great', note: 'Saga rolls back payment step automatically' }
      }},
      { name: 'Escrow Management', icon: 'escrow', behaviors: {
        'sync-stripe': { fit: 'tradeoff', note: 'Manual escrow state tracking' },
        'async-queue': { fit: 'good', note: 'Event-driven escrow release on auction close' },
        'saga-orchestrator': { fit: 'great', note: 'Saga coordinates escrow → release → confirm steps' }
      }}
    ],
    variants: {
      'sync-stripe': { label: 'Sync Stripe SDK',
        metrics: { 'Latency': 45, 'Throughput': 60, 'Cost Efficiency': 70, 'Op. Simplicity': 75, 'Reliability': 80, 'Portability': 65, 'Learning Curve': 80 },
        pros: ['Immediate confirmation','Simple sync flow','Easy to reason about'], cons: ['Blocks caller','Stripe timeout = failed bid','Not horizontally scalable'] },
      'async-queue': { label: 'Async Queue + Webhook',
        metrics: { 'Latency': 80, 'Throughput': 85, 'Cost Efficiency': 75, 'Op. Simplicity': 55, 'Reliability': 70, 'Portability': 80, 'Learning Curve': 60 },
        pros: ['Fast async accept','Webhook confirms','Decoupled from bid API'], cons: ['Eventual consistency','Webhook delivery not guaranteed','More moving parts'] },
      'saga-orchestrator': { label: 'Saga Orchestrator',
        metrics: { 'Latency': 70, 'Throughput': 75, 'Cost Efficiency': 65, 'Op. Simplicity': 40, 'Reliability': 65, 'Portability': 70, 'Learning Curve': 35 },
        pros: ['Centralized control','Auto-rollback on failure','Easy to debug'], cons: ['SPOF risk','Complex state machine','Orchestrator becomes bottleneck'] }
    },
    currentVariant: 'sync-stripe'
  },
  'notification-service': {
    name: 'Notification Service', category: 'Compute',
    is: 'Sends bid confirmations, outbid alerts, auction end notifications',
    gain: 'Decoupled notification logic, multi-channel support',
    cost: 'Delivery guarantees, idempotency, rate limiting needed',
    position: { x: 580, y: 320 },
    heatStatus: 'green',
    connections: [],
    dataContext: [
      { name: 'Bid Confirmations', icon: 'notification', behaviors: {
        'email-smtp': { fit: 'good', note: 'Standard email delivery, reliable but slow' },
        'push-websocket': { fit: 'great', note: 'Instant push to connected clients, real-time feedback' },
        'multi-channel': { fit: 'great', note: 'Email + SMS + Push for critical bid confirmations' }
      }},
      { name: 'Outbid Alerts', icon: 'alert', behaviors: {
        'email-smtp': { fit: 'tradeoff', note: 'Email delay = user finds out late they were outbid' },
        'push-websocket': { fit: 'great', note: 'Instant alert, user can immediately counter-bid' },
        'multi-channel': { fit: 'good', note: 'Multi-channel for important alerts, but cost adds up' }
      }},
      { name: 'Auction End Notifications', icon: 'end', behaviors: {
        'email-smtp': { fit: 'great', note: 'Email is expected for auction close summary' },
        'push-websocket': { fit: 'good', note: 'Real-time notification if user is online' },
        'multi-channel': { fit: 'great', note: 'Email for record, push for immediacy' }
      }}
    ],
    variants: {
      'email-smtp': { label: 'Email SMTP',
        metrics: { 'Latency': 70, 'Throughput': 75, 'Cost Efficiency': 85, 'Op. Simplicity': 80, 'Reliability': 75, 'Portability': 90, 'Learning Curve': 85 },
        pros: ['Standard protocol','High deliverability','Reliable record'], cons: ['Slow delivery (seconds to minutes)','No real-time feedback','SMTP config complexity'] },
      'push-websocket': { label: 'Push WebSocket',
        metrics: { 'Latency': 95, 'Throughput': 80, 'Cost Efficiency': 75, 'Op. Simplicity': 60, 'Reliability': 65, 'Portability': 70, 'Learning Curve': 65 },
        pros: ['Instant delivery','Real-time bidirectional','Low latency'], cons: ['Only works for connected clients','Websocket state management','No delivery guarantee for offline users'] },
      'multi-channel': { label: 'Multi-Channel',
        metrics: { 'Latency': 85, 'Throughput': 70, 'Cost Efficiency': 50, 'Op. Simplicity': 45, 'Reliability': 80, 'Portability': 75, 'Learning Curve': 55 },
        pros: ['Redundant delivery','Real-time + durable record','Reaches offline users'], cons: ['Higher cost (SMS)','Complex coordination','Idempotency critical (avoid duplicate notifications)'] }
    },
    currentVariant: 'email-smtp'
  },
  'event-bus': {
    name: 'Event Bus', category: 'Messaging',
    is: 'Central event bus for async service communication',
    gain: 'Decoupled services, async processing, event replay',
    cost: 'Ordering guarantees, exactly-once semantics, operational overhead',
    position: { x: 330, y: 320 },
    heatStatus: 'yellow',
    connections: [
      { target: 'payment-service', label: 'Deliver', connType: 'queue', protocol: 'Kafka Binary', pattern: 'Deliver Event → Process → Ack',
        direction: 'Event bus delivers bid events to payment service',
        role: 'Event Delivery',
        summary: 'The event bus delivers bid.validated events to the payment service consumer group. Payment service processes Stripe charges and emits payment.confirmed back to the bus.',
        latency: '~5-20ms (poll interval)', colocatable: false,
        code: `<span class="cm">// Event Bus → Payment Service</span>\n<span class="kw">await</span> consumer.<span class="fn">subscribe</span>({ topic: <span class="str">'auction-events'</span> })\n<span class="kw">await</span> consumer.<span class="fn">run</span>({\n  <span class="fn">eachMessage</span>: <span class="kw">async</span> ({ message }) => {\n    <span class="kw">await</span> <span class="fn">processPayment</span>(message)\n  }\n})` },
      { target: 'notification-service', label: 'Deliver', connType: 'queue', protocol: 'Kafka Binary', pattern: 'Deliver Event → Notify',
        direction: 'Event bus delivers events to notification service',
        role: 'Event Delivery',
        summary: 'Notification service subscribes to bid.validated, bid.outbid, and auction.closed events, then sends emails, push notifications, or SMS to users.',
        latency: '~5-20ms (poll interval)', colocatable: false,
        code: `<span class="cm">// Event Bus → Notification Service</span>\n<span class="kw">await</span> consumer.<span class="fn">subscribe</span>({ topics: [<span class="str">'bids'</span>, <span class="str">'auctions'</span>] })\n<span class="kw">await</span> consumer.<span class="fn">run</span>({\n  <span class="fn">eachMessage</span>: <span class="kw">async</span> ({ topic, message }) => {\n    <span class="kw">await</span> <span class="fn">sendNotification</span>(message)\n  }\n})` }
    ],
    dataContext: [
      { name: 'Bid Events', icon: 'message', behaviors: {
        'kafka': { fit: 'great', note: 'Durable, high throughput, replay capability' },
        'rabbitmq': { fit: 'good', note: 'Flexible routing, easier ops, but lower throughput' },
        'aws-eventbridge': { fit: 'good', note: 'Managed, schema registry, but vendor lock-in' }
      }},
      { name: 'Auction Events', icon: 'event', behaviors: {
        'kafka': { fit: 'great', note: 'Event sourcing natural fit, ordered per auction' },
        'rabbitmq': { fit: 'good', note: 'Topic exchange for fanout, but no replay' },
        'aws-eventbridge': { fit: 'great', note: 'Event pattern matching, managed routing' }
      }},
      { name: 'Payment Events', icon: 'payment', behaviors: {
        'kafka': { fit: 'good', note: 'Durable for audit trail, but eventual delivery' },
        'rabbitmq': { fit: 'great', note: 'DLQ for failed payments, retry policies' },
        'aws-eventbridge': { fit: 'good', note: 'Managed retries, SQS DLQ integration' }
      }}
    ],
    variants: {
      'kafka': { label: 'Kafka',
        metrics: { 'Throughput': 92, 'Ordering': 75, 'Scalability': 90, 'Op. Simplicity': 40, 'Reliability': 85, 'Portability': 75, 'Learning Curve': 35 },
        pros: ['High throughput','Durable log','Event replay'], cons: ['Zookeeper dependency','Complex ops','Steep learning curve'] },
      'rabbitmq': { label: 'RabbitMQ',
        metrics: { 'Throughput': 75, 'Ordering': 80, 'Scalability': 70, 'Op. Simplicity': 65, 'Reliability': 80, 'Portability': 85, 'Learning Curve': 60 },
        pros: ['Flexible routing','DLQ support','Easier ops'], cons: ['Lower throughput','No replay','Clustering complexity'] },
      'aws-eventbridge': { label: 'AWS EventBridge',
        metrics: { 'Throughput': 70, 'Ordering': 60, 'Scalability': 85, 'Op. Simplicity': 90, 'Reliability': 88, 'Portability': 30, 'Learning Curve': 75 },
        pros: ['Fully managed','Pattern matching','Schema registry'], cons: ['Vendor lock-in','Cost at scale','Limited throughput'] }
    },
    currentVariant: 'kafka'
  },
  'bid-store': {
    name: 'Bid Store', category: 'Data Storage',
    is: 'Persistent storage for all bid records and auction state',
    gain: 'ACID guarantees, relational queries, audit trail',
    cost: 'Write latency under high load, scaling limits',
    position: { x: 80, y: 470 },
    heatStatus: 'green',
    connections: [],
    dataContext: [
      { name: 'Bid Records', icon: 'table', behaviors: {
        'postgresql': { fit: 'great', note: 'Relational integrity, foreign keys, transactions' },
        'redis-postgresql': { fit: 'great', note: 'Redis for top bids, PostgreSQL for durability' },
        'event-store': { fit: 'good', note: 'Full audit trail, but query complexity' }
      }},
      { name: 'Auction State', icon: 'state', behaviors: {
        'postgresql': { fit: 'good', note: 'Standard relational model, easy queries' },
        'redis-postgresql': { fit: 'great', note: 'Redis sorted set for leaderboard + DB persistence' },
        'event-store': { fit: 'great', note: 'Event-sourced aggregate, full state history' }
      }},
      { name: 'Bid History', icon: 'history', behaviors: {
        'postgresql': { fit: 'great', note: 'Standard append-only table with indexes' },
        'redis-postgresql': { fit: 'good', note: 'Recent bids in Redis, full history in DB' },
        'event-store': { fit: 'great', note: 'Append-only log is natural fit' }
      }}
    ],
    variants: {
      'postgresql': { label: 'PostgreSQL',
        metrics: { 'Read Perf': 75, 'Write Perf': 80, 'Scalability': 60, 'Consistency': 95, 'Op. Simplicity': 70, 'Reliability': 90, 'Learning Curve': 75 },
        pros: ['ACID guarantees','Relational queries','Mature'], cons: ['Write bottleneck under load','Vertical scaling limits'] },
      'redis-postgresql': { label: 'Redis + PostgreSQL',
        metrics: { 'Read Perf': 92, 'Write Perf': 85, 'Scalability': 75, 'Consistency': 80, 'Op. Simplicity': 50, 'Reliability': 80, 'Learning Curve': 60 },
        pros: ['Fast reads (Redis)','Durable writes (PostgreSQL)','Leaderboard optimized'], cons: ['Dual-write complexity','Cache invalidation','Higher ops burden'] },
      'event-store': { label: 'Event Store',
        metrics: { 'Read Perf': 70, 'Write Perf': 90, 'Scalability': 80, 'Consistency': 90, 'Op. Simplicity': 35, 'Reliability': 85, 'Learning Curve': 30 },
        pros: ['Append-only (fast writes)','Full audit trail','Event sourcing'], cons: ['Query complexity','Read model lag','Steep learning curve'] }
    },
    currentVariant: 'postgresql'
  },
  'cache-layer': {
    name: 'Cache Layer', category: 'Caching',
    is: 'In-memory cache for current bids, active auctions, sessions',
    gain: 'Sub-millisecond reads, reduced database load',
    cost: 'Memory cost, cache invalidation, consistency trade-offs',
    position: { x: 580, y: 470 },
    heatStatus: 'green',
    connections: [],
    dataContext: [
      { name: 'Current Highest Bid', icon: 'cache_item', behaviors: {
        'redis': { fit: 'great', note: 'Sorted set for top bids, fast ZRANGE lookups' },
        'memcached': { fit: 'tradeoff', note: 'Simple key-value, no sorted sets' },
        'local-cache': { fit: 'poor', note: 'Not distributed, stale across instances' }
      }},
      { name: 'Active Auction List', icon: 'list', behaviors: {
        'redis': { fit: 'great', note: 'Redis SET for active auctions, fast membership tests' },
        'memcached': { fit: 'good', note: 'Key per auction, simple get/set' },
        'local-cache': { fit: 'poor', note: 'Stale list, no cross-instance sync' }
      }},
      { name: 'Bidder Sessions', icon: 'session', behaviors: {
        'redis': { fit: 'great', note: 'TTL-based session expiry, native support' },
        'memcached': { fit: 'great', note: 'TTL expiry, simpler than Redis' },
        'local-cache': { fit: 'poor', note: 'Sessions not portable across instances' }
      }}
    ],
    variants: {
      'redis': { label: 'Redis',
        metrics: { 'Read Perf': 95, 'Write Perf': 90, 'Scalability': 80, 'Cost Efficiency': 65, 'Op. Simplicity': 65, 'Reliability': 75, 'Learning Curve': 70 },
        pros: ['Rich data structures','Sorted sets for leaderboards','Pub/sub support'], cons: ['Memory cost','Persistence trade-offs','Clustering complexity'] },
      'memcached': { label: 'Memcached',
        metrics: { 'Read Perf': 95, 'Write Perf': 92, 'Scalability': 85, 'Cost Efficiency': 75, 'Op. Simplicity': 80, 'Reliability': 70, 'Learning Curve': 85 },
        pros: ['Simpler than Redis','High throughput','Low ops overhead'], cons: ['No sorted sets','No persistence','Limited data types'] },
      'local-cache': { label: 'Local In-Memory',
        metrics: { 'Read Perf': 98, 'Write Perf': 95, 'Scalability': 40, 'Cost Efficiency': 95, 'Op. Simplicity': 90, 'Reliability': 50, 'Learning Curve': 95 },
        pros: ['Zero latency','No network hop','Simple'], cons: ['Not distributed','Stale data across instances','No failover'] }
    },
    currentVariant: 'redis'
  }
};

const dashboardCategories = [
  { name: 'Perf', key: 'perf', icon: 'perf' },
  { name: 'Cost', key: 'cost', icon: 'cost_dash' },
  { name: 'Reliab', key: 'rel', icon: 'rel' },
  { name: 'Ops', key: 'ops', icon: 'ops' },
  { name: 'Scale', key: 'scale', icon: 'scale' },
  { name: 'Strat', key: 'strat', icon: 'strat' },
  { name: 'Dev', key: 'dev', icon: 'dev_dash' }
];

// Maps each component metric to a dashboard category key
const METRIC_TO_CATEGORY = {
  'Latency': 'perf',
  'Throughput': 'perf',
  'Read Perf': 'perf',
  'Write Perf': 'perf',
  'Cost Efficiency': 'cost',
  'Reliability': 'rel',
  'Consistency': 'rel',
  'Ordering': 'rel',
  'Op. Simplicity': 'ops',
  'Scalability': 'scale',
  'Portability': 'strat',
  'Learning Curve': 'dev'
};

// ═══════════════ STATE ═══════════════
const state = {
  selectedNode: null,
  selectedConnection: null, // { sourceId, targetId }
  heatmapEnabled: false,
  toolboxTab: 'components',
  swapOpenNode: null,
  variantOpenNode: null,
  // Node drag state
  dragging: null,    // node id being dragged
  dragStart: null,   // { mx, my, nx, ny } mouse + node start positions
  dragMoved: false,  // true if mouse actually moved (to distinguish click vs drag)
  // Connection label drag state
  draggingConn: null,  // { sourceId, targetId, connIdx }
  connDragStart: null, // { mx, my, ox, oy } mouse + original offset
  // Collapsible section state
  collapsedSections: new Set(),
  lastDeltas: {},
  deltaTimeout: null,
  issuesOpen: false,
  flowParticles: [],
  flowAnimationId: null,
  hiddenMetrics: new Set(['Reliability', 'Portability', 'Learning Curve']),
  metricFilterOpen: false,
  inspSwapOpen: false,
  inspVariantOpen: false,
  dashboardExpanded: false
};
let connectionPathData = [];

// ═══════════════ HELPER FUNCTIONS ═══════════════

function getMetricColor(value) {
  if (value >= 70) return 'var(--green)';
  if (value >= 40) return 'var(--yellow)';
  return 'var(--red)';
}

function getHeatColor(status) {
  if (status === 'green') return 'var(--green)';
  if (status === 'yellow') return 'var(--yellow)';
  return 'var(--red)';
}

function getConnectionHealth(srcId, tgtId) {
  const src = components[srcId];
  const tgt = components[tgtId];
  // Worst of the two endpoints
  const priority = { 'red': 0, 'yellow': 1, 'green': 2 };
  return priority[src.heatStatus] <= priority[tgt.heatStatus] ? src.heatStatus : tgt.heatStatus;
}

const HEALTH_LABELS = {
  green: { label: 'Healthy', color: 'var(--green)', icon: 'gain',
    desc: 'Both endpoints are performing well. This connection is not a bottleneck — data flows efficiently between these components.' },
  yellow: { label: 'Warning', color: 'var(--yellow)', icon: 'Monitoring',
    desc: 'One or both endpoints have degraded metrics. This connection may become a bottleneck under load. Consider optimizing the weaker endpoint or adjusting its configuration variant.' },
  red: { label: 'Bottleneck', color: 'var(--red)', icon: 'cons',
    desc: 'One or both endpoints are critically underperforming. This connection is likely a system bottleneck. The weakest endpoint constrains the entire path — improving it will have the most impact.' }
};

function buildEndpointMetricDetail(nodeId, panelId) {
  const c = components[nodeId];
  const metrics = c.variants[c.currentVariant].metrics;
  const entries = Object.entries(metrics);
  const belowThreshold = entries.filter(([, v]) => v < 70);
  const causeText = belowThreshold.length === 0
    ? '<div style="font-size:10px;color:var(--green);margin-bottom:4px">All metrics above threshold</div>'
    : `<div class="conn-health-metrics-label">${belowThreshold.length} metric${belowThreshold.length > 1 ? 's' : ''} below threshold (70)</div>`;
  return `<div class="conn-health-metrics" id="${panelId}">
    ${causeText}
    ${entries.map(([name, val]) => {
      const color = getMetricColor(val);
      const isCause = val < 70;
      return `<div class="conn-health-metric-row">
        <span class="conn-health-metric-flag" style="color:${isCause ? 'var(--red)' : 'transparent'}">${isCause ? '!' : ''}</span>
        <span class="conn-health-metric-name" style="${isCause ? 'color:var(--text-primary);font-weight:500' : ''}">${name}</span>
        <div class="conn-health-metric-bar">
          <div class="conn-health-metric-fill" style="width:${val}%;background:${color}"></div>
        </div>
        <span class="conn-health-metric-val" style="color:${color}">${val}</span>
      </div>`;
    }).join('')}
  </div>`;
}

function toggleConnHealthDetail(panelId, event) {
  if (event) event.stopPropagation();
  const el = document.getElementById(panelId);
  if (el) el.classList.toggle('visible');
}

function renderConnectionHealth(srcId, tgtId) {
  const health = getConnectionHealth(srcId, tgtId);
  const h = HEALTH_LABELS[health];
  const src = components[srcId];
  const tgt = components[tgtId];
  const srcH = HEALTH_LABELS[src.heatStatus];
  const tgtH = HEALTH_LABELS[tgt.heatStatus];
  const infoIcon = `<svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><circle cx="8" cy="8" r="6"/><path d="M8 7v4M8 5v.5"/></svg>`;
  const content = `<div class="conn-health-indicator">
      <div class="conn-health-badge" style="background:${h.color}20;color:${h.color};border:1px solid ${h.color}40">
        <span class="conn-health-dot" style="background:${h.color}"></span> ${h.label}
      </div>
      <div class="conn-health-desc">${h.desc}</div>
      <div class="conn-health-endpoints">
        <div>
          <div class="conn-health-ep" style="cursor:pointer" title="Inspect ${src.name}">
            <span class="conn-health-dot" style="background:${srcH.color}"></span>
            <span onclick="selectNode('${srcId}')" style="text-decoration:underline;text-decoration-style:dotted;cursor:pointer">${src.name}</span>
            <span style="color:${srcH.color};font-weight:600;margin-left:auto">${srcH.label}</span>
            <button class="conn-health-info-btn" onclick="toggleConnHealthDetail('chd-${srcId}', event)" title="Show metric details">${infoIcon}</button>
          </div>
          ${buildEndpointMetricDetail(srcId, 'chd-' + srcId)}
        </div>
        <div>
          <div class="conn-health-ep" style="cursor:pointer" title="Inspect ${tgt.name}">
            <span class="conn-health-dot" style="background:${tgtH.color}"></span>
            <span onclick="selectNode('${tgtId}')" style="text-decoration:underline;text-decoration-style:dotted;cursor:pointer">${tgt.name}</span>
            <span style="color:${tgtH.color};font-weight:600;margin-left:auto">${tgtH.label}</span>
            <button class="conn-health-info-btn" onclick="toggleConnHealthDetail('chd-${tgtId}', event)" title="Show metric details">${infoIcon}</button>
          </div>
          ${buildEndpointMetricDetail(tgtId, 'chd-' + tgtId)}
        </div>
      </div>
      <div class="conn-health-rule">Health = worst of the two endpoints</div>
    </div>`;
  return collapsible('conn-health', 'Monitoring', 'var(--text-secondary)', 'Connection Health', content);
}

function icon(name, color) {
  const svg = ICONS[name] || '';
  if (color) return svg.replace(/stroke="currentColor"/g, `stroke="${color}"`);
  return svg;
}

// ═══════════════ COLLAPSIBLE HELPER ═══════════════

function toggleInspSwap(event) {
  if (event) event.stopPropagation();
  state.inspVariantOpen = false;
  state.inspSwapOpen = !state.inspSwapOpen;
  renderInspector();
  if (state.inspSwapOpen) positionInspDropdown('.insp-swap-btn', '.insp-header-dropdown.swap');
}

function toggleInspVariant(event) {
  if (event) event.stopPropagation();
  state.inspSwapOpen = false;
  state.inspVariantOpen = !state.inspVariantOpen;
  renderInspector();
  if (state.inspVariantOpen) positionInspDropdown('.insp-variant-btn', '.insp-header-dropdown.variant');
}

function positionInspDropdown(btnSelector, menuSelector) {
  const btn = document.querySelector(btnSelector);
  const menu = document.querySelector(menuSelector);
  if (!btn || !menu) return;
  const rect = btn.getBoundingClientRect();
  menu.style.top = (rect.bottom + 4) + 'px';
  // For swap dropdown, align left; for variant, align right
  if (menuSelector.includes('swap')) {
    menu.style.left = rect.left + 'px';
  } else {
    menu.style.right = (window.innerWidth - rect.right) + 'px';
  }
}

function inspSwapComponent(newId, event) {
  if (event) event.stopPropagation();
  state.inspSwapOpen = false;
  swapComponent(state.selectedNode, newId);
}

function inspChangeVariant(variantKey, event) {
  if (event) event.stopPropagation();
  state.inspVariantOpen = false;
  changeVariant(state.selectedNode, variantKey);
}

function toggleMetricFilter(event) {
  if (event) event.stopPropagation();
  state.metricFilterOpen = !state.metricFilterOpen;
  renderInspector();
  if (state.metricFilterOpen) {
    positionMetricFilterMenu();
  }
}

function positionMetricFilterMenu() {
  const btn = document.querySelector('.metric-filter-btn');
  const menu = document.querySelector('.metric-filter-menu');
  if (!btn || !menu) return;
  const rect = btn.getBoundingClientRect();
  menu.style.top = (rect.bottom + 4) + 'px';
  menu.style.right = (window.innerWidth - rect.right) + 'px';
}

function toggleMetricVisibility(metricName, event) {
  if (event) event.stopPropagation();
  if (state.hiddenMetrics.has(metricName)) {
    state.hiddenMetrics.delete(metricName);
  } else {
    state.hiddenMetrics.add(metricName);
  }
  renderInspector();
  if (state.metricFilterOpen) positionMetricFilterMenu();
}

function setAllMetrics(show, event) {
  if (event) event.stopPropagation();
  const c = components[state.selectedNode];
  const v = c.variants[c.currentVariant];
  if (show) {
    Object.keys(v.metrics).forEach(name => state.hiddenMetrics.delete(name));
  } else {
    Object.keys(v.metrics).forEach(name => state.hiddenMetrics.add(name));
  }
  renderInspector();
  if (state.metricFilterOpen) positionMetricFilterMenu();
}

function toggleMetricExplanation(panelId, event) {
  if (event) event.stopPropagation();
  const el = document.getElementById(panelId);
  if (!el) return;
  // Close other open metric explanations first
  document.querySelectorAll('.metric-explanation.visible').forEach(other => {
    if (other.id !== panelId) other.classList.remove('visible');
  });
  el.classList.toggle('visible');
}

function toggleSection(sectionId) {
  if (state.collapsedSections.has(sectionId)) {
    state.collapsedSections.delete(sectionId);
  } else {
    state.collapsedSections.add(sectionId);
  }
  const body = document.getElementById(sectionId);
  if (body) body.classList.toggle('collapsed');
  const title = document.querySelector(`[data-toggle="${sectionId}"]`);
  if (title) {
    const chev = title.querySelector('.section-chevron');
    if (chev) chev.classList.toggle('open');
  }
}

function collapsible(id, titleIcon, titleColor, titleText, content) {
  const isCollapsed = state.collapsedSections.has(id);
  return `<div class="insp-section">
    <div class="insp-section-title collapsible" data-toggle="${id}" onclick="toggleSection('${id}')">
      ${icon(titleIcon, titleColor)} ${titleText}
      <span class="section-chevron ${isCollapsed ? '' : 'open'}">${icon('chevron', 'var(--text-secondary)')}</span>
    </div>
    <div class="insp-section-body ${isCollapsed ? 'collapsed' : ''}" id="${id}">${content}</div>
  </div>`;
}

// ═══════════════ RENDER FUNCTIONS ═══════════════

function renderLegend() {
  const el = document.getElementById('canvasLegend');
  if (state.heatmapEnabled) {
    el.innerHTML = `
      <div class="legend-title">${icon('Monitoring', 'var(--text-secondary)')} Health Overlay</div>
      <div class="legend-item"><div class="legend-dot" style="border-color:var(--green)"></div> Healthy</div>
      <div class="legend-item"><div class="legend-dot" style="border-color:var(--yellow)"></div> Warning</div>
      <div class="legend-item"><div class="legend-dot" style="border-color:var(--red)"></div> Bottleneck</div>
      <div class="legend-divider"></div>
      <div class="legend-item"><div class="legend-swatch" style="background:var(--green)"></div> Line: healthy</div>
      <div class="legend-item"><div class="legend-swatch" style="background:var(--yellow);height:2px;border-top:1px dashed var(--yellow)"></div> Line: warning</div>
      <div class="legend-item"><div class="legend-swatch" style="background:var(--red);height:2px;border-top:1px dashed var(--red)"></div> Line: bottleneck</div>
    `;
  } else {
    // Show category legend for visible categories
    const usedCats = new Set(Object.values(components).map(c => c.category));
    el.innerHTML = `
      <div class="legend-title">${icon('Search', 'var(--text-secondary)')} Component Types</div>
      ${[...usedCats].map(cat => `<div class="legend-item clickable" onclick="showCategoryInfo('${cat}')" title="About ${cat}">${icon(cat, CATEGORIES[cat].color)} <span style="color:var(--text-secondary)">${cat}</span></div>`).join('')}
    `;
  }
}

function renderToolbox() {
  const el = document.getElementById('toolboxContent');
  if (state.toolboxTab === 'components') {
    // Build a set of component names currently on canvas
    const onCanvas = new Set(Object.values(components).map(c => c.name));

    el.innerHTML = Object.entries(COMPONENT_CATALOG).map(([catName, items]) => {
      const cat = CATEGORIES[catName];
      const info = CATEGORY_INFO[catName];
      const groupId = `catgrp-${catName.replace(/[^a-zA-Z]/g, '')}`;
      const isCollapsed = state.collapsedSections.has(groupId);
      const activeCount = items.filter(i => onCanvas.has(i.name)).length;

      return `<div class="cat-group">
        <div class="cat-group-header" onclick="toggleSection('${groupId}')" data-toggle="${groupId}">
          ${icon(catName, cat.color)}
          <span class="cat-group-name" style="color:${cat.color}">${catName}</span>
          ${activeCount ? `<span class="cat-item-active">${activeCount} in use</span>` : ''}
          <span class="cat-group-count">${items.length}</span>
          <span class="section-chevron ${isCollapsed ? '' : 'open'}">${icon('chevron', 'var(--text-secondary)')}</span>
        </div>
        <div class="cat-group-body ${isCollapsed ? 'collapsed' : ''}" id="${groupId}">
          ${info ? `<div class="cat-group-desc">${info.role}</div>` : ''}
          ${items.map(item => {
            const isActive = onCanvas.has(item.name);
            const fromTags = item.connectsFrom.map(t => `<span class="cat-item-tip-tag">${t}</span>`).join('');
            const toTags = item.connectsTo.map(t => `<span class="cat-item-tip-tag">${t}</span>`).join('');
            // Find the canvas node id if this component is on canvas
            const canvasId = Object.entries(components).find(([, c]) => c.name === item.name)?.[0];
            return `<div class="cat-item${isActive ? ' active-item' : ''}" ${canvasId ? `ondblclick="selectNode('${canvasId}')"` : ''}>
              <span class="cat-item-dot" style="background:${cat.color}${isActive ? '' : '60'}"></span>
              <span class="cat-item-name">${item.name}</span>
              ${isActive ? '<span class="cat-item-active">ON CANVAS</span>' : ''}
              <span class="cat-item-sub">${item.sub}</span>
              <div class="cat-item-tip">
                <strong>${item.name}</strong> <span style="color:var(--text-secondary)">· ${item.sub}</span>
                ${item.connectsFrom.length ? `<div class="cat-item-tip-label">Receives from</div><div class="cat-item-tip-list">${fromTags}</div>` : ''}
                ${item.connectsTo.length ? `<div class="cat-item-tip-label">Connects to</div><div class="cat-item-tip-list">${toTags}</div>` : ''}
              </div>
            </div>`;
          }).join('')}
        </div>
      </div>`;
    }).join('');
  } else if (state.toolboxTab === 'stacks') {
    el.innerHTML = `<div class="component-card" style="border-left-color:var(--accent)">
      <div class="card-header">
        <div class="card-icon">${icon('Messaging', 'var(--accent)')}</div>
        <div><div class="card-name">Real-Time Messaging Stack</div><div class="card-category">${icon('Messaging', 'var(--accent)')} 5 components</div></div></div>
      <div class="card-section"><div class="card-section-label card-is">${icon('is', 'var(--text-secondary)')} IS</div>Pre-wired stack for real-time message delivery with persistence and caching</div>
      <div class="card-section"><div class="card-section-label card-gain">${icon('gain', 'var(--green)')} GAIN</div>Complete messaging pipeline, proven pattern</div>
      <div class="card-section"><div class="card-section-label card-cost">${icon('cost', 'var(--yellow)')} COST</div>Full Kafka + Redis operational burden</div>
    </div>
    <div class="component-card" style="border-left-color:var(--cat-auth)">
      <div class="card-header">
        <div class="card-icon">${icon('Auth/Security', 'var(--cat-auth)')}</div>
        <div><div class="card-name">Auth Stack</div><div class="card-category">${icon('Auth/Security', 'var(--cat-auth)')} 3 components</div></div></div>
      <div class="card-section"><div class="card-section-label card-is">${icon('is', 'var(--text-secondary)')} IS</div>Authentication and authorization with JWT, rate limiting, and session store</div>
    </div>`;
  } else {
    el.innerHTML = `<div class="component-card" style="border-left-color:var(--accent)">
      <div class="card-header">
        <div class="card-icon">${icon('Delivery/Network', 'var(--accent)')}</div>
        <div><div class="card-name">Auction System</div><div class="card-category">${icon('Monitoring', 'var(--accent)')} Tier 2 · 7 components</div></div></div>
      <div class="card-section"><div class="card-section-label card-is">${icon('is', 'var(--text-secondary)')} IS</div>Real-time messaging with persistent storage, caching layer, and event streaming</div>
    </div>
    <div class="component-card" style="border-left-color:var(--cat-realtime)">
      <div class="card-header">
        <div class="card-icon">${icon('Real-Time', 'var(--cat-realtime)')}</div>
        <div><div class="card-name">E-Commerce Checkout</div><div class="card-category">${icon('Monitoring', 'var(--cat-realtime)')} Tier 2 · 5 components</div></div></div>
      <div class="card-section"><div class="card-section-label card-is">${icon('is', 'var(--text-secondary)')} IS</div>Multi-datacenter messaging with MTProto, distributed file storage, and bot platform</div>
    </div>`;
  }
}

const VARIANT_ICON = '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.5"><circle cx="6" cy="6" r="2"/><path d="M6 1v2M6 9v2M1 6h2M9 6h2"/></svg>';

function renderNodes() {
  const container = document.getElementById('nodesContainer');
  container.innerHTML = Object.entries(components).map(([id, c]) => {
    const cat = CATEGORIES[c.category];
    const v = c.variants[c.currentVariant];
    const allMetrics = Object.entries(v.metrics);
    const visibleMetrics = allMetrics.filter(([k]) => !state.hiddenMetrics.has(k));
    const isSelected = state.selectedNode === id;
    let heatClass = '';
    if (state.heatmapEnabled) heatClass = `heatmap-${c.heatStatus}`;
    const alts = ALTERNATIVES[id] || [];
    const swapOpen = state.swapOpenNode === id;
    const variantOpen = state.variantOpenNode === id;
    const variantKeys = Object.keys(c.variants);
    const hasDropdown = swapOpen || variantOpen;
    return `<div class="node ${isSelected ? 'selected' : ''} ${heatClass}" id="node-${id}"
      data-shape="${cat.shape}" data-node-id="${id}"
      style="left:${c.position.x}px;top:${c.position.y}px;border-top:3px solid ${cat.color}${hasDropdown ? ';z-index:15' : ''}"
      onmousedown="startDrag(event, '${id}')">
      <div class="node-tooltip">
        <div class="tooltip-header">${icon(c.category, cat.color)} <strong>${c.name}</strong> · <span style="color:var(--text-secondary)">${c.category}</span></div>
        <div class="tooltip-metrics">
          ${visibleMetrics.slice(0,4).map(([k,val]) => `<div class="tooltip-metric">${k}: <span>${val}</span></div>`).join('')}
        </div>
      </div>
      <div class="node-body">
        <div class="node-header">
          <div class="node-icon clickable" onclick="event.stopPropagation(); ${alts.length > 1 ? `toggleSwapDropdown('${id}')` : `showCategoryInfo('${c.category}')`}" title="${alts.length > 1 ? 'Swap component' : 'About ' + c.category}">${icon(c.category, cat.color)}</div>
          <div class="node-name">${c.name}</div>
        </div>
        ${swapOpen ? `<div class="node-dropdown left" onclick="event.stopPropagation()">
          ${alts.map(a => `<div class="swap-option ${a.id === id ? 'current' : ''}" onclick="swapComponent('${id}', '${a.id}')">
            ${icon(c.category, cat.color)} ${a.name} <span class="swap-option-sub">${a.sub}</span>
          </div>`).join('')}
        </div>` : ''}
        ${variantKeys.length > 1 ? `<div class="node-variant-btn" onclick="event.stopPropagation(); toggleVariantDropdown('${id}')" title="Change configuration variant">${VARIANT_ICON}</div>` : ''}
        ${variantOpen ? `<div class="node-dropdown right" onclick="event.stopPropagation()">
          ${variantKeys.map(vk => {
            const vl = c.variants[vk];
            return `<div class="swap-option ${vk === c.currentVariant ? 'current' : ''}" onclick="changeVariantFromNode('${id}', '${vk}')">
              ${VARIANT_ICON} ${vl.label} ${vk === c.currentVariant ? '<span class="swap-option-sub">Current</span>' : ''}
            </div>`;
          }).join('')}
        </div>` : ''}
        <div class="node-variant">${v.label}</div>
        <div class="node-mini-metrics">
          ${visibleMetrics.map(([k,val]) => `<div class="node-mini-bar"><div class="node-mini-fill" style="width:${val}%;background:${getMetricColor(val)}"></div></div>`).join('')}
        </div>
      </div>
    </div>`;
  }).join('');
}

function renderConnections() {
  connectionPathData = [];
  const svg = document.getElementById('canvasSvg');
  let defs = `<defs>
    <marker id="arrowDefault" markerWidth="8" markerHeight="6" refX="8" refY="3" orient="auto"><path d="M0,0 L8,3 L0,6" fill="var(--border)"/></marker>
    <marker id="arrowGreen" markerWidth="8" markerHeight="6" refX="8" refY="3" orient="auto"><path d="M0,0 L8,3 L0,6" fill="var(--green)"/></marker>
    <marker id="arrowYellow" markerWidth="8" markerHeight="6" refX="8" refY="3" orient="auto"><path d="M0,0 L8,3 L0,6" fill="var(--yellow)"/></marker>
    <marker id="arrowRed" markerWidth="8" markerHeight="6" refX="8" refY="3" orient="auto"><path d="M0,0 L8,3 L0,6" fill="var(--red)"/></marker>
    <marker id="arrowAccent" markerWidth="8" markerHeight="6" refX="8" refY="3" orient="auto"><path d="M0,0 L8,3 L0,6" fill="var(--accent)"/></marker>
  </defs>`;
  let paths = '';
  let labels = '';
  Object.entries(components).forEach(([id, c]) => {
    c.connections.forEach((conn, ci) => {
      const targetId = conn.target;
      const src = c.position;
      const tgt = components[targetId].position;
      const sx = src.x + 76, sy = src.y + 50;
      const tx = tgt.x + 76, ty = tgt.y + 10;
      const baseMx = (sx + tx) / 2, baseMy = (sy + ty) / 2;
      // Offset defines where the LABEL sits (on the curve at t=0.5)
      if (!conn.offset) conn.offset = { x: 0, y: 0 };
      // Label position = midpoint + offset (this is where the curve passes at t=0.5)
      const lx = baseMx + conn.offset.x;
      const ly = baseMy + conn.offset.y;
      // Derive control point so curve passes through label at t=0.5
      // P(0.5) = 0.25*P0 + 0.5*Pc + 0.25*P1  →  Pc = 2*P(0.5) - 0.5*(P0+P1)
      const cpx = 2 * lx - 0.5 * (sx + tx);
      const cpy = 2 * ly - 0.5 * (sy + ty);
      const pathD = `M${sx},${sy} Q${cpx},${cpy} ${tx},${ty}`;
      const health = getConnectionHealth(id, targetId);
      connectionPathData.push({ sx, sy, cpx, cpy, tx, ty, health });
      let heatClass = '';
      let markerEnd = 'url(#arrowDefault)';
      if (state.heatmapEnabled) {
        heatClass = `heat-${health}`;
        markerEnd = `url(#arrow${health.charAt(0).toUpperCase() + health.slice(1)})`;
      }
      const isSelected = state.selectedConnection &&
        state.selectedConnection.sourceId === id && state.selectedConnection.targetId === targetId;
      if (isSelected) markerEnd = 'url(#arrowAccent)';
      paths += `<path id="conn-${id}-${targetId}" class="conn-path ${heatClass} ${isSelected ? 'conn-selected' : ''}" d="${pathD}" marker-end="${markerEnd}"/>`;
      // Label sits exactly on the curve at t=0.5
      const labelText = conn.label || '';
      const connType = conn.connType || 'http';
      const ctDef = CONN_TYPE_DEFS[connType];
      const iconSpace = 14; // 10px icon + 4px gap
      const labelW = labelText.length * 6 + 16 + iconSpace;
      const iconX = lx - labelW/2 + 4;
      const iconY = ly - 5;
      const textX = lx + iconSpace/2;
      labels += `<g class="conn-label-group ${isSelected ? 'selected' : ''}"
        onmousedown="event.stopPropagation(); startConnDrag(event, '${id}', '${targetId}', ${ci})"
        onclick="event.stopPropagation();">
        <rect class="conn-label-bg ${isSelected ? 'selected' : ''}" x="${lx - labelW/2}" y="${ly - 9}" width="${labelW}" height="18" />
        <g transform="translate(${iconX},${iconY}) scale(1)"><path d="${ctDef.path}" fill="none" stroke="${ctDef.color}" stroke-width="1.3"/></g>
        <text class="conn-label-text" x="${textX}" y="${ly}">${labelText}</text>
      </g>`;
    });
  });
  svg.innerHTML = defs + paths + labels;
}

function renderInspector() {
  const el = document.getElementById('inspectorContent');

  // Connection detail view
  if (state.selectedConnection) {
    const { sourceId, targetId } = state.selectedConnection;
    const conn = getConnectionData(sourceId, targetId);
    const srcComp = components[sourceId];
    const tgtComp = components[targetId];
    if (!conn || !srcComp || !tgtComp) { state.selectedConnection = null; return renderInspector(); }
    const srcCat = CATEGORIES[srcComp.category];
    const tgtCat = CATEGORIES[tgtComp.category];
    el.innerHTML = `
      <div class="conn-header">
        <div class="conn-endpoint" onclick="selectNode('${sourceId}')" title="Inspect ${srcComp.name}">
          <div class="conn-ep-icon" style="border-color:${srcCat.color}">${icon(srcComp.category, srcCat.color)}</div>
          <div class="conn-ep-name">${srcComp.name}</div>
        </div>
        <div class="conn-header-arrow">${icon('arrow_right', 'var(--text-secondary)')}</div>
        <div class="conn-endpoint" onclick="selectNode('${targetId}')" title="Inspect ${tgtComp.name}">
          <div class="conn-ep-icon" style="border-color:${tgtCat.color}">${icon(tgtComp.category, tgtCat.color)}</div>
          <div class="conn-ep-name">${tgtComp.name}</div>
        </div>
      </div>
      <div class="conn-meta">
        <span class="conn-protocol-badge">${conn.label}</span>
        ${conn.role ? `<span class="conn-role-tag">${conn.role}</span>` : ''}
      </div>
      ${conn.direction ? `<div class="conn-direction-text">${conn.direction}</div>` : ''}
      <div class="conn-props-strip">
        <div class="conn-prop-chip">
          ${icon('protocol', 'var(--text-secondary)')}
          <span class="conn-prop-chip-label">Protocol</span>
          <span class="conn-prop-chip-val">${conn.protocol}</span>
        </div>
        <div class="conn-prop-chip">
          ${icon('pattern', 'var(--text-secondary)')}
          <span class="conn-prop-chip-label">Pattern</span>
          <span class="conn-prop-chip-val">${conn.pattern}</span>
        </div>
        <div class="conn-prop-chip">
          ${icon('speed', 'var(--text-secondary)')}
          <span class="conn-prop-chip-label">Latency</span>
          <span class="conn-prop-chip-val">${conn.latency}</span>
        </div>
        <div class="conn-prop-chip ${conn.colocatable ? 'positive' : 'negative'}">
          ${icon('coloc', conn.colocatable ? 'var(--green)' : 'var(--red)')}
          <span class="conn-prop-chip-label">Co-locatable</span>
          <span class="conn-prop-chip-val">${conn.colocatable ? 'Yes' : 'No'}</span>
        </div>
      </div>
      ${conn.summary ? collapsible('conn-summary', 'is', 'var(--text-secondary)', 'What This Connection Does',
        `<div class="conn-summary">${conn.summary}</div>`) : ''}
      ${renderConnectionHealth(sourceId, targetId)}
      ${conn.code ? collapsible('conn-code', 'code', 'var(--text-secondary)', 'Connection Code',
        `<div class="conn-code-pattern">${conn.code}</div>`) : ''}
      <div class="conn-footer">
        <div class="conn-footer-link" onclick="selectNode('${sourceId}')">
          ${icon(srcComp.category, srcCat.color)} ${srcComp.name}
        </div>
        <div class="conn-footer-link" onclick="selectNode('${targetId}')">
          ${icon(tgtComp.category, tgtCat.color)} ${tgtComp.name}
        </div>
      </div>
    `;
    return;
  }

  if (!state.selectedNode) {
    el.innerHTML = `<div class="inspector-empty">
      <svg viewBox="0 0 32 32" fill="none" stroke="currentColor" stroke-width="1"><circle cx="16" cy="16" r="12"/><path d="M16 10v6M16 20v1"/></svg>
      Click a component or connection on the canvas to inspect it.
    </div>`;
    return;
  }
  const c = components[state.selectedNode];
  const cat = CATEGORIES[c.category];
  const v = c.variants[c.currentVariant];
  const alts = ALTERNATIVES[state.selectedNode] || [];
  const variantKeys = Object.keys(c.variants);
  const currentMetrics = v.metrics;
  const rec = getVariantRecommendation(state.selectedNode);

  // Build swap dropdown items with metric diffs
  const swapDropdownHTML = alts.length > 1 ? `<div class="insp-header-dropdown swap ${state.inspSwapOpen ? 'visible' : ''}">
    ${alts.map(a => {
      const isCurrent = a.id === state.selectedNode;
      const altComp = components[a.id];
      const altMetrics = altComp ? altComp.variants[altComp.currentVariant].metrics : {};
      const metricDiffs = !isCurrent ? Object.entries(currentMetrics).map(([mk, mv]) => {
        const altVal = altMetrics[mk];
        if (altVal === undefined || state.hiddenMetrics.has(mk)) return '';
        const diff = altVal - mv;
        if (diff === 0) return '';
        const mi = METRIC_ICON_MAP[mk] ? icon(METRIC_ICON_MAP[mk], diff > 0 ? 'var(--green)' : 'var(--red)') : '';
        return `<span class="insp-dd-metric ${diff > 0 ? 'positive' : 'negative'}">${mi}${diff > 0 ? '+' : ''}${diff}</span>`;
      }).filter(Boolean).join('') : '';
      return `<div class="insp-dd-item ${isCurrent ? 'current' : ''}" onclick="inspSwapComponent('${a.id}', event)">
        <div class="insp-dd-item-header">
          ${icon(c.category, cat.color)} ${a.name}
          <span class="insp-dd-item-sub">${a.sub}</span>
          ${isCurrent ? '<span class="insp-dd-item-current">Current</span>' : ''}
        </div>
        ${metricDiffs ? `<div class="insp-dd-metrics">${metricDiffs}</div>` : ''}
      </div>`;
    }).join('')}
  </div>` : '';

  // Build variant dropdown items with metric change previews
  const variantDropdownHTML = variantKeys.length > 1 ? `<div class="insp-header-dropdown variant ${state.inspVariantOpen ? 'visible' : ''}">
    ${variantKeys.map(vk => {
      const vv = c.variants[vk];
      const isCurrent = vk === c.currentVariant;
      const metricDiffs = !isCurrent ? Object.entries(vv.metrics).map(([mk, mv]) => {
        const diff = mv - currentMetrics[mk];
        if (diff === 0 || state.hiddenMetrics.has(mk)) return '';
        const mi = METRIC_ICON_MAP[mk] ? icon(METRIC_ICON_MAP[mk], diff > 0 ? 'var(--green)' : 'var(--red)') : '';
        return `<span class="insp-dd-metric ${diff > 0 ? 'positive' : 'negative'}">${mi}${diff > 0 ? '+' : ''}${diff}</span>`;
      }).filter(Boolean).join('') : '';
      return `<div class="insp-dd-item ${isCurrent ? 'current' : ''}" onclick="inspChangeVariant('${vk}', event)">
        <div class="insp-dd-item-header">
          ${VARIANT_ICON} ${vv.label}
          ${isCurrent ? '<span class="insp-dd-item-current">Current</span>' : ''}
        </div>
        ${metricDiffs ? `<div class="insp-dd-metrics">${metricDiffs}</div>` : ''}
      </div>`;
    }).join('')}
    ${rec ? `<div class="insp-dd-rec">${icon('gain', 'var(--accent)')} Try <strong>${rec.label}</strong> for <span class="delta-positive" style="margin-left:2px">+${rec.improvement} ${rec.metric}</span></div>` : ''}
  </div>` : '';
  const allMetricEntries = Object.entries(v.metrics);
  const visibleCount = allMetricEntries.filter(([name]) => !state.hiddenMetrics.has(name)).length;
  const checkSvg = '<svg viewBox="0 0 10 10" fill="none" stroke="white" stroke-width="2"><path d="M2 5l2 2 4-4"/></svg>';
  const filterMenuItems = allMetricEntries.map(([name, val]) => {
    const isVisible = !state.hiddenMetrics.has(name);
    const mi = METRIC_ICON_MAP[name] ? icon(METRIC_ICON_MAP[name], 'var(--text-secondary)') : '';
    return `<div class="metric-filter-item ${isVisible ? 'checked' : ''}" onclick="toggleMetricVisibility('${name}', event)">
      <div class="metric-filter-check">${isVisible ? checkSvg : ''}</div>
      <span class="metric-filter-name">${mi} ${name}</span>
      <span class="metric-filter-val" style="color:${getMetricColor(val)}">${val}</span>
    </div>`;
  }).join('');
  const filterMenu = `<div class="metric-filter-menu ${state.metricFilterOpen ? 'visible' : ''}">
    <div class="metric-filter-actions">
      <button class="metric-filter-action" onclick="setAllMetrics(true, event)">All</button>
      <button class="metric-filter-action" onclick="setAllMetrics(false, event)">None</button>
    </div>
    ${filterMenuItems}
  </div>`;
  const filterBtnLabel = visibleCount < allMetricEntries.length ? `${visibleCount}/${allMetricEntries.length}` : '';
  const filterBtn = `<div class="metric-filter-wrap">
    <button class="metric-filter-btn ${state.metricFilterOpen ? 'active' : ''}" onclick="toggleMetricFilter(event)" title="Choose which metrics to show">
      ${icon('filter', 'currentColor')} ${filterBtnLabel}
    </button>
    ${filterMenu}
  </div>`;

  const metricBars = allMetricEntries.filter(([name]) => !state.hiddenMetrics.has(name)).map(([name, val], idx) => {
    const metricIcon = METRIC_ICON_MAP[name] ? icon(METRIC_ICON_MAP[name], 'var(--text-secondary)') : '';
    const delta = state.lastDeltas[name];
    const deltaHTML = delta ? ` <span class="metric-delta ${delta > 0 ? 'positive' : delta < 0 ? 'negative' : 'neutral'}">${delta > 0 ? '+' : ''}${delta}</span>` : '';
    const explData = METRIC_EXPLANATIONS[state.selectedNode] && METRIC_EXPLANATIONS[state.selectedNode][c.currentVariant] && METRIC_EXPLANATIONS[state.selectedNode][c.currentVariant][name];
    const explId = `mexpl-${idx}`;
    const infoBtn = explData ? `<button class="metric-info-btn" onclick="toggleMetricExplanation('${explId}', event)" title="Why this score?">${icon('info', 'currentColor')}</button>` : '';
    const explPanel = explData ? `<div class="metric-explanation" id="${explId}"><div class="metric-expl-reason">${explData.reason}</div><ul class="metric-expl-factors">${explData.factors.map(f => `<li>${f}</li>`).join('')}</ul></div>` : '';
    return `<div class="metric-row-wrap">
      <div class="metric-row">
        <div class="metric-label"><span class="metric-name">${metricIcon} ${name}</span><span class="metric-value" style="color:${getMetricColor(val)}">${val}${deltaHTML}</span>${infoBtn}</div>
        <div class="metric-bar-track"><div class="metric-bar-fill" style="width:${val}%;background:${getMetricColor(val)}"></div><div class="metric-threshold" style="left:70%" title="Healthy threshold"></div></div>
      </div>
      ${explPanel}
    </div>`;
  }).join('');
  const metricsEmpty = visibleCount === 0 ? '<div style="font-size:11px;color:var(--text-secondary);padding:8px 0;text-align:center;">No metrics selected. Click the filter to add metrics.</div>' : '';

  const codePattern = CODE_PATTERNS[state.selectedNode] && CODE_PATTERNS[state.selectedNode][c.currentVariant];

  // Auto-open metrics for components with issues
  if (c.heatStatus !== 'green') {
    state.collapsedSections.delete('insp-metrics');
  }

  el.innerHTML = `
    <div class="insp-header">
      <div class="insp-header-btn insp-swap-btn ${state.inspSwapOpen ? 'active' : ''}" ${alts.length > 1 ? 'onclick="toggleInspSwap(event)"' : 'style="cursor:default;opacity:0.6"'} title="${alts.length > 1 ? 'Swap component' : c.category}">${icon(c.category, cat.color)}</div>
      <div class="insp-header-center">
        <div class="insp-name">${c.name}</div>
        <div class="insp-variant-label">${v.label}</div>
      </div>
      ${variantKeys.length > 1 ? `<div class="insp-header-btn insp-variant-btn ${state.inspVariantOpen ? 'active' : ''}" onclick="toggleInspVariant(event)" title="Change configuration variant">${VARIANT_ICON}</div>` : ''}
    </div>
    <div class="insp-category"><div class="insp-cat-dot" style="background:${cat.color}"></div>${c.category}</div>
    ${swapDropdownHTML}
    ${variantDropdownHTML}
    <div class="insp-section">
      <div class="insp-section-title collapsible" data-toggle="insp-metrics" onclick="toggleSection('insp-metrics')">
        <span class="metric-section-title-row">
          ${icon('metrics', 'var(--text-secondary)')} Metrics
          <span onclick="event.stopPropagation()">${filterBtn}</span>
        </span>
        <span class="section-chevron ${state.collapsedSections.has('insp-metrics') ? '' : 'open'}">${icon('chevron', 'var(--text-secondary)')}</span>
      </div>
      <div class="insp-section-body ${state.collapsedSections.has('insp-metrics') ? 'collapsed' : ''}" id="insp-metrics">${metricsEmpty}${metricBars}</div>
    </div>
    ${collapsible('insp-tradeoffs', 'cons', 'var(--text-secondary)', 'Pros & Cons',
      `<div class="pros-cons">${v.pros.map(p => `<div class="pro">${p}</div>`).join('')}${v.cons.map(cc => `<div class="con">${cc}</div>`).join('')}</div>`)}
    ${c.dataContext ? collapsible('insp-data', 'data_ctx', 'var(--accent)', 'Your Data Context',
      c.dataContext.map(item => {
        const behavior = item.behaviors[c.currentVariant];
        if (!behavior) return '';
        return `<div class="data-item fit-${behavior.fit}">
          <div class="data-item-header">
            ${icon(item.icon, 'var(--text-secondary)')}
            ${item.name}
            <span class="fit-badge ${behavior.fit}">${behavior.fit === 'tradeoff' ? 'trade-off' : behavior.fit}</span>
          </div>
          <div class="data-item-note">${behavior.note}</div>
        </div>`;
      }).join('')) : ''}
    ${codePattern ? collapsible('insp-code', 'code', 'var(--text-secondary)', 'Implementation Pattern',
      `<div class="code-pattern">${codePattern}</div>`) : ''}
  `;
}

function renderDashboard() {
  // Compact bottom bar
  const el = document.getElementById('dashboardBars');
  const { scores, breakdown } = calculateDashboardScores();
  el.innerHTML = dashboardCategories.map(cat => {
    const val = scores[cat.key];
    return `<div class="dash-bar-group">
      <div class="dash-bar-track clickable" onclick="highlightForDashboard('${cat.key}')"><div class="dash-bar-fill" style="width:${val}%;background:${getMetricColor(val)}">
        <span class="dash-bar-value">${val}</span>
      </div></div>
      <div class="dash-bar-label">${icon(cat.icon, 'var(--text-secondary)')} ${cat.name}</div>
    </div>`;
  }).join('');

  // Overlay grid (always update so it's ready when toggled)
  const overlayGrid = document.getElementById('dashOverlayGrid');
  overlayGrid.innerHTML = dashboardCategories.map(cat => {
    const val = scores[cat.key];
    const factors = breakdown[cat.key] || [];
    const info = DASHBOARD_INFO[cat.key];
    const catFullName = info ? info.name : cat.name;
    return `<div class="dash-card">
      <div class="dash-card-header">
        ${icon(cat.icon, getMetricColor(val))} ${catFullName}
        <span class="dash-card-score" style="color:${getMetricColor(val)}">${val}</span>
      </div>
      <div class="dash-card-bar"><div class="dash-card-fill" style="width:${val}%;background:${getMetricColor(val)}"></div></div>
      ${info ? `<div class="dash-card-desc">${info.desc}</div>` : ''}
      <div class="dash-card-factors">
        ${factors.map(f => {
          const mi = METRIC_ICON_MAP[f.metric] ? icon(METRIC_ICON_MAP[f.metric], getMetricColor(f.value)) : '';
          return `<div class="dash-card-factor">
            <span class="dash-card-factor-tip">${f.comp} — ${f.metric}: ${f.value}</span>
            <span class="dash-card-factor-comp">${f.comp}</span>
            <span class="dash-card-factor-icon">${mi}</span>
            <span class="dash-card-factor-bar"><span class="dash-card-factor-fill" style="width:${f.value}%;background:${getMetricColor(f.value)}"></span></span>
            <span class="dash-card-factor-val" style="color:${getMetricColor(f.value)}">${f.value}</span>
          </div>`;
        }).join('')}
      </div>
    </div>`;
  }).join('');

  // Sync overlay visibility
  document.getElementById('dashOverlay').classList.toggle('visible', state.dashboardExpanded);
  document.getElementById('dashboard').classList.toggle('expanded', state.dashboardExpanded);
}

function toggleDashboardExpand() {
  state.dashboardExpanded = !state.dashboardExpanded;
  document.getElementById('dashOverlay').classList.toggle('visible', state.dashboardExpanded);
  document.getElementById('dashboard').classList.toggle('expanded', state.dashboardExpanded);
  if (state.dashboardExpanded) renderDashboard(); // refresh overlay content
}

function calculateDashboardScores() {
  // Build breakdown: for each category, collect { comp, metric, value } entries
  const breakdown = {};
  dashboardCategories.forEach(cat => { breakdown[cat.key] = []; });

  Object.entries(components).forEach(([id, c]) => {
    const v = c.variants[c.currentVariant];
    Object.entries(v.metrics).forEach(([metricName, value]) => {
      const catKey = METRIC_TO_CATEGORY[metricName];
      if (catKey && breakdown[catKey]) {
        breakdown[catKey].push({ comp: c.name, metric: metricName, value });
      }
    });
  });

  // Score per category = average of all contributing metric values
  const scores = {};
  dashboardCategories.forEach(cat => {
    const factors = breakdown[cat.key];
    if (factors.length > 0) {
      scores[cat.key] = Math.round(factors.reduce((sum, f) => sum + f.value, 0) / factors.length);
    } else {
      scores[cat.key] = 50; // default if no data
    }
  });

  return { scores, breakdown };
}

// ═══════════════ INTERACTIONS ═══════════════

function selectNode(id) {
  if (state.selectedNode !== id) state.lastDeltas = {}; // clear deltas when switching components
  state.inspSwapOpen = false;
  state.inspVariantOpen = false;
  state.selectedNode = id;
  state.selectedConnection = null; // deselect connection when selecting node
  renderNodes();
  renderConnections();
  renderInspector();
  updatePrompt();
}

// ═══════════════ DRAG & DROP ═══════════════

function startDrag(e, nodeId) {
  // Ignore if clicking on interactive children (icon swap, variant btn, dropdowns, select)
  if (e.target.closest('.node-variant-btn') || e.target.closest('.node-dropdown') || e.target.closest('.swap-dropdown') || e.target.closest('.node-icon.clickable') || e.target.closest('select')) return;
  e.preventDefault();
  const c = components[nodeId];
  state.dragging = nodeId;
  state.dragMoved = false;
  state.dragStart = { mx: e.clientX, my: e.clientY, nx: c.position.x, ny: c.position.y };
}

function onDrag(e) {
  if (!state.dragging) return;
  const dx = e.clientX - state.dragStart.mx;
  const dy = e.clientY - state.dragStart.my;
  // Only count as drag if moved more than 4px (to allow click)
  if (Math.abs(dx) > 4 || Math.abs(dy) > 4) state.dragMoved = true;
  if (!state.dragMoved) return;
  const c = components[state.dragging];
  c.position.x = state.dragStart.nx + dx;
  c.position.y = state.dragStart.ny + dy;
  // Move the DOM element directly for performance (no full re-render)
  const nodeEl = document.getElementById(`node-${state.dragging}`);
  if (nodeEl) {
    nodeEl.style.left = c.position.x + 'px';
    nodeEl.style.top = c.position.y + 'px';
    nodeEl.classList.add('dragging');
  }
  // Update connection lines
  renderConnections();
}

function endDrag(e) {
  if (!state.dragging) return;
  const nodeId = state.dragging;
  const nodeEl = document.getElementById(`node-${nodeId}`);
  if (nodeEl) nodeEl.classList.remove('dragging');
  state.dragging = null;
  if (!state.dragMoved) {
    // It was a click, not a drag — select the node
    selectNode(nodeId);
  }
  state.dragStart = null;
  state.dragMoved = false;
}

// ═══════════════ CONNECTION LABEL DRAG ═══════════════

function startConnDrag(e, sourceId, targetId, connIdx) {
  e.preventDefault();
  const conn = components[sourceId].connections[connIdx];
  if (!conn.offset) conn.offset = { x: 0, y: 0 };
  state.draggingConn = { sourceId, targetId, connIdx };
  state.connDragStart = { mx: e.clientX, my: e.clientY, ox: conn.offset.x, oy: conn.offset.y };
  state.dragMoved = false;
}

function onConnDrag(e) {
  if (!state.draggingConn) return;
  const dx = e.clientX - state.connDragStart.mx;
  const dy = e.clientY - state.connDragStart.my;
  if (Math.abs(dx) > 3 || Math.abs(dy) > 3) state.dragMoved = true;
  if (!state.dragMoved) return;
  const { sourceId, connIdx } = state.draggingConn;
  const conn = components[sourceId].connections[connIdx];
  conn.offset.x = state.connDragStart.ox + dx;
  conn.offset.y = state.connDragStart.oy + dy;
  renderConnections();
}

function endConnDrag(e) {
  if (!state.draggingConn) return;
  const wasDrag = state.dragMoved;
  const { sourceId, targetId } = state.draggingConn;
  state.draggingConn = null;
  state.connDragStart = null;
  if (!wasDrag) {
    // It was a click, not a drag — select the connection
    selectConnection(sourceId, targetId);
  }
  state.dragMoved = false;
}

// Combined mouse handlers for both node and connection dragging
document.addEventListener('mousemove', function(e) { onDrag(e); onConnDrag(e); });
document.addEventListener('mouseup', function(e) { endDrag(e); endConnDrag(e); });

function changeVariant(nodeId, variantKey) {
  const c = components[nodeId];
  // Store previous metrics for delta display
  const prevMetrics = { ...c.variants[c.currentVariant].metrics };
  c.currentVariant = variantKey;

  // Calculate deltas for display
  const newMetrics = c.variants[variantKey].metrics;
  state.lastDeltas = {};
  Object.entries(newMetrics).forEach(([key, val]) => {
    if (prevMetrics[key] !== undefined) state.lastDeltas[key] = val - prevMetrics[key];
  });
  // Deltas persist until the next variant change (cleared at top of this function)

  // Update heatmap status based on new metrics
  const v = c.variants[variantKey];
  const avg = Object.values(v.metrics).reduce((a,b) => a+b, 0) / Object.values(v.metrics).length;
  c.heatStatus = avg >= 70 ? 'green' : avg >= 50 ? 'yellow' : 'red';

  // Immediate update on source
  renderInspector();
  renderNodes();
  renderConnections();

  // Sequential ripple through connections
  triggerRipple(nodeId);

  // Dashboard updates after ripple
  setTimeout(() => renderDashboard(), 300 + c.connections.length * 150);
  restartFlowIfActive();
  renderIssuesButton();
  updatePrompt();
}

function triggerRipple(sourceId) {
  const c = components[sourceId];
  const sourceNode = document.getElementById(`node-${sourceId}`);
  if (sourceNode) { sourceNode.classList.add('rippling'); setTimeout(() => sourceNode.classList.remove('rippling'), 400); }

  c.connections.forEach((conn, i) => {
    const targetId = conn.target;
    setTimeout(() => {
      // Flash the connection line
      const line = document.getElementById(`conn-${sourceId}-${targetId}`);
      if (line) { line.classList.add('ripple'); setTimeout(() => line.classList.remove('ripple'), 300); }

      // Ripple the target node
      const targetNode = document.getElementById(`node-${targetId}`);
      if (targetNode) {
        targetNode.classList.add('rippling');
        setTimeout(() => targetNode.classList.remove('rippling'), 400);
      }

      renderNodes();
      renderConnections();
      if (i === c.connections.length - 1) restartFlowIfActive();
    }, (i + 1) * 150);
  });
}

function toggleHeatmap() {
  state.heatmapEnabled = !state.heatmapEnabled;
  document.getElementById('heatmapToggle').classList.toggle('active', state.heatmapEnabled);
  renderNodes();
  renderConnections();
  renderLegend();
  if (state.heatmapEnabled) {
    startFlowAnimation();
  } else {
    stopFlowAnimation();
  }
  updatePrompt();
}

function togglePanel(panelId) {
  document.getElementById(panelId).classList.toggle('collapsed');
}

function switchTab(tabEl, tabName) {
  document.querySelectorAll('.toolbox-tab').forEach(t => t.classList.remove('active'));
  tabEl.classList.add('active');
  state.toolboxTab = tabName;
  renderToolbox();
}

// ═══════════════ CONNECTION SELECTION ═══════════════

function selectConnection(sourceId, targetId) {
  // Toggle selection
  if (state.selectedConnection &&
      state.selectedConnection.sourceId === sourceId &&
      state.selectedConnection.targetId === targetId) {
    state.selectedConnection = null;
  } else {
    state.selectedConnection = { sourceId, targetId };
    state.selectedNode = null; // deselect node when selecting connection
  }
  renderNodes();
  renderConnections();
  renderInspector();
  updatePrompt();
}

function getConnectionData(sourceId, targetId) {
  const c = components[sourceId];
  if (!c) return null;
  return c.connections.find(conn => conn.target === targetId) || null;
}

// ═══════════════ COMPONENT SWAP ═══════════════

function toggleSwapDropdown(nodeId) {
  state.variantOpenNode = null;
  state.swapOpenNode = state.swapOpenNode === nodeId ? null : nodeId;
  renderNodes();
  renderConnections();
}

function toggleVariantDropdown(nodeId) {
  state.swapOpenNode = null;
  state.variantOpenNode = state.variantOpenNode === nodeId ? null : nodeId;
  renderNodes();
  renderConnections();
}

function changeVariantFromNode(nodeId, variantKey) {
  state.variantOpenNode = null;
  changeVariant(nodeId, variantKey);
}

function swapComponent(currentId, newId) {
  if (currentId === newId) {
    state.swapOpenNode = null;
    renderNodes();
    renderConnections();
    return;
  }
  // In a real app this would replace the component entirely.
  // For this playground, show feedback that it would swap.
  const alt = (ALTERNATIVES[currentId] || []).find(a => a.id === newId);
  const node = document.getElementById(`node-${currentId}`);
  if (node) {
    node.style.transition = 'transform 0.2s, opacity 0.2s';
    node.style.transform = 'scale(0.9)';
    node.style.opacity = '0.5';
    setTimeout(() => {
      node.style.transform = 'scale(1)';
      node.style.opacity = '1';
    }, 200);
  }
  state.swapOpenNode = null;
  // Update the prompt to reflect the swap intention
  if (alt) {
    const c = components[currentId];
    c._swapTarget = alt;
  }
  renderNodes();
  renderConnections();
  renderInspector();
  updatePrompt();
}

// Close swap/variant dropdown on click outside
document.addEventListener('click', function(e) {
  if (state.swapOpenNode && !e.target.closest('.node-icon.clickable') && !e.target.closest('.node-dropdown') && !e.target.closest('.swap-dropdown')) {
    state.swapOpenNode = null;
    renderNodes();
    renderConnections();
  }
  if (state.variantOpenNode && !e.target.closest('.node-variant-btn') && !e.target.closest('.node-dropdown')) {
    state.variantOpenNode = null;
    renderNodes();
    renderConnections();
  }
  if (state.issuesOpen && !e.target.closest('#issuesBtn') && !e.target.closest('#issuesDropdown')) {
    state.issuesOpen = false;
    document.getElementById('issuesDropdown').classList.remove('visible');
  }
  if (state.metricFilterOpen && !e.target.closest('.metric-filter-wrap') && !e.target.closest('.metric-filter-menu')) {
    state.metricFilterOpen = false;
    const menu = document.querySelector('.metric-filter-menu');
    if (menu) menu.classList.remove('visible');
  }
  if (state.inspSwapOpen && !e.target.closest('.insp-swap-btn') && !e.target.closest('.insp-header-dropdown.swap')) {
    state.inspSwapOpen = false;
    renderInspector();
  }
  if (state.inspVariantOpen && !e.target.closest('.insp-variant-btn') && !e.target.closest('.insp-header-dropdown.variant')) {
    state.inspVariantOpen = false;
    renderInspector();
  }
});

// ═══════════════ PROMPT OUTPUT ═══════════════

function updatePrompt() {
  const el = document.getElementById('promptText');
  const parts = [];
  parts.push('Build the Archie architecture simulator interface with these specifications:');
  parts.push('');
  parts.push('LAYOUT: VS Code three-zone pattern — Toolbox sidebar (left, 270px), Canvas (center, dark bg #0f1117), Inspector panel (right, 310px). Dashboard bar at bottom (110px). Top bar with logo, architecture name, tier badge, and icon+label action buttons.');
  parts.push('');
  parts.push('THEME: Dark mode primary. Panel bg: #1a1d27, Surface: #242736, Border: #2e3348, Text: #e2e4eb / #8b8fa3, Accent: #6366f1 (indigo). Font: Inter, 13px base. 4px spacing unit.');
  parts.push('');
  parts.push('ICONOGRAPHY: Every category, action, metric, and label has an SVG icon. Icons are the primary visual communication — users identify component types by icon before text. 10 category icons: CPU (compute), Database cylinder (data storage), Lightning bolt (caching), Chat bubble (messaging), Globe (delivery/network), Signal waves (real-time), Shield (auth), Chart (monitoring), Magnifying glass (search), Gear (devops). Icons appear in nodes, toolbox cards, inspector, dashboard labels, tabs, and buttons.');
  parts.push('');
  parts.push('NODE SHAPES: Each component category has a distinct node shape: Compute = sharp rectangle (4px radius), Data Storage = bottom-rounded cylinder shape (4px top, 14px bottom radius), Caching = pill (16px radius), Messaging = alternating corners (12px/4px), Delivery = stadium (20px radius). Nodes show: category color top stripe, category icon + name, variant label, mini metric bars.');
  parts.push('');
  parts.push('COLOR SYSTEM: Two separate color layers — category colors (10 distinct hues) identify component TYPE via accent stripes and icon fills. Heatmap colors (green/yellow/red) show HEALTH status on borders and connection lines when heatmap is enabled. These never overlap — category = identity, heatmap = performance.');
  parts.push('');

  if (state.heatmapEnabled) {
    parts.push('HEATMAP: Enabled — node borders glow with health colors (green/yellow/red). Connection LINES also colored by health (worst of two endpoints). Dashed lines for warning/bottleneck connections. Legend visible in top-right corner of canvas.');
    parts.push('');
  }

  if (state.selectedNode) {
    const c = components[state.selectedNode];
    const v = c.variants[c.currentVariant];
    parts.push(`CURRENT SELECTION: ${c.name} (${c.category}) with "${v.label}" config variant.`);
    parts.push(`Metrics: ${Object.entries(v.metrics).map(([k,val]) => `${k}: ${val}/100`).join(', ')}`);
    parts.push('');
  }

  parts.push('CORE INTERACTION: Config variant dropdown in inspector. On change → metric bars animate (0.5s cubic-bezier), sequential ripple propagates through connections (~150ms per hop), heatmap colors shift on nodes AND lines, dashboard updates after ripple completes.');
  parts.push('');
  parts.push('TOOLBOX: Three tabs with icons (grid=Components | stack=Stacks | blueprint=Blueprints). Component cards in IS/GAIN/COST format with category icon + color left border. Section labels have micro-icons (circle=IS, up-arrow=GAIN, down-arrow=COST).');
  parts.push('');
  parts.push('DASHBOARD: 7 horizontal bars with category icons (rocket=Perf, dollar=Cost, shield=Reliab, gear=Ops, mountain=Scale, flag=Strat, code=Dev). Color-coded: green >70, yellow 40-70, red <40.');
  parts.push('');
  parts.push('DATA CONTEXT: Each component has user-defined data items (e.g., Redis: "User Sessions", "Rate Limits", "Message Cache"). When switching config variants, a "Your Data Context" section in the inspector shows how each data item behaves under that variant with fit indicators (great/good/trade-off/poor/risky) and specific notes. This makes abstract metrics concrete: "Your sessions are read-heavy → Cache-Aside is a great fit" vs "Your rate limit counters are write-heavy → Cache-Aside is a poor fit." Users can edit their data items to personalize the trade-off analysis.');
  parts.push('');
  parts.push('COMPONENT SWAP: Each node shows a swap button (arrows icon) on hover in the top-right corner. Clicking opens a dropdown with alternative components in the same category (e.g., Redis → Memcached, KeyDB, Dragonfly). The inspector also shows a "Swap to" dropdown below the component name. This enables quick comparison of alternative tools without rebuilding the architecture.');
  parts.push('');
  parts.push('IMPLEMENTATION PATTERNS: Below the config variant dropdown in the inspector, a code snippet panel shows the actual implementation pattern for the current variant. Syntax-highlighted (keywords purple, functions blue, strings green, comments gray). This makes the difference between variants tangible — users see HOW the code changes, not just abstract metric scores.');
  parts.push('');
  parts.push('CONNECTIONS AS FIRST-CLASS OBJECTS: Connections between components are not just lines — they have properties. Each connection specifies: protocol (HTTP, RESP, Kafka TCP, PostgreSQL Wire, etc.), communication pattern (request-response, pub-sub, poll-consume, fire-and-forget), typical latency, whether components can be co-located on the same machine, and implementation code showing HOW the connection works. Click any connection label on the canvas to inspect its properties. Connections show directional arrows. The Auction System architecture has event-driven flows: Bid API→Event Bus publishes, Auction Engine→Bid Store persists, Payment Service→Notification Service triggers alerts.');

  if (state.selectedConnection) {
    const conn = getConnectionData(state.selectedConnection.sourceId, state.selectedConnection.targetId);
    if (conn) {
      const src = components[state.selectedConnection.sourceId];
      const tgt = components[state.selectedConnection.targetId];
      parts.push('');
      parts.push(`SELECTED CONNECTION: ${src.name} → ${tgt.name} via ${conn.protocol}. Pattern: ${conn.pattern}. Latency: ${conn.latency}. Co-locatable: ${conn.colocatable ? 'Yes' : 'No'}.`);
    }
  }

  el.textContent = parts.join('\n');
}

function copyPrompt() {
  const text = document.getElementById('promptText').textContent;
  navigator.clipboard.writeText(text).then(() => {
    const btn = document.querySelector('.prompt-copy-btn');
    const original = btn.innerHTML;
    btn.innerHTML = '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 6l3 3 5-5"/></svg> Copied!';
    setTimeout(() => btn.innerHTML = original, 1500);
  });
}

// ═══════════════ INFO POPUPS ═══════════════

function showInfoPopup(headerHTML, bodyHTML) {
  const overlay = document.getElementById('infoPopupOverlay');
  document.getElementById('infoPopupHeader').innerHTML = headerHTML + `<button class="info-popup-close" onclick="hideInfoPopup()">${icon('close', 'var(--text-secondary)')}</button>`;
  document.getElementById('infoPopupBody').innerHTML = bodyHTML;
  overlay.classList.add('visible');
}

function hideInfoPopup() {
  document.getElementById('infoPopupOverlay').classList.remove('visible');
}

function showCategoryInfo(categoryName) {
  const info = CATEGORY_INFO[categoryName];
  if (!info) return;
  const cat = CATEGORIES[categoryName];
  const headerHTML = `${icon(categoryName, cat.color)} <span style="color:${cat.color}">${categoryName}</span>`;
  const bodyHTML = `
    <p><strong>${info.desc}</strong></p>
    <div class="info-popup-section">
      <div class="info-popup-section-title">Role in Architecture</div>
      <p>${info.role}</p>
    </div>
    <div class="info-popup-section">
      <div class="info-popup-section-title">Common Examples</div>
      <p>${info.examples}</p>
    </div>
    <div class="info-popup-section">
      <div class="info-popup-section-title">How to Choose</div>
      <p>${info.key}</p>
    </div>
  `;
  showInfoPopup(headerHTML, bodyHTML);
}

function showDashboardInfo(categoryKey) {
  const info = DASHBOARD_INFO[categoryKey];
  if (!info) return;
  const dashCat = dashboardCategories.find(c => c.key === categoryKey);
  const headerHTML = `${dashCat ? icon(dashCat.icon, 'var(--accent)') : ''} <span style="color:var(--accent)">${info.name}</span>`;
  const bodyHTML = `
    <p><strong>${info.desc}</strong></p>
    <div class="info-popup-section">
      <div class="info-popup-section-title">Key Metrics</div>
      <p>${info.metrics}</p>
    </div>
    <div class="info-popup-section">
      <div class="info-popup-section-title">Why It Matters</div>
      <p>${info.impact}</p>
    </div>
    <div class="info-popup-section">
      <div class="info-popup-section-title">How to Improve</div>
      <p>${info.improve}</p>
    </div>
  `;
  showInfoPopup(headerHTML, bodyHTML);
}

// Close popup on Escape key
document.addEventListener('keydown', function(e) {
  if (e.key === 'Escape') {
    hideInfoPopup();
    if (state.issuesOpen) { state.issuesOpen = false; document.getElementById('issuesDropdown').classList.remove('visible'); }
    if (state.swapOpenNode || state.variantOpenNode) { state.swapOpenNode = null; state.variantOpenNode = null; renderNodes(); renderConnections(); }
  }
});

// ═══════════════ ISSUES SUMMARY ═══════════════

function getIssues() {
  const issues = [];
  Object.entries(components).forEach(([id, c]) => {
    if (c.heatStatus !== 'green') {
      const v = c.variants[c.currentVariant];
      const avg = Math.round(Object.values(v.metrics).reduce((a,b) => a+b, 0) / Object.values(v.metrics).length);
      const worst = Object.entries(v.metrics).sort((a,b) => a[1] - b[1])[0];
      issues.push({ id, name: c.name, category: c.category, status: c.heatStatus, avg, worstMetric: worst[0], worstValue: worst[1] });
    }
  });
  const priority = { 'red': 0, 'yellow': 1 };
  issues.sort((a, b) => (priority[a.status] ?? 2) - (priority[b.status] ?? 2) || a.avg - b.avg);
  return issues;
}

function renderIssuesButton() {
  const issues = getIssues();
  const badge = document.getElementById('issuesBadge');
  if (issues.length === 0) {
    badge.classList.add('hidden');
  } else {
    badge.classList.remove('hidden');
    badge.textContent = issues.length;
    badge.className = 'issues-badge' + (issues.some(i => i.status === 'red') ? '' : ' warning');
  }
}

function toggleIssues() {
  state.issuesOpen = !state.issuesOpen;
  const dropdown = document.getElementById('issuesDropdown');
  const btn = document.getElementById('issuesBtn');
  if (state.issuesOpen) {
    const rect = btn.getBoundingClientRect();
    dropdown.style.top = (rect.bottom + 4) + 'px';
    dropdown.style.left = Math.max(8, rect.left - 80) + 'px';
    const issues = getIssues();
    if (issues.length === 0) {
      dropdown.innerHTML = `<div class="issues-dropdown-title">${icon('gain', 'var(--green)')} Architecture Health</div>
        <div class="issues-none">All components healthy — no issues detected</div>`;
    } else {
      dropdown.innerHTML = `<div class="issues-dropdown-title">${icon('cons', 'var(--red)')} ${issues.length} Issue${issues.length > 1 ? 's' : ''} Detected</div>
        ${issues.map(i => {
          const cat = CATEGORIES[i.category];
          const h = HEALTH_LABELS[i.status];
          return `<div class="issues-item" onclick="selectNode('${i.id}'); toggleIssues();">
            <span class="issues-item-dot" style="background:${h.color}"></span>
            ${icon(i.category, cat.color)}
            <span class="issues-item-name">${i.name}</span>
            <span class="issues-item-detail">${h.label} · worst: ${i.worstMetric} ${i.worstValue}</span>
          </div>`;
        }).join('')}`;
    }
    dropdown.classList.add('visible');
  } else {
    dropdown.classList.remove('visible');
  }
}

// ═══════════════ VARIANT RECOMMENDATION ═══════════════

function getVariantRecommendation(nodeId) {
  const c = components[nodeId];
  const currentMetrics = c.variants[c.currentVariant].metrics;
  const worst = Object.entries(currentMetrics).sort((a,b) => a[1] - b[1])[0];
  if (worst[1] >= 70) return null;
  let bestAlt = null;
  let bestImprovement = 0;
  Object.entries(c.variants).forEach(([vk, vv]) => {
    if (vk === c.currentVariant) return;
    const altValue = vv.metrics[worst[0]];
    if (altValue !== undefined && altValue > worst[1]) {
      const improvement = altValue - worst[1];
      if (improvement > bestImprovement) {
        bestImprovement = improvement;
        bestAlt = { key: vk, label: vv.label, metric: worst[0], from: worst[1], to: altValue, improvement };
      }
    }
  });
  if (!bestAlt) return null;
  const altMetrics = c.variants[bestAlt.key].metrics;
  let worstRegression = null;
  Object.entries(currentMetrics).forEach(([k, v]) => {
    if (k === worst[0]) return;
    const altV = altMetrics[k];
    if (altV !== undefined && altV < v) {
      const loss = v - altV;
      if (!worstRegression || loss > worstRegression.loss) worstRegression = { metric: k, loss };
    }
  });
  bestAlt.tradeoff = worstRegression;
  return bestAlt;
}

// ═══════════════ TIER INFO ═══════════════

function showTierInfo() {
  const headerHTML = `${icon('strat', 'var(--accent)')} <span style="color:var(--accent)">Architecture Tier System</span>`;
  const issues = getIssues();
  const redCount = issues.filter(i => i.status === 'red').length;
  const yellowCount = issues.filter(i => i.status === 'yellow').length;
  const bodyHTML = `
    <p><strong>Tiers measure how complete and production-ready your architecture is.</strong></p>
    <div class="info-popup-section">
      <div class="info-popup-section-title">Current: Tier 2 / 3</div>
      <p>Your architecture has core components with defined connections and configuration variants. Metrics are tracked and trade-offs are visible.</p>
    </div>
    <div class="info-popup-section">
      <div class="info-popup-section-title">Tier Criteria</div>
      <ul class="info-popup-list">
        <li><strong style="color:var(--green)">Tier 1:</strong> Components placed with basic connections defined</li>
        <li><strong style="color:var(--accent)">Tier 2 (current):</strong> Config variants selected, metrics profiled, trade-offs mapped</li>
        <li><strong style="color:var(--yellow)">Tier 3:</strong> All bottlenecks addressed, heatmap mostly green, data context personalized</li>
      </ul>
    </div>
    <div class="info-popup-section">
      <div class="info-popup-section-title">Gap to Tier 3</div>
      <ul class="info-popup-list">
        ${redCount > 0 ? `<li style="color:var(--red)">Resolve ${redCount} bottleneck${redCount > 1 ? 's' : ''} (red components)</li>` : `<li style="color:var(--green)">No bottlenecks — great!</li>`}
        ${yellowCount > 0 ? `<li style="color:var(--yellow)">Address ${yellowCount} warning${yellowCount > 1 ? 's' : ''} (yellow components)</li>` : `<li style="color:var(--green)">No warnings — great!</li>`}
        <li>Customize data context items for your specific use case</li>
        <li>Verify connection health across all paths</li>
      </ul>
    </div>
  `;
  showInfoPopup(headerHTML, bodyHTML);
}

// ═══════════════ DASHBOARD LINKING ═══════════════

function highlightForDashboard(catKey) {
  const issues = getIssues();
  if (issues.length > 0) {
    issues.forEach(issue => {
      const nodeEl = document.getElementById('node-' + issue.id);
      if (nodeEl) {
        nodeEl.classList.add('flash-highlight');
        setTimeout(() => nodeEl.classList.remove('flash-highlight'), 800);
      }
    });
  }
  showDashboardInfo(catKey);
}

// ═══════════════ FLOW PARTICLE ANIMATION ═══════════════
const FLOW_SPEEDS = { green: 0.014, yellow: 0.006, red: 0.0025 };
const FLOW_COLORS = { green: '#22c55e', yellow: '#eab308', red: '#ef4444' };

function startFlowAnimation() {
  stopFlowAnimation();
  if (connectionPathData.length === 0) return;
  state.flowParticles = [];
  connectionPathData.forEach((path, pi) => {
    const count = path.health === 'green' ? 3 : 2;
    for (let i = 0; i < count; i++) {
      state.flowParticles.push({
        pathIdx: pi,
        t: i / count + Math.random() * 0.1,
        speed: FLOW_SPEEDS[path.health] * (0.9 + Math.random() * 0.2)
      });
    }
  });
  const svg = document.getElementById('flowSvg');
  svg.innerHTML = '<defs><filter id="flowGlow"><feGaussianBlur stdDeviation="2" result="blur"/>' +
    '<feMerge><feMergeNode in="blur"/><feMergeNode in="SourceGraphic"/></feMerge></filter></defs>' +
    state.flowParticles.map((p, i) => {
      const color = FLOW_COLORS[connectionPathData[p.pathIdx].health];
      return `<circle id="fp${i}" cx="0" cy="0" r="3" fill="${color}" opacity="0.9" filter="url(#flowGlow)"/>`;
    }).join('');
  function tick() {
    if (!state.heatmapEnabled) return;
    for (let i = 0; i < state.flowParticles.length; i++) {
      const p = state.flowParticles[i];
      p.t += p.speed;
      if (p.t > 1) p.t -= 1;
      const pd = connectionPathData[p.pathIdx];
      if (!pd) continue;
      const mt = 1 - p.t;
      const x = mt * mt * pd.sx + 2 * mt * p.t * pd.cpx + p.t * p.t * pd.tx;
      const y = mt * mt * pd.sy + 2 * mt * p.t * pd.cpy + p.t * p.t * pd.ty;
      const el = document.getElementById(`fp${i}`);
      if (el) {
        el.setAttribute('cx', x);
        el.setAttribute('cy', y);
        el.setAttribute('r', 2.5 + Math.sin(p.t * Math.PI * 4) * 0.8);
      }
    }
    state.flowAnimationId = requestAnimationFrame(tick);
  }
  state.flowAnimationId = requestAnimationFrame(tick);
}

function stopFlowAnimation() {
  if (state.flowAnimationId) cancelAnimationFrame(state.flowAnimationId);
  state.flowAnimationId = null;
  state.flowParticles = [];
  const svg = document.getElementById('flowSvg');
  if (svg) svg.innerHTML = '';
}

function restartFlowIfActive() {
  if (state.heatmapEnabled) startFlowAnimation();
}

// ═══════════════ INIT ═══════════════
function init() {
  renderLegend();
  renderToolbox();
  renderNodes();
  renderConnections();
  renderDashboard();
  renderIssuesButton();
  updatePrompt();
}

init();
</script>
</body>
</html>
