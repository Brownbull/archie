<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Twitter Home Timeline — Archie Playground</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
<style>
/* ═══════════════ RESET & BASE ═══════════════ */
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
:root {
  --canvas-bg: #0f1117;
  --panel-bg: #1a1d27;
  --surface: #242736;
  --border: #2e3348;
  --text-primary: #e2e4eb;
  --text-secondary: #8b8fa3;
  --accent: #6366f1;
  --accent-hover: #818cf8;
  --green: #22c55e;
  --yellow: #eab308;
  --red: #ef4444;
  --cat-compute: #3b82f6;
  --cat-data: #22c55e;
  --cat-cache: #f97316;
  --cat-messaging: #a855f7;
  --cat-delivery: #06b6d4;
  --cat-realtime: #ec4899;
  --cat-auth: #ef4444;
  --cat-monitoring: #eab308;
  --cat-search: #14b8a6;
  --cat-devops: #8b5cf6;
  --radius: 6px;
  --space: 4px;
  --toolbox-w: 270px;
  --inspector-w: 310px;
  --topbar-h: 44px;
}
html, body { height: 100%; overflow: hidden; }
body {
  font-family: 'Inter', system-ui, -apple-system, sans-serif;
  background: var(--canvas-bg);
  color: var(--text-primary);
  font-size: 13px;
  line-height: 1.4;
}

/* ═══════════════ TOP BAR ═══════════════ */
.top-bar {
  height: var(--topbar-h);
  background: var(--panel-bg);
  border-bottom: 1px solid var(--border);
  display: flex;
  align-items: center;
  padding: 0 12px;
  gap: 12px;
  z-index: 100;
}
.logo {
  font-weight: 700;
  font-size: 15px;
  color: var(--accent);
  letter-spacing: -0.5px;
  display: flex;
  align-items: center;
  gap: 6px;
}
.logo svg { width: 18px; height: 18px; }
.arch-name {
  font-weight: 500;
  color: var(--text-secondary);
  flex: 1;
}
.tier-badge {
  background: var(--accent);
  color: white;
  font-size: 11px;
  font-weight: 600;
  padding: 3px 10px;
  border-radius: 12px;
  cursor: default;
  display: flex;
  align-items: center;
  gap: 4px;
}
.tier-badge svg { width: 12px; height: 12px; }
.tier-badge .tier-hint {
  font-weight: 400;
  opacity: 0.7;
  font-size: 10px;
}
.top-actions { display: flex; gap: 6px; }
.top-btn {
  background: var(--surface);
  border: 1px solid var(--border);
  color: var(--text-secondary);
  padding: 5px 10px;
  border-radius: var(--radius);
  font-size: 11px;
  font-family: inherit;
  cursor: pointer;
  transition: all 0.15s;
  display: flex;
  align-items: center;
  gap: 4px;
}
.top-btn svg { width: 14px; height: 14px; }
.top-btn:hover { color: var(--text-primary); border-color: var(--text-secondary); }
.top-btn.active { background: var(--accent); color: white; border-color: var(--accent); }

/* ═══════════════ MAIN LAYOUT ═══════════════ */
.main-layout {
  display: flex;
  height: calc(100vh - var(--topbar-h));
}

/* ═══════════════ TOOLBOX ═══════════════ */
.toolbox {
  width: var(--toolbox-w);
  min-width: var(--toolbox-w);
  background: var(--panel-bg);
  border-right: 1px solid var(--border);
  display: flex;
  flex-direction: column;
  transition: width 0.2s, min-width 0.2s, opacity 0.2s;
  overflow: hidden;
}
.toolbox.collapsed { width: 0; min-width: 0; opacity: 0; pointer-events: none; }
.toolbox-title {
  padding: 10px 12px;
  border-bottom: 1px solid var(--border);
  font-weight: 600;
  font-size: 12px;
  color: var(--text-secondary);
  text-transform: uppercase;
  letter-spacing: 0.5px;
  display: flex;
  align-items: center;
  gap: 6px;
}
.toolbox-title svg { width: 14px; height: 14px; }
.toolbox-tabs {
  display: flex;
  border-bottom: 1px solid var(--border);
}
.toolbox-tab {
  flex: 1;
  padding: 8px 4px;
  text-align: center;
  font-size: 11px;
  font-weight: 500;
  color: var(--text-secondary);
  cursor: pointer;
  border-bottom: 2px solid transparent;
  transition: all 0.15s;
  background: none;
  border-top: none;
  border-left: none;
  border-right: none;
  font-family: inherit;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 4px;
}
.toolbox-tab svg { width: 14px; height: 14px; }
.toolbox-tab:hover { color: var(--text-primary); }
.toolbox-tab.active { color: var(--accent); border-bottom-color: var(--accent); }
.toolbox-content {
  flex: 1;
  overflow-y: auto;
  padding: 8px;
}
.toolbox-content::-webkit-scrollbar { width: 4px; }
.toolbox-content::-webkit-scrollbar-track { background: transparent; }
.toolbox-content::-webkit-scrollbar-thumb { background: var(--border); border-radius: 2px; }
.component-card {
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 10px;
  margin-bottom: 8px;
  cursor: grab;
  transition: all 0.15s;
  border-left: 3px solid var(--cat-color);
}
.component-card:hover {
  border-color: var(--text-secondary);
  transform: translateY(-1px);
}
.card-header {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 6px;
}
.card-icon {
  width: 20px;
  height: 20px;
  flex-shrink: 0;
  display: flex;
  align-items: center;
  justify-content: center;
}
.card-icon svg { width: 18px; height: 18px; }
.card-name { font-weight: 600; font-size: 12px; }
.card-category { font-size: 10px; color: var(--text-secondary); display: flex; align-items: center; gap: 3px; }
.card-category svg { width: 10px; height: 10px; }
.card-section {
  font-size: 10px;
  margin-top: 4px;
  line-height: 1.5;
}
.card-section-label {
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  font-size: 9px;
  margin-bottom: 1px;
  display: flex;
  align-items: center;
  gap: 3px;
}
.card-section-label svg { width: 10px; height: 10px; }
.card-is { color: var(--text-secondary); }
.card-gain { color: var(--green); }
.card-cost { color: var(--yellow); }
/* ═══════════════ CATALOG CATEGORY GROUPS ═══════════════ */
.cat-group {
  margin-bottom: 4px;
}
.cat-group-header {
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 6px 8px;
  cursor: pointer;
  border-radius: var(--radius);
  transition: background 0.1s;
  user-select: none;
}
.cat-group-header:hover { background: var(--surface); }
.cat-group-header svg { width: 14px; height: 14px; flex-shrink: 0; }
.cat-group-name {
  font-weight: 600;
  font-size: 11px;
  flex: 1;
}
.cat-group-count {
  font-size: 9px;
  color: var(--text-secondary);
  background: var(--surface);
  padding: 1px 6px;
  border-radius: 8px;
}
.cat-group-header .section-chevron svg { width: 10px; height: 10px; }
.cat-group-body {
  padding: 0 0 4px 8px;
}
.cat-group-body.collapsed { display: none; }
.cat-group-desc {
  font-size: 10px;
  color: var(--text-secondary);
  line-height: 1.4;
  padding: 2px 8px 6px 20px;
  font-style: italic;
}
.cat-item {
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 5px 8px;
  border-radius: 4px;
  font-size: 11px;
  cursor: grab;
  transition: background 0.1s;
  position: relative;
}
.cat-item:hover { background: var(--surface); }
.cat-item-dot {
  width: 6px;
  height: 6px;
  border-radius: 50%;
  flex-shrink: 0;
}
.cat-item-name { font-weight: 500; }
.cat-item-sub { font-size: 9px; color: var(--text-secondary); margin-left: auto; }
.cat-item-active {
  font-size: 8px;
  color: var(--accent);
  font-weight: 600;
  margin-left: 4px;
}
/* Catalog item tooltip */
.cat-item-tip {
  display: none;
  position: absolute;
  left: calc(100% + 8px);
  top: 50%;
  transform: translateY(-50%);
  background: var(--panel-bg);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 8px 10px;
  font-size: 10px;
  min-width: 180px;
  z-index: 30;
  box-shadow: 0 4px 16px rgba(0,0,0,0.5);
  pointer-events: none;
  white-space: normal;
  line-height: 1.4;
}
.cat-item:hover .cat-item-tip { display: block; }
.cat-item-tip-label {
  font-size: 9px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  color: var(--text-secondary);
  margin-top: 4px;
}
.cat-item-tip-label:first-child { margin-top: 0; }
.cat-item-tip-list {
  display: flex;
  flex-wrap: wrap;
  gap: 3px;
  margin-top: 2px;
}
.cat-item-tip-tag {
  font-size: 9px;
  padding: 1px 5px;
  border-radius: 3px;
  background: var(--surface);
  border: 1px solid var(--border);
}

/* ═══════════════ CANVAS ═══════════════ */
.canvas {
  flex: 1;
  position: relative;
  background: var(--canvas-bg);
  overflow: hidden;
}
.canvas-svg {
  position: absolute;
  top: 0; left: 0;
  width: 100%; height: 100%;
  pointer-events: none;
  z-index: 1;
}
.canvas-svg .conn-label-group { pointer-events: all; cursor: grab; }
.canvas-svg .conn-label-group:active { cursor: grabbing; }
.canvas-svg .conn-path {
  stroke: var(--border);
  stroke-width: 2;
  fill: none;
  transition: stroke 0.4s, stroke-width 0.3s;
}
.canvas-svg .conn-path.heat-green { stroke: var(--green); stroke-width: 2.5; }
.canvas-svg .conn-path.heat-yellow { stroke: var(--yellow); stroke-width: 2.5; stroke-dasharray: 8 4; }
.canvas-svg .conn-path.heat-red { stroke: var(--red); stroke-width: 3; stroke-dasharray: 6 3; }
.canvas-svg .conn-path.ripple { stroke: var(--accent); stroke-width: 3; }
.canvas-svg .conn-path.conn-selected { stroke: var(--accent); stroke-width: 2.5; }

/* Canvas Legend */
.canvas-legend {
  position: absolute;
  top: 12px;
  right: 12px;
  background: var(--panel-bg);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 8px 10px;
  font-size: 10px;
  z-index: 5;
  opacity: 0.9;
  transition: opacity 0.2s;
}
.canvas-legend:hover { opacity: 1; }
.legend-title {
  font-weight: 600;
  font-size: 9px;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  color: var(--text-secondary);
  margin-bottom: 6px;
  display: flex;
  align-items: center;
  gap: 4px;
}
.legend-title svg { width: 12px; height: 12px; }
.legend-item {
  display: flex;
  align-items: center;
  gap: 6px;
  margin-bottom: 3px;
  color: var(--text-secondary);
}
.legend-item svg { width: 12px; height: 12px; }
.legend-swatch {
  width: 12px;
  height: 3px;
  border-radius: 2px;
  flex-shrink: 0;
}
.legend-dot {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  border: 2px solid;
  flex-shrink: 0;
}
.legend-divider {
  height: 1px;
  background: var(--border);
  margin: 5px 0;
}

/* Canvas Nodes */
.node {
  position: absolute;
  width: 152px;
  background: var(--surface);
  border: 2px solid var(--border);
  padding: 0;
  cursor: pointer;
  z-index: 2;
  transition: all 0.2s;
  user-select: none;
}
/* Shape variations per category */
.node[data-shape="rectangle"] { border-radius: 4px; }
.node[data-shape="cylinder"] { border-radius: 4px 4px 14px 14px; }
.node[data-shape="pill"] { border-radius: 16px; }
.node[data-shape="hexish"] { border-radius: 12px 4px 12px 4px; }
.node[data-shape="stadium"] { border-radius: 20px; }

.node:hover { border-color: var(--text-secondary); z-index: 3; }
.node.selected { border-color: var(--accent); box-shadow: 0 0 0 2px rgba(99,102,241,0.3); z-index: 4; }
.node.dragging { opacity: 0.85; z-index: 10; cursor: grabbing; box-shadow: 0 8px 32px rgba(0,0,0,0.5); transition: none; }

.node-body {
  padding: 8px 10px 10px;
  position: relative;
}
/* Variant button on node (right side) */
.node-variant-btn {
  position: absolute;
  top: 4px;
  right: 4px;
  width: 20px;
  height: 20px;
  background: var(--panel-bg);
  border: 1px solid var(--border);
  border-radius: 4px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  opacity: 0;
  transition: opacity 0.15s, background 0.15s;
  z-index: 5;
}
.node-variant-btn svg { width: 12px; height: 12px; }
.node:hover .node-variant-btn { opacity: 0.7; }
.node-variant-btn:hover { opacity: 1 !important; background: var(--accent); border-color: var(--accent); }
/* Node dropdown overlays (shared) */
.node-dropdown {
  position: absolute;
  margin-top: 4px;
  background: var(--panel-bg);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 4px;
  min-width: 160px;
  z-index: 20;
  box-shadow: 0 8px 24px rgba(0,0,0,0.4);
}
.node-dropdown.left { top: 100%; left: 0; }
.node-dropdown.right { top: 100%; right: 0; }
/* Legacy alias */
.swap-dropdown { position: absolute; top: 100%; right: 0; margin-top: 4px; background: var(--panel-bg); border: 1px solid var(--border); border-radius: var(--radius); padding: 4px; min-width: 160px; z-index: 20; box-shadow: 0 8px 24px rgba(0,0,0,0.4); }
.swap-option {
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 5px 8px;
  border-radius: 3px;
  font-size: 11px;
  cursor: pointer;
  transition: background 0.1s;
  color: var(--text-primary);
}
.swap-option:hover { background: var(--surface); }
.swap-option.current { color: var(--accent); font-weight: 600; }
.swap-option svg { width: 12px; height: 12px; }
.swap-option-sub { font-size: 9px; color: var(--text-secondary); margin-left: auto; }
.node-header {
  display: flex;
  align-items: center;
  gap: 6px;
  margin-bottom: 4px;
}
.node-icon {
  width: 20px;
  height: 20px;
  flex-shrink: 0;
  display: flex;
  align-items: center;
  justify-content: center;
}
.node-icon svg { width: 18px; height: 18px; }
.node-name { font-weight: 600; font-size: 12px; line-height: 1.2; }
.node-variant { font-size: 10px; color: var(--text-secondary); margin-left: 26px; }
.node-mini-metrics {
  display: flex;
  gap: 3px;
  margin-top: 6px;
}
.node-mini-bar {
  flex: 1;
  height: 3px;
  background: var(--border);
  border-radius: 2px;
  overflow: hidden;
}
.node-mini-fill {
  height: 100%;
  border-radius: 2px;
  transition: width 0.4s ease, background-color 0.4s ease;
}

/* Heatmap borders */
.node.heatmap-green { border-color: var(--green); box-shadow: 0 0 10px rgba(34,197,94,0.3); }
.node.heatmap-yellow { border-color: var(--yellow); box-shadow: 0 0 10px rgba(234,179,8,0.3); }
.node.heatmap-red { border-color: var(--red); box-shadow: 0 0 10px rgba(239,68,68,0.3); }
.node.selected.heatmap-green { box-shadow: 0 0 0 2px rgba(34,197,94,0.3), 0 0 10px rgba(34,197,94,0.2); }
.node.selected.heatmap-yellow { box-shadow: 0 0 0 2px rgba(234,179,8,0.3), 0 0 10px rgba(234,179,8,0.2); }
.node.selected.heatmap-red { box-shadow: 0 0 0 2px rgba(239,68,68,0.3), 0 0 10px rgba(239,68,68,0.2); }

/* Tooltip */
.node-tooltip {
  display: none;
  position: absolute;
  bottom: calc(100% + 8px);
  left: 50%;
  transform: translateX(-50%);
  background: var(--panel-bg);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 8px 10px;
  font-size: 11px;
  white-space: nowrap;
  z-index: 10;
  pointer-events: none;
  box-shadow: 0 4px 12px rgba(0,0,0,0.4);
}
.node:hover .node-tooltip { display: block; }
.tooltip-header { display: flex; align-items: center; gap: 5px; margin-bottom: 3px; }
.tooltip-header svg { width: 14px; height: 14px; }
.tooltip-metrics { display: flex; gap: 10px; margin-top: 4px; }
.tooltip-metric { color: var(--text-secondary); }
.tooltip-metric span { color: var(--text-primary); font-weight: 500; }

/* Canvas empty state hint */
.canvas-hint {
  position: absolute;
  bottom: 72px;
  left: 50%;
  transform: translateX(-50%);
  color: var(--text-secondary);
  font-size: 11px;
  opacity: 0.5;
  pointer-events: none;
  display: flex;
  align-items: center;
  gap: 6px;
}
.canvas-hint svg { width: 14px; height: 14px; }

/* ═══════════════ INSPECTOR ═══════════════ */
.inspector {
  width: var(--inspector-w);
  min-width: var(--inspector-w);
  background: var(--panel-bg);
  border-left: 1px solid var(--border);
  display: flex;
  flex-direction: column;
  transition: width 0.2s, min-width 0.2s, opacity 0.2s;
  overflow: hidden;
}
.inspector.collapsed { width: 0; min-width: 0; opacity: 0; pointer-events: none; }
.inspector-header {
  padding: 10px 12px;
  border-bottom: 1px solid var(--border);
  font-weight: 600;
  font-size: 12px;
  color: var(--text-secondary);
  text-transform: uppercase;
  letter-spacing: 0.5px;
  display: flex;
  align-items: center;
  gap: 6px;
}
.inspector-header svg { width: 14px; height: 14px; }
.inspector-content {
  flex: 1;
  overflow-y: auto;
  padding: 12px;
}
.inspector-content::-webkit-scrollbar { width: 4px; }
.inspector-content::-webkit-scrollbar-track { background: transparent; }
.inspector-content::-webkit-scrollbar-thumb { background: var(--border); border-radius: 2px; }
.inspector-empty {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 100%;
  color: var(--text-secondary);
  font-size: 12px;
  text-align: center;
  padding: 20px;
  gap: 8px;
}
.inspector-empty svg { width: 32px; height: 32px; opacity: 0.3; }
.insp-header {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 4px;
}
.insp-header-btn {
  width: 28px;
  height: 28px;
  display: flex;
  align-items: center;
  justify-content: center;
  border: 1px solid var(--border);
  border-radius: var(--radius);
  background: var(--surface);
  cursor: pointer;
  transition: all 0.15s;
  flex-shrink: 0;
}
.insp-header-btn:hover { border-color: var(--text-secondary); }
.insp-header-btn.active { border-color: var(--accent); background: rgba(99, 102, 241, 0.1); }
.insp-header-btn svg { width: 16px; height: 16px; }
.insp-header-center {
  flex: 1;
  min-width: 0;
}
.insp-name { font-size: 16px; font-weight: 700; }
.insp-variant-label { font-size: 11px; color: var(--text-secondary); }
.insp-category { font-size: 11px; color: var(--text-secondary); margin-bottom: 12px; display: flex; align-items: center; gap: 6px; }
.insp-cat-dot { width: 8px; height: 8px; border-radius: 50%; }
/* Inspector header dropdowns */
.insp-header-dropdown {
  display: none;
  position: fixed;
  background: var(--panel-bg);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 6px 0;
  min-width: 240px;
  max-width: 280px;
  z-index: 1000;
  box-shadow: 0 4px 16px rgba(0,0,0,0.4);
  animation: metricExpand 0.15s ease-out;
}
.insp-header-dropdown.visible { display: block; }
.insp-dd-item {
  padding: 8px 12px;
  cursor: pointer;
  transition: background 0.1s;
  border-left: 3px solid transparent;
}
.insp-dd-item:hover { background: var(--surface); }
.insp-dd-item.current {
  border-left-color: var(--accent);
  background: rgba(99, 102, 241, 0.05);
}
.insp-dd-item-header {
  display: flex;
  align-items: center;
  gap: 6px;
  font-size: 12px;
  font-weight: 500;
}
.insp-dd-item-header svg { width: 14px; height: 14px; }
.insp-dd-item-sub {
  font-size: 10px;
  color: var(--text-secondary);
  font-weight: 400;
}
.insp-dd-item-current {
  font-size: 9px;
  color: var(--accent);
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.3px;
}
.insp-dd-metrics {
  display: flex;
  gap: 4px;
  margin-top: 5px;
  flex-wrap: wrap;
}
.insp-dd-metric {
  font-size: 9px;
  padding: 1px 5px;
  border-radius: 3px;
  background: var(--surface);
  border: 1px solid var(--border);
  display: inline-flex;
  align-items: center;
  gap: 2px;
}
.insp-dd-metric svg { width: 10px; height: 10px; flex-shrink: 0; }
.insp-dd-metric.positive { color: var(--green); border-color: rgba(34,197,94,0.3); }
.insp-dd-metric.negative { color: var(--red); border-color: rgba(239,68,68,0.3); }
.insp-dd-metric.neutral { color: var(--text-secondary); }
.insp-dd-rec {
  padding: 6px 12px;
  margin-top: 2px;
  border-top: 1px solid var(--border);
  font-size: 10px;
  color: var(--text-secondary);
  display: flex;
  align-items: center;
  gap: 4px;
}
.insp-dd-rec svg { width: 10px; height: 10px; }
.insp-section { margin-bottom: 14px; }
.insp-section-title {
  font-size: 10px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  color: var(--text-secondary);
  margin-bottom: 6px;
  display: flex;
  align-items: center;
  gap: 5px;
}
.insp-section-title svg { width: 12px; height: 12px; }
.insp-select {
  width: 100%;
  background: var(--surface);
  border: 1px solid var(--border);
  color: var(--text-primary);
  padding: 6px 8px;
  border-radius: var(--radius);
  font-family: inherit;
  font-size: 12px;
  cursor: pointer;
  outline: none;
}
.insp-select:focus { border-color: var(--accent); }

/* Metric bars in inspector */
.metric-row { margin-bottom: 0; }
.metric-label {
  display: flex;
  justify-content: space-between;
  font-size: 11px;
  margin-bottom: 3px;
}
.metric-name { color: var(--text-secondary); display: flex; align-items: center; gap: 4px; }
.metric-name svg { width: 11px; height: 11px; }
.metric-value { font-weight: 600; }
.metric-bar-track {
  height: 6px;
  background: var(--surface);
  border-radius: 3px;
  overflow: hidden;
  position: relative;
}
.metric-bar-fill {
  height: 100%;
  border-radius: 3px;
  transition: width 0.5s cubic-bezier(0.4, 0, 0.2, 1), background-color 0.5s;
}

/* Metric filter dropdown */
.metric-filter-wrap {
  position: relative;
  display: inline-block;
}
.metric-filter-btn {
  background: none;
  border: 1px solid transparent;
  color: var(--text-secondary);
  cursor: pointer;
  padding: 2px 5px;
  border-radius: var(--radius);
  display: flex;
  align-items: center;
  gap: 3px;
  font-size: 10px;
  font-family: inherit;
  transition: all 0.15s;
  margin-left: auto;
}
.metric-filter-btn:hover { color: var(--accent); border-color: var(--border); }
.metric-filter-btn.active { color: var(--accent); background: rgba(99, 102, 241, 0.1); border-color: var(--accent); }
.metric-filter-btn svg { width: 10px; height: 10px; }
.metric-filter-menu {
  display: none;
  position: fixed;
  background: var(--panel-bg);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 6px 0;
  min-width: 200px;
  z-index: 1000;
  box-shadow: 0 4px 16px rgba(0,0,0,0.4);
  animation: metricExpand 0.15s ease-out;
}
.metric-filter-menu.visible { display: block; }
.metric-filter-actions {
  display: flex;
  gap: 4px;
  padding: 0 8px 6px;
  border-bottom: 1px solid var(--border);
  margin-bottom: 4px;
}
.metric-filter-action {
  background: none;
  border: none;
  color: var(--accent);
  font-size: 10px;
  font-family: inherit;
  cursor: pointer;
  padding: 2px 6px;
  border-radius: 3px;
  transition: background 0.15s;
}
.metric-filter-action:hover { background: rgba(99, 102, 241, 0.15); }
.metric-filter-item {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 4px 10px;
  cursor: pointer;
  font-size: 11px;
  color: var(--text-secondary);
  transition: background 0.1s;
}
.metric-filter-item:hover { background: var(--surface); }
.metric-filter-check {
  width: 14px;
  height: 14px;
  border: 1.5px solid var(--border);
  border-radius: 3px;
  display: flex;
  align-items: center;
  justify-content: center;
  flex-shrink: 0;
  transition: all 0.15s;
}
.metric-filter-item.checked .metric-filter-check {
  background: var(--accent);
  border-color: var(--accent);
}
.metric-filter-check svg { width: 10px; height: 10px; }
.metric-filter-name { display: flex; align-items: center; gap: 4px; flex: 1; }
.metric-filter-name svg { width: 11px; height: 11px; }
.metric-filter-val {
  font-size: 10px;
  font-weight: 600;
  margin-left: auto;
}
.metric-section-title-row {
  display: flex;
  align-items: center;
  width: 100%;
}

/* Metric explanation dropdown */
.metric-row-wrap { margin-bottom: 8px; }
.metric-info-btn {
  background: none;
  border: none;
  color: var(--text-secondary);
  cursor: pointer;
  padding: 0;
  width: 14px;
  height: 14px;
  display: flex;
  align-items: center;
  justify-content: center;
  opacity: 0.5;
  transition: opacity 0.15s, color 0.15s;
  flex-shrink: 0;
}
.metric-info-btn:hover { opacity: 1; color: var(--accent); }
.metric-info-btn svg { width: 11px; height: 11px; }
.metric-explanation {
  display: none;
  margin-top: 6px;
  padding: 8px 10px;
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  font-size: 11px;
  line-height: 1.5;
  animation: metricExpand 0.2s ease-out;
}
.metric-explanation.visible { display: block; }
@keyframes metricExpand {
  from { opacity: 0; transform: translateY(-4px); }
  to { opacity: 1; transform: translateY(0); }
}
.metric-expl-reason {
  color: var(--text-primary);
  margin-bottom: 6px;
}
.metric-expl-factors {
  list-style: none;
  padding: 0;
  margin: 0;
  display: flex;
  flex-direction: column;
  gap: 3px;
}
.metric-expl-factors li {
  color: var(--text-secondary);
  font-size: 10px;
  padding-left: 12px;
  position: relative;
}
.metric-expl-factors li::before {
  content: '›';
  position: absolute;
  left: 2px;
  color: var(--accent);
  font-weight: 600;
}

/* Pros/Cons */
.pros-cons { display: flex; flex-direction: column; gap: 4px; }
.pro, .con { font-size: 11px; display: flex; gap: 4px; align-items: flex-start; }
.pro::before { content: '+'; color: var(--green); font-weight: 700; flex-shrink: 0; }
.con::before { content: '−'; color: var(--red); font-weight: 700; flex-shrink: 0; }

/* Data Context */
.data-context-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
}
.data-context-edit {
  font-size: 9px;
  color: var(--accent);
  cursor: pointer;
  opacity: 0.7;
  display: flex;
  align-items: center;
  gap: 3px;
}
.data-context-edit:hover { opacity: 1; }
.data-context-edit svg { width: 10px; height: 10px; }
.data-item {
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: 4px;
  padding: 6px 8px;
  margin-bottom: 6px;
  transition: border-color 0.3s;
}
.data-item.fit-great { border-left: 3px solid var(--green); }
.data-item.fit-good { border-left: 3px solid var(--green); opacity: 0.85; }
.data-item.fit-tradeoff { border-left: 3px solid var(--yellow); }
.data-item.fit-poor { border-left: 3px solid var(--red); }
.data-item.fit-risky { border-left: 3px solid var(--red); }
.data-item-header {
  display: flex;
  align-items: center;
  gap: 5px;
  margin-bottom: 2px;
  font-size: 11px;
  font-weight: 500;
}
.data-item-header svg { width: 11px; height: 11px; }
.fit-badge {
  font-size: 9px;
  font-weight: 600;
  padding: 1px 5px;
  border-radius: 3px;
  margin-left: auto;
  text-transform: uppercase;
  letter-spacing: 0.3px;
}
.fit-badge.great { background: rgba(34,197,94,0.15); color: var(--green); }
.fit-badge.good { background: rgba(34,197,94,0.1); color: var(--green); }
.fit-badge.tradeoff { background: rgba(234,179,8,0.15); color: var(--yellow); }
.fit-badge.poor { background: rgba(239,68,68,0.15); color: var(--red); }
.fit-badge.risky { background: rgba(239,68,68,0.15); color: var(--red); }
.data-item-note {
  font-size: 10px;
  color: var(--text-secondary);
  line-height: 1.4;
  margin-left: 16px;
}

/* Code Pattern */
.code-pattern {
  background: var(--canvas-bg);
  border: 1px solid var(--border);
  border-radius: 4px;
  padding: 8px 10px;
  font-family: 'SF Mono', 'Fira Code', 'Cascadia Code', monospace;
  font-size: 10px;
  line-height: 1.5;
  color: var(--text-secondary);
  overflow-x: auto;
  white-space: pre;
  tab-size: 2;
}
.code-pattern .kw { color: #c084fc; }
.code-pattern .fn { color: #60a5fa; }
.code-pattern .str { color: #4ade80; }
.code-pattern .cm { color: #6b7280; font-style: italic; }
.code-pattern .num { color: #fbbf24; }

/* Connection Labels */
.conn-label-group { cursor: pointer; }
.conn-label-group:hover .conn-label-bg { fill: var(--surface); }
.conn-label-bg {
  fill: var(--panel-bg);
  stroke: var(--border);
  stroke-width: 1;
  rx: 4;
  transition: fill 0.15s;
}
.conn-label-bg.selected { stroke: var(--accent); stroke-width: 1.5; }
.conn-label-text {
  fill: var(--text-secondary);
  font-size: 9px;
  font-family: 'Inter', system-ui, sans-serif;
  font-weight: 500;
  text-anchor: middle;
  dominant-baseline: central;
  pointer-events: none;
}
.conn-label-icon {
  fill: none;
  stroke: var(--text-secondary);
  stroke-width: 1;
}
.conn-label-group.selected .conn-label-text { fill: var(--accent); }

/* Connection detail in inspector */
/* Connection inspector — header with clickable endpoints */
.conn-header {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 10px;
}
.conn-endpoint {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 4px;
  cursor: pointer;
  flex: 1;
  min-width: 0;
  padding: 6px 4px;
  border-radius: var(--radius);
  transition: background 0.15s;
}
.conn-endpoint:hover { background: var(--surface); }
.conn-ep-icon {
  width: 32px;
  height: 32px;
  display: flex;
  align-items: center;
  justify-content: center;
  border: 2px solid var(--border);
  border-radius: 50%;
  background: var(--surface);
}
.conn-ep-icon svg { width: 16px; height: 16px; }
.conn-ep-name {
  font-size: 11px;
  font-weight: 600;
  text-align: center;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  max-width: 100%;
}
.conn-header-arrow { flex-shrink: 0; color: var(--text-secondary); }
.conn-header-arrow svg { width: 14px; height: 14px; }
/* Connection metadata badges */
.conn-meta {
  display: flex;
  align-items: center;
  gap: 6px;
  margin-bottom: 8px;
}
.conn-protocol-badge {
  display: inline-flex;
  align-items: center;
  gap: 3px;
  background: rgba(99, 102, 241, 0.1);
  border: 1px solid rgba(99, 102, 241, 0.3);
  border-radius: 3px;
  padding: 2px 8px;
  font-size: 10px;
  font-weight: 600;
  color: var(--accent);
}
.conn-role-tag {
  font-size: 10px;
  font-weight: 500;
  color: var(--text-secondary);
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: 3px;
  padding: 2px 8px;
}
/* Connection direction text */
.conn-direction-text {
  font-size: 11px;
  color: var(--text-secondary);
  line-height: 1.5;
  margin-bottom: 10px;
  font-style: italic;
  padding-left: 2px;
}
/* Connection property chips */
.conn-props-strip {
  display: flex;
  flex-direction: column;
  gap: 4px;
  margin-bottom: 10px;
}
.conn-prop-chip {
  display: flex;
  align-items: center;
  gap: 6px;
  font-size: 11px;
  padding: 5px 8px;
  background: var(--surface);
  border-radius: 4px;
  border-left: 3px solid var(--border);
}
.conn-prop-chip svg { width: 11px; height: 11px; flex-shrink: 0; }
.conn-prop-chip-label {
  color: var(--text-secondary);
  font-weight: 500;
  min-width: 60px;
  flex-shrink: 0;
}
.conn-prop-chip-val { color: var(--text-primary); }
.conn-prop-chip.positive { border-left-color: var(--green); }
.conn-prop-chip.positive .conn-prop-chip-val { color: var(--green); }
.conn-prop-chip.negative { border-left-color: var(--red); }
.conn-prop-chip.negative .conn-prop-chip-val { color: var(--red); }
/* Code pattern block */
.conn-code-pattern {
  background: var(--canvas-bg);
  border: 1px solid var(--border);
  border-radius: 4px;
  padding: 8px 10px;
  font-family: 'SF Mono', 'Fira Code', 'Cascadia Code', monospace;
  font-size: 10px;
  line-height: 1.5;
  color: var(--text-secondary);
  overflow-x: auto;
  white-space: pre;
  tab-size: 2;
  margin-top: 8px;
}
.conn-code-pattern .kw { color: #c084fc; }
.conn-code-pattern .fn { color: #60a5fa; }
.conn-code-pattern .str { color: #4ade80; }
.conn-code-pattern .cm { color: #6b7280; font-style: italic; }
.conn-code-pattern .num { color: #fbbf24; }
/* Connection footer — quick links to endpoints */
.conn-footer {
  display: flex;
  gap: 6px;
  margin-top: 12px;
  padding-top: 10px;
  border-top: 1px solid var(--border);
}
.conn-footer-link {
  flex: 1;
  display: flex;
  align-items: center;
  gap: 4px;
  font-size: 10px;
  color: var(--text-secondary);
  cursor: pointer;
  padding: 5px 8px;
  border: 1px solid var(--border);
  border-radius: var(--radius);
  transition: all 0.15s;
  justify-content: center;
}
.conn-footer-link:hover { border-color: var(--accent); color: var(--text-primary); }
.conn-footer-link svg { width: 11px; height: 11px; }
.conn-summary {
  font-size: 11px;
  color: var(--text-secondary);
  line-height: 1.6;
  padding: 6px 0;
}


/* ═══════════════ DASHBOARD ═══════════════ */
.dashboard {
  position: absolute;
  bottom: 0;
  left: 0;
  right: 0;
  background: var(--panel-bg);
  border-top: 1px solid var(--border);
  padding: 6px 12px;
  display: flex;
  flex-direction: column;
  z-index: 10;
}
.dashboard-title {
  font-size: 10px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  color: var(--text-secondary);
  margin-bottom: 4px;
  display: flex;
  align-items: center;
  gap: 5px;
}
.dashboard-title svg { width: 13px; height: 13px; }
.dashboard-bars {
  display: flex;
  gap: 6px;
  align-items: center;
}
.dash-bar-group {
  flex: 1;
  display: flex;
  flex-direction: column;
  gap: 2px;
}
.dash-bar-label {
  font-size: 9px;
  color: var(--text-secondary);
  text-align: center;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 3px;
}
.dash-bar-label svg { width: 10px; height: 10px; }
.dash-bar-track {
  height: 16px;
  background: var(--surface);
  border-radius: 3px;
  overflow: hidden;
  position: relative;
}
.dash-bar-fill {
  height: 100%;
  border-radius: 3px;
  transition: width 0.6s cubic-bezier(0.4, 0, 0.2, 1), background-color 0.6s;
  position: relative;
}
.dash-bar-value {
  position: absolute;
  right: 4px;
  top: 50%;
  transform: translateY(-50%);
  font-size: 9px;
  font-weight: 600;
  color: rgba(255,255,255,0.8);
}

/* Dashboard expand toggle */
.dash-expand-btn {
  background: none;
  border: 1px solid var(--border);
  border-radius: 3px;
  cursor: pointer;
  padding: 1px 4px;
  margin-left: auto;
  display: flex;
  align-items: center;
  color: var(--text-secondary);
  transition: all 0.15s;
}
.dash-expand-btn:hover { border-color: var(--text-secondary); color: var(--text-primary); }
.dash-expand-chevron { width: 10px; height: 10px; transition: transform 0.2s; }
.dashboard.expanded .dash-expand-chevron { transform: rotate(180deg); }

/* ═══════════════ DASHBOARD OVERLAY ═══════════════ */
.dash-overlay {
  display: none;
  position: absolute;
  top: 0; left: 0; right: 0; bottom: 0;
  background: rgba(15, 17, 23, 0.97);
  z-index: 20;
  flex-direction: column;
  overflow-y: auto;
  padding: 20px 24px;
}
.dash-overlay.visible { display: flex; }
.dash-overlay::-webkit-scrollbar { width: 4px; }
.dash-overlay::-webkit-scrollbar-track { background: transparent; }
.dash-overlay::-webkit-scrollbar-thumb { background: var(--border); border-radius: 2px; }
.dash-overlay-header {
  font-size: 12px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  color: var(--text-secondary);
  margin-bottom: 16px;
  display: flex;
  align-items: center;
  gap: 6px;
}
.dash-overlay-header svg { width: 14px; height: 14px; }
.dash-overlay-close {
  margin-left: auto;
  background: none;
  border: 1px solid var(--border);
  border-radius: 3px;
  color: var(--text-secondary);
  font-size: 16px;
  cursor: pointer;
  width: 24px;
  height: 24px;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.15s;
}
.dash-overlay-close:hover { border-color: var(--text-primary); color: var(--text-primary); }
.dash-overlay-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
  gap: 16px;
  flex: 1;
}
/* Each category card in the overlay */
.dash-card {
  background: var(--panel-bg);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 12px;
  display: flex;
  flex-direction: column;
  gap: 8px;
}
.dash-card-header {
  display: flex;
  align-items: center;
  gap: 6px;
  font-size: 12px;
  font-weight: 600;
}
.dash-card-header svg { width: 14px; height: 14px; }
.dash-card-score {
  font-size: 20px;
  font-weight: 700;
  margin-left: auto;
}
.dash-card-bar {
  height: 8px;
  background: var(--surface);
  border-radius: 4px;
  overflow: hidden;
}
.dash-card-fill {
  height: 100%;
  border-radius: 4px;
  transition: width 0.6s cubic-bezier(0.4, 0, 0.2, 1);
}
.dash-card-desc {
  font-size: 10px;
  color: var(--text-secondary);
  line-height: 1.4;
}
.dash-card-factors {
  display: flex;
  flex-direction: column;
  gap: 4px;
  margin-top: 4px;
}
.dash-card-factor {
  display: flex;
  align-items: center;
  gap: 6px;
  font-size: 10px;
  color: var(--text-secondary);
  position: relative;
}
.dash-card-factor-comp {
  width: 72px;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  flex-shrink: 0;
}
.dash-card-factor-icon {
  width: 14px;
  flex-shrink: 0;
  display: flex;
  align-items: center;
}
.dash-card-factor-icon svg { width: 11px; height: 11px; }
.dash-card-factor-bar {
  flex: 1;
  height: 6px;
  background: var(--surface);
  border-radius: 3px;
  overflow: hidden;
  min-width: 30px;
  display: block;
}
.dash-card-factor-fill {
  display: block;
  height: 100%;
  border-radius: 3px;
  transition: width 0.4s;
}
.dash-card-factor-val {
  width: 22px;
  text-align: right;
  font-weight: 600;
  font-size: 10px;
  flex-shrink: 0;
}
/* Factor tooltip */
.dash-card-factor-tip {
  display: none;
  position: absolute;
  bottom: calc(100% + 4px);
  left: 0;
  background: var(--panel-bg);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 6px 10px;
  font-size: 10px;
  color: var(--text-primary);
  white-space: nowrap;
  z-index: 5;
  box-shadow: 0 2px 8px rgba(0,0,0,0.3);
  pointer-events: none;
}
.dash-card-factor:hover .dash-card-factor-tip { display: block; }

/* ═══════════════ PROMPT OUTPUT ═══════════════ */
.prompt-section {
  position: fixed;
  bottom: 0;
  left: 0;
  right: 0;
  z-index: 200;
  transform: translateY(calc(100% - 32px));
  transition: transform 0.3s;
}
.prompt-section.open { transform: translateY(0); }
.prompt-toggle {
  background: var(--accent);
  color: white;
  border: none;
  padding: 6px 16px;
  font-size: 11px;
  font-weight: 600;
  font-family: inherit;
  cursor: pointer;
  border-radius: var(--radius) var(--radius) 0 0;
  margin-left: 16px;
  display: flex;
  align-items: center;
  gap: 5px;
}
.prompt-toggle svg { width: 14px; height: 14px; }
.prompt-body {
  background: var(--panel-bg);
  border-top: 1px solid var(--accent);
  padding: 12px 16px;
  max-height: 180px;
  display: flex;
  gap: 12px;
}
.prompt-text {
  flex: 1;
  font-size: 12px;
  color: var(--text-secondary);
  line-height: 1.6;
  overflow-y: auto;
  font-family: 'Inter', system-ui, sans-serif;
}
.prompt-copy-btn {
  background: var(--accent);
  color: white;
  border: none;
  padding: 6px 14px;
  border-radius: var(--radius);
  font-size: 11px;
  font-weight: 600;
  font-family: inherit;
  cursor: pointer;
  align-self: flex-start;
  white-space: nowrap;
  transition: background 0.15s;
  display: flex;
  align-items: center;
  gap: 4px;
}
.prompt-copy-btn svg { width: 12px; height: 12px; }
.prompt-copy-btn:hover { background: var(--accent-hover); }

/* ═══════════════ RIPPLE ANIMATION ═══════════════ */
@keyframes ripplePulse {
  0% { box-shadow: 0 0 0 0 rgba(99,102,241,0.4); }
  70% { box-shadow: 0 0 0 10px rgba(99,102,241,0); }
  100% { box-shadow: 0 0 0 0 rgba(99,102,241,0); }
}
.node.rippling { animation: ripplePulse 0.4s ease-out; }

/* ═══════════════ INFO POPUP ═══════════════ */
.info-popup-overlay {
  display: none;
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  background: rgba(0,0,0,0.5);
  z-index: 300;
  align-items: center;
  justify-content: center;
}
.info-popup-overlay.visible { display: flex; }
.info-popup {
  background: var(--panel-bg);
  border: 1px solid var(--border);
  border-radius: 8px;
  padding: 20px;
  max-width: 420px;
  width: 90%;
  box-shadow: 0 16px 48px rgba(0,0,0,0.5);
}
.info-popup-header {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 12px;
  font-size: 15px;
  font-weight: 700;
}
.info-popup-header svg { width: 22px; height: 22px; }
.info-popup-close {
  margin-left: auto;
  background: none;
  border: none;
  color: var(--text-secondary);
  cursor: pointer;
  font-size: 18px;
  padding: 2px 6px;
  border-radius: 4px;
  display: flex;
  align-items: center;
  transition: color 0.15s, background 0.15s;
}
.info-popup-close:hover { color: var(--text-primary); background: var(--surface); }
.info-popup-close svg { width: 14px; height: 14px; }
.info-popup-body {
  font-size: 12px;
  line-height: 1.6;
  color: var(--text-secondary);
}
.info-popup-body strong { color: var(--text-primary); font-weight: 600; }
.info-popup-body p { margin: 0 0 8px; }
.info-popup-section {
  margin-bottom: 10px;
}
.info-popup-section-title {
  font-size: 10px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  color: var(--text-secondary);
  margin-bottom: 4px;
}
.info-popup-list {
  margin: 0;
  padding-left: 16px;
}
.info-popup-list li { margin-bottom: 3px; }

/* Dashboard info icon */
.dash-info-btn {
  background: none;
  border: none;
  color: var(--text-secondary);
  cursor: pointer;
  padding: 0;
  display: inline-flex;
  align-items: center;
  opacity: 0.4;
  transition: opacity 0.15s, color 0.15s;
}
.dash-info-btn:hover { opacity: 1; color: var(--accent); }
.dash-info-btn svg { width: 9px; height: 9px; }

/* Clickable category icon on nodes */
.node-icon.clickable { cursor: pointer; transition: transform 0.15s; z-index: 6; position: relative; }
.node-icon.clickable:hover { transform: scale(1.2); }
.legend-item.clickable { cursor: pointer; transition: color 0.15s; }
.legend-item.clickable:hover { color: var(--text-primary) !important; }

/* Connection Health Indicator */
.conn-health-indicator { margin-top: 4px; }
.conn-health-badge {
  display: inline-flex;
  align-items: center;
  gap: 6px;
  padding: 4px 10px;
  border-radius: 4px;
  font-size: 11px;
  font-weight: 600;
  margin-bottom: 6px;
}
.conn-health-dot {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  flex-shrink: 0;
}
.conn-health-desc {
  font-size: 11px;
  color: var(--text-secondary);
  line-height: 1.5;
  margin-bottom: 8px;
}
.conn-health-endpoints {
  display: flex;
  flex-direction: column;
  gap: 4px;
  margin-bottom: 6px;
}
.conn-health-ep {
  display: flex;
  align-items: center;
  gap: 6px;
  font-size: 11px;
  color: var(--text-primary);
  background: var(--surface);
  padding: 4px 8px;
  border-radius: 4px;
}
.conn-health-rule {
  font-size: 9px;
  color: var(--text-secondary);
  font-style: italic;
  opacity: 0.7;
}
/* ═══════════════ CONNECTION HEALTH DETAIL ═══════════════ */
.conn-health-info-btn {
  width: 18px; height: 18px;
  border: none; background: none; cursor: pointer;
  color: var(--text-secondary); padding: 0; margin-left: 4px;
  border-radius: 50%; display: flex; align-items: center; justify-content: center;
  flex-shrink: 0; transition: color 0.15s, background 0.15s;
}
.conn-health-info-btn:hover { color: var(--accent); background: var(--accent)15; }
.conn-health-info-btn svg { width: 14px; height: 14px; }
.conn-health-metrics {
  display: none; padding: 6px 8px; margin-top: 4px;
  background: var(--canvas-bg); border-radius: 4px;
  border: 1px solid var(--border);
}
.conn-health-metrics.visible { display: block; }
.conn-health-metric-row {
  display: flex; align-items: center; gap: 6px;
  font-size: 10px; padding: 2px 0;
}
.conn-health-metric-name {
  width: 90px; color: var(--text-secondary); flex-shrink: 0;
}
.conn-health-metric-bar {
  flex: 1; height: 4px; background: var(--surface);
  border-radius: 2px; overflow: hidden; position: relative;
}
.conn-health-metric-fill {
  height: 100%; border-radius: 2px; transition: width 0.3s ease;
}
.conn-health-metric-val {
  width: 28px; text-align: right; font-weight: 600; font-size: 10px; flex-shrink: 0;
}
.conn-health-metric-flag {
  font-size: 9px; font-weight: 600; width: 12px; text-align: center; flex-shrink: 0;
}
.conn-health-metrics-label {
  font-size: 9px; color: var(--text-secondary); margin-bottom: 4px;
  text-transform: uppercase; letter-spacing: 0.5px; font-weight: 600;
}

/* ═══════════════ COLLAPSIBLE SECTIONS ═══════════════ */
.insp-section-title.collapsible {
  cursor: pointer;
  user-select: none;
  transition: color 0.15s;
}
.insp-section-title.collapsible:hover { color: var(--text-primary); }
.section-chevron {
  margin-left: auto;
  display: inline-flex;
  transition: transform 0.2s ease;
}
.section-chevron svg { width: 10px; height: 10px; }
.section-chevron.open { transform: rotate(90deg); }
.insp-section-body.collapsed { display: none; }
/* Collapsible toolbox cards */
.card-header.collapsible {
  cursor: pointer;
  user-select: none;
  transition: opacity 0.15s;
}
.card-header.collapsible:hover { opacity: 1; }
.card-header.collapsible .section-chevron { margin-left: auto; }
.card-details.collapsed { display: none; }

/* ═══════════════ METRIC DELTAS ═══════════════ */
.metric-delta {
  font-size: 10px;
  font-weight: 600;
  margin-left: 4px;
  display: inline-block;
  animation: deltaFadeIn 0.3s ease;
}
@keyframes deltaFadeIn {
  from { opacity: 0; transform: translateY(-4px); }
  to { opacity: 1; transform: translateY(0); }
}
.metric-delta.positive { color: var(--green); }
.metric-delta.negative { color: var(--red); }
.metric-delta.neutral { color: var(--text-secondary); }

/* ═══════════════ ISSUES SUMMARY ═══════════════ */
.issues-badge {
  position: absolute;
  top: -4px;
  right: -4px;
  background: var(--red);
  color: white;
  font-size: 9px;
  font-weight: 700;
  width: 16px;
  height: 16px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  pointer-events: none;
  line-height: 1;
}
.issues-badge.warning { background: var(--yellow); color: #000; }
.issues-badge.hidden { display: none; }
.issues-dropdown {
  position: fixed;
  background: var(--panel-bg);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 4px;
  min-width: 300px;
  z-index: 150;
  box-shadow: 0 8px 24px rgba(0,0,0,0.4);
  display: none;
}
.issues-dropdown.visible { display: block; }
.issues-dropdown-title {
  font-size: 10px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  color: var(--text-secondary);
  padding: 6px 8px 4px;
  display: flex;
  align-items: center;
  gap: 4px;
}
.issues-dropdown-title svg { width: 12px; height: 12px; }
.issues-item {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 6px 8px;
  border-radius: 4px;
  cursor: pointer;
  transition: background 0.1s;
  font-size: 11px;
}
.issues-item:hover { background: var(--surface); }
.issues-item svg { width: 14px; height: 14px; }
.issues-item-dot {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  flex-shrink: 0;
}
.issues-item-name { font-weight: 500; flex: 1; }
.issues-item-detail { color: var(--text-secondary); font-size: 10px; }
.issues-none {
  padding: 12px 8px;
  text-align: center;
  color: var(--text-secondary);
  font-size: 11px;
}

/* ═══════════════ VARIANT HINT ═══════════════ */
.variant-hint {
  background: var(--surface);
  border: 1px solid var(--border);
  border-left: 3px solid var(--accent);
  border-radius: var(--radius);
  padding: 6px 8px;
  margin-top: 6px;
  font-size: 10px;
  color: var(--text-secondary);
  line-height: 1.4;
  display: flex;
  align-items: flex-start;
  gap: 4px;
}
.variant-hint svg { width: 12px; height: 12px; flex-shrink: 0; margin-top: 1px; }
.variant-hint strong { color: var(--accent); font-weight: 600; }
.variant-hint .delta-positive { color: var(--green); font-weight: 600; }
.variant-hint .delta-negative { color: var(--red); font-weight: 600; }

/* ═══════════════ METRIC THRESHOLD ═══════════════ */
.metric-threshold {
  position: absolute;
  top: -1px;
  bottom: -1px;
  width: 1px;
  background: var(--text-secondary);
  opacity: 0.25;
  z-index: 1;
}

/* ═══════════════ DASHBOARD CLICKABLE ═══════════════ */
.dash-bar-track.clickable { cursor: pointer; transition: opacity 0.15s; }
.dash-bar-track.clickable:hover { opacity: 0.85; }
.node.flash-highlight { animation: nodeFlash 0.8s ease; }
@keyframes nodeFlash {
  0%, 100% { box-shadow: 0 0 0 0 rgba(99,102,241,0); }
  50% { box-shadow: 0 0 20px 4px rgba(99,102,241,0.5); }
}
</style>
</head>
<body>

<!-- ═══════════════ TOP BAR ═══════════════ -->
<div class="top-bar">
  <div class="logo">
    <svg viewBox="0 0 18 18" fill="none" stroke="currentColor" stroke-width="1.5"><rect x="2" y="2" width="14" height="14" rx="3"/><circle cx="6" cy="7" r="1.5" fill="currentColor" stroke="none"/><circle cx="12" cy="7" r="1.5" fill="currentColor" stroke="none"/><path d="M6 7h6M9 7v5"/></svg>
    Archie
  </div>
  <div class="arch-name">Twitter Home Timeline Architecture</div>
  <div class="tier-badge" onclick="showTierInfo()" style="cursor:pointer" title="Click for tier details">
    <svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M8 1l2.5 4.5L16 6.5l-4 3.5 1 5.5L8 13l-5 2.5 1-5.5-4-3.5 5.5-1z"/></svg>
    Tier 2 <span class="tier-hint">/ 3</span>
  </div>
  <div class="top-actions">
    <button class="top-btn" id="heatmapToggle" onclick="toggleHeatmap()">
      <svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><circle cx="8" cy="8" r="6"/><circle cx="8" cy="8" r="3" opacity="0.5"/><circle cx="8" cy="8" r="1" fill="currentColor" stroke="none"/></svg>
      Heatmap
    </button>
    <button class="top-btn" id="issuesBtn" onclick="toggleIssues()" style="position:relative">
      <svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M8 2L1 14h14z"/><path d="M8 6v4M8 12v.5"/></svg>
      Issues
      <span class="issues-badge hidden" id="issuesBadge">0</span>
    </button>
    <button class="top-btn" onclick="togglePanel('toolbox')">
      <svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><rect x="2" y="2" width="5" height="12" rx="1"/><rect x="9" y="2" width="5" height="5" rx="1"/><rect x="9" y="9" width="5" height="5" rx="1"/></svg>
      Toolbox
    </button>
    <button class="top-btn" onclick="togglePanel('inspector')">
      <svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><rect x="2" y="2" width="12" height="12" rx="1"/><line x1="8" y1="2" x2="8" y2="14"/><line x1="8" y1="6" x2="14" y2="6"/><line x1="8" y1="10" x2="14" y2="10"/></svg>
      Inspector
    </button>
    <button class="top-btn">
      <svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M3 14V9l5-7 5 7v5"/><path d="M6 14v-3h4v3"/></svg>
      Import
    </button>
    <button class="top-btn">
      <svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M4 2h8l2 3v9H2V5z"/><path d="M5 2v3h6V2"/><circle cx="8" cy="10" r="2"/></svg>
      Export
    </button>
  </div>
</div>

<!-- ═══════════════ MAIN LAYOUT ═══════════════ -->
<div class="main-layout">
  <!-- TOOLBOX -->
  <aside class="toolbox" id="toolbox">
    <div class="toolbox-title">
      <svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><rect x="2" y="2" width="5" height="12" rx="1"/><rect x="9" y="2" width="5" height="5" rx="1"/><rect x="9" y="9" width="5" height="5" rx="1"/></svg>
      Toolbox
    </div>
    <div class="toolbox-tabs">
      <button class="toolbox-tab active" onclick="switchTab(this,'components')">
        <svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><rect x="2" y="2" width="5" height="5" rx="1"/><rect x="9" y="2" width="5" height="5" rx="1"/><rect x="2" y="9" width="5" height="5" rx="1"/><rect x="9" y="9" width="5" height="5" rx="1"/></svg>
        Components
      </button>
      <button class="toolbox-tab" onclick="switchTab(this,'stacks')">
        <svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><rect x="3" y="2" width="10" height="3" rx="1"/><rect x="3" y="7" width="10" height="3" rx="1"/><rect x="3" y="12" width="10" height="3" rx="1"/></svg>
        Stacks
      </button>
      <button class="toolbox-tab" onclick="switchTab(this,'blueprints')">
        <svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 2h12v12H2z"/><path d="M5 5h6M5 8h6M5 11h3"/><circle cx="12" cy="11" r="1" fill="currentColor" stroke="none"/></svg>
        Blueprints
      </button>
    </div>
    <div class="toolbox-content" id="toolboxContent"></div>
  </aside>

  <!-- CANVAS -->
  <main class="canvas" id="canvas">
    <svg class="canvas-svg" id="flowSvg" style="z-index:0"></svg>
    <svg class="canvas-svg" id="canvasSvg"></svg>
    <div id="nodesContainer"></div>
    <!-- Legend -->
    <div class="canvas-legend" id="canvasLegend"></div>
    <div class="canvas-hint">
      <svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><circle cx="8" cy="8" r="6"/><path d="M8 5v3M8 10v1"/></svg>
      Click a component to inspect &middot; Toggle heatmap to see health overlay
    </div>
    <!-- DASHBOARD — inside canvas, at bottom -->
    <div class="dashboard" id="dashboard">
      <div class="dashboard-title">
        <svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><rect x="1" y="8" width="3" height="6" rx="0.5"/><rect x="5.5" y="5" width="3" height="9" rx="0.5"/><rect x="10" y="2" width="3" height="12" rx="0.5"/></svg>
        Architecture Health
        <button class="dash-expand-btn" onclick="toggleDashboardExpand()" title="Show contributing factors">
          <svg class="dash-expand-chevron" viewBox="0 0 10 10" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2.5 4L5 6.5L7.5 4"/></svg>
        </button>
      </div>
      <div class="dashboard-bars" id="dashboardBars"></div>
    </div>
    <!-- DASHBOARD EXPANDED OVERLAY -->
    <div class="dash-overlay" id="dashOverlay">
      <div class="dash-overlay-header">
        <svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><rect x="1" y="8" width="3" height="6" rx="0.5"/><rect x="5.5" y="5" width="3" height="9" rx="0.5"/><rect x="10" y="2" width="3" height="12" rx="0.5"/></svg>
        Architecture Health — 7 Metric Categories
        <button class="dash-overlay-close" onclick="toggleDashboardExpand()" title="Close details">&times;</button>
      </div>
      <div class="dash-overlay-grid" id="dashOverlayGrid"></div>
    </div>
  </main>

  <!-- INSPECTOR -->
  <aside class="inspector" id="inspector">
    <div class="inspector-header">
      <svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><rect x="2" y="2" width="12" height="12" rx="1"/><line x1="8" y1="2" x2="8" y2="14"/><line x1="8" y1="6" x2="14" y2="6"/><line x1="8" y1="10" x2="14" y2="10"/></svg>
      Inspector
    </div>
    <div class="inspector-content" id="inspectorContent">
      <div class="inspector-empty">
        <svg viewBox="0 0 32 32" fill="none" stroke="currentColor" stroke-width="1"><circle cx="16" cy="16" r="12"/><path d="M16 10v6M16 20v1"/></svg>
        Click a component on the canvas to see its details, metrics, and configuration variants.
      </div>
    </div>
  </aside>
</div>

<!-- ═══════════════ PROMPT OUTPUT ═══════════════ -->
<div class="prompt-section" id="promptSection">
  <button class="prompt-toggle" onclick="document.getElementById('promptSection').classList.toggle('open')">
    <svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><rect x="2" y="2" width="12" height="12" rx="2"/><path d="M5 6h6M5 8h6M5 10h4"/></svg>
    Prompt Output
  </button>
  <div class="prompt-body">
    <div class="prompt-text" id="promptText"></div>
    <button class="prompt-copy-btn" onclick="copyPrompt()">
      <svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><rect x="5" y="5" width="9" height="9" rx="1"/><path d="M5 11H3a1 1 0 01-1-1V3a1 1 0 011-1h7a1 1 0 011 1v2"/></svg>
      Copy Prompt
    </button>
  </div>
</div>

<!-- ═══════════════ INFO POPUP ═══════════════ -->
<div class="info-popup-overlay" id="infoPopupOverlay" onclick="if(event.target===this)hideInfoPopup()">
  <div class="info-popup">
    <div class="info-popup-header" id="infoPopupHeader"></div>
    <div class="info-popup-body" id="infoPopupBody"></div>
  </div>
</div>

<!-- Issues Dropdown (fixed position, placed by JS) -->
<div class="issues-dropdown" id="issuesDropdown"></div>

<script>
// ═══════════════ SVG ICONS ═══════════════
const ICONS = {
  // Category icons
  'Compute': '<svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><rect x="4" y="4" width="8" height="8" rx="1"/><line x1="6" y1="2" x2="6" y2="4"/><line x1="10" y1="2" x2="10" y2="4"/><line x1="6" y1="12" x2="6" y2="14"/><line x1="10" y1="12" x2="10" y2="14"/><line x1="2" y1="6" x2="4" y2="6"/><line x1="2" y1="10" x2="4" y2="10"/><line x1="12" y1="6" x2="14" y2="6"/><line x1="12" y1="10" x2="14" y2="10"/></svg>',
  'Data Storage': '<svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><ellipse cx="8" cy="4" rx="5" ry="2"/><path d="M3 4v8c0 1.1 2.24 2 5 2s5-.9 5-2V4"/><path d="M3 8c0 1.1 2.24 2 5 2s5-.9 5-2" opacity="0.5"/></svg>',
  'Caching': '<svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M9 1L4 9h4l-1 6 5-8H8l1-6z" stroke-linejoin="round"/></svg>',
  'Messaging': '<svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 3h12v8H6l-4 3V3z" stroke-linejoin="round"/></svg>',
  'Delivery/Network': '<svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><circle cx="8" cy="8" r="6"/><ellipse cx="8" cy="8" rx="3" ry="6"/><line x1="2" y1="8" x2="14" y2="8"/></svg>',
  'Real-Time': '<svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 8h2l2-4 2 8 2-5 2 3h2"/></svg>',
  'Auth/Security': '<svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M8 1L2 4v4c0 4 2.5 6 6 7 3.5-1 6-3 6-7V4L8 1z"/></svg>',
  'Monitoring': '<svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><rect x="2" y="2" width="12" height="12" rx="1"/><path d="M4 10l3-4 2 2 3-4"/></svg>',
  'Search': '<svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><circle cx="7" cy="7" r="4"/><line x1="10" y1="10" x2="14" y2="14"/></svg>',
  'DevOps': '<svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><circle cx="8" cy="8" r="2"/><path d="M8 2v2M8 12v2M2 8h2M12 8h2M3.8 3.8l1.4 1.4M10.8 10.8l1.4 1.4M3.8 12.2l1.4-1.4M10.8 5.2l1.4-1.4"/></svg>',
  // UI icons
  'is': '<svg viewBox="0 0 10 10" fill="none" stroke="currentColor" stroke-width="1.5"><circle cx="5" cy="5" r="3.5"/></svg>',
  'gain': '<svg viewBox="0 0 10 10" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M5 2v6M2 5l3-3 3 3"/></svg>',
  'cost': '<svg viewBox="0 0 10 10" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M5 8V2M2 5l3 3 3-3"/></svg>',
  'config': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.5"><circle cx="6" cy="6" r="2"/><path d="M6 1v2M6 9v2M1 6h2M9 6h2"/></svg>',
  'metrics': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.5"><rect x="1" y="6" width="2" height="5" rx="0.5"/><rect x="5" y="3" width="2" height="8" rx="0.5"/><rect x="9" y="1" width="2" height="10" rx="0.5"/></svg>',
  'pros': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.5"><circle cx="6" cy="6" r="4.5"/><path d="M4 6h4M6 4v4"/></svg>',
  'cons': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.5"><circle cx="6" cy="6" r="4.5"/><path d="M4 6h4"/></svg>',
  // Dashboard category icons
  'perf': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M2 10l3-5 2 2 3-5"/><path d="M9 2h2v2"/></svg>',
  'cost_dash': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><circle cx="6" cy="6" r="4"/><path d="M6 3v6M4.5 4.5h3M4.5 7.5h3"/></svg>',
  'rel': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M6 1L1.5 4v3.5c0 2.5 1.8 4 4.5 4.5 2.7-.5 4.5-2 4.5-4.5V4L6 1z"/></svg>',
  'ops': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><circle cx="6" cy="6" r="2"/><path d="M6 1v1.5M6 9.5V11M1 6h1.5M9.5 6H11M2.8 2.8l1 1M8.2 8.2l1 1M2.8 9.2l1-1M8.2 3.8l1-1"/></svg>',
  'scale': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M2 10V6l4-4 4 4v4"/></svg>',
  'strat': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><circle cx="6" cy="4" r="2"/><path d="M6 6v4M3 8h6"/></svg>',
  'dev_dash': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M4 3L1 6l3 3M8 3l3 3-3 3"/></svg>',
  // Data context icons
  'data_ctx': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><rect x="1" y="1" width="10" height="10" rx="1"/><path d="M4 4h4M4 6h4M4 8h2"/></svg>',
  'edit': '<svg viewBox="0 0 10 10" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M1 9l6-6 1 1-6 6z"/><path d="M6 3l1-1 2 2-1 1"/></svg>',
  'session': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><circle cx="6" cy="4" r="2.5"/><path d="M2 10c0-2.2 1.8-4 4-4s4 1.8 4 4"/></svg>',
  'counter': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M2 10V5l2-3 2 4 2-2 2 3v3"/></svg>',
  'cache_item': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><rect x="2" y="2" width="8" height="8" rx="1"/><path d="M5 4v4M4 7l1 1 1-1"/></svg>',
  'table': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><rect x="1" y="1" width="10" height="10" rx="1"/><line x1="1" y1="4" x2="11" y2="4"/><line x1="5" y1="4" x2="5" y2="11"/></svg>',
  'message': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M2 2h8v6H5l-3 2V2z"/></svg>',
  'endpoint': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M1 6h4M7 6h4"/><circle cx="6" cy="6" r="2"/></svg>',
  'route': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M2 2l8 8M2 5h3M7 9h3"/></svg>',
  'event': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M7 1L3 7h3l-1 4 4-6H6l1-4z"/></svg>',
  'receipt': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M2 6l3 3 5-5"/></svg>',
  'presence': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><circle cx="6" cy="6" r="3"/><circle cx="6" cy="6" r="1" fill="currentColor" stroke="none"/></svg>',
  'ssl': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><rect x="3" y="5" width="6" height="5" rx="1"/><path d="M4 5V4a2 2 0 014 0v1"/></svg>',
  'ratelimit': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><circle cx="6" cy="6" r="4.5"/><path d="M6 3v3l2 1"/></svg>',
  // Metric-specific icons
  'latency': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><circle cx="6" cy="6" r="4.5"/><path d="M6 3.5v3l2 1.5"/></svg>',
  'throughput': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M1 6h10M8 3l3 3-3 3"/></svg>',
  'cost_eff': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><circle cx="6" cy="6" r="4"/><path d="M6 3v6M4.5 4.5h3M4.5 7.5h3"/></svg>',
  'simplicity': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M3 4h6M3 6h6M3 8h4"/></svg>',
  'read_perf': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><circle cx="6" cy="5" r="3"/><path d="M1 5c2-3 8-3 10 0M1 5c2 3 8 3 10 0"/></svg>',
  'write_perf': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M2 10l7-7 1 1-7 7z"/><path d="M8 3l1-1 2 2-1 1"/></svg>',
  'scalability': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M2 10V6l4-4 4 4v4"/></svg>',
  'consistency': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M2 6h8M4 3h4M4 9h4"/></svg>',
  'ordering': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M3 3h6M3 6h4M3 9h2"/></svg>',
  'code': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M4 3L1 6l3 3"/><path d="M8 3l3 3-3 3"/><line x1="7" y1="2" x2="5" y2="10"/></svg>',
  // Connection property icons
  'protocol': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M2 6h8"/><circle cx="2" cy="6" r="1.5"/><circle cx="10" cy="6" r="1.5"/></svg>',
  'pattern': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M2 6h2l1-3 2 6 1-3h2"/></svg>',
  'speed': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><circle cx="6" cy="7" r="4"/><path d="M6 7l2-3"/><path d="M3 7h1M8 7h1"/></svg>',
  'coloc': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><rect x="1" y="3" width="10" height="6" rx="1"/><line x1="6" y1="3" x2="6" y2="9"/></svg>',
  'conn': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M1 6h3M8 6h3"/><rect x="4" y="3" width="4" height="6" rx="1"/></svg>',
  'arrow_right': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M2 6h8M7 3l3 3-3 3"/></svg>',
  'arrow_bidir': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M2 6h8M4 3L1 6l3 3M8 3l3 3-3 3"/></svg>',
  'info': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><circle cx="6" cy="6" r="5"/><path d="M6 5.5v3"/><circle cx="6" cy="3.5" r="0.5" fill="currentColor" stroke="none"/></svg>',
  'close': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M3 3l6 6M9 3l-6 6"/></svg>',
  'chevron': '<svg viewBox="0 0 10 10" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M3 2l4 3-4 3"/></svg>',
  // New metric icons
  'reliability': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M6 1L1.5 4v3.5c0 2.5 1.8 4 4.5 4.5 2.7-.5 4.5-2 4.5-4.5V4L6 1z"/></svg>',
  'portability': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M6 1v10M1 6h10"/><circle cx="6" cy="6" r="4.5"/><path d="M2.5 4h7M2.5 8h7"/></svg>',
  'learning': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M1 4.5l5-2.5 5 2.5-5 2.5z"/><path d="M2.5 5.5v3c0 1 1.5 1.5 3.5 1.5s3.5-.5 3.5-1.5v-3"/></svg>',
  'filter': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M1.5 2h9L7.5 6v3.5L4.5 11V6z"/></svg>'
};

// Map metric names to icon keys
const METRIC_ICON_MAP = {
  'Latency': 'latency', 'Throughput': 'throughput', 'Cost Efficiency': 'cost_eff',
  'Op. Simplicity': 'simplicity', 'Read Perf': 'read_perf', 'Write Perf': 'write_perf',
  'Scalability': 'scalability', 'Consistency': 'consistency', 'Ordering': 'ordering',
  'Reliability': 'reliability', 'Portability': 'portability', 'Learning Curve': 'learning'
};

// Metric explanations — why each component+variant scores the way it does
const METRIC_EXPLANATIONS = {
  'load-balancer': {
    'nginx': {
      'Latency': { reason: 'Nginx is written in C with an event-driven architecture, adding only 1-3ms of reverse proxy overhead.', factors: ['Event-driven, non-blocking I/O', 'Compiled C code, near-hardware speed', 'Minimal processing per request'] },
      'Throughput': { reason: 'Handles tens of thousands of concurrent connections with ~2KB memory per connection.', factors: ['Worker process model scales to CPU cores', 'Efficient keepalive connection pooling', 'No managed-service throttle limits'] },
      'Cost Efficiency': { reason: 'Open-source, runs on commodity hardware, no per-request billing.', factors: ['No license fees', 'Low CPU and memory footprint', 'Operational cost for self-management'] },
      'Op. Simplicity': { reason: 'Config-file driven with no GUI. Manual health checks and SSL management.', factors: ['Nginx config syntax requires learning', 'No dynamic service discovery', 'Manual certificate management'] },
      'Reliability': { reason: 'Stable and battle-tested, but requires manual HA setup (keepalived, multiple instances).', factors: ['No automatic failover without external tools', 'Worker crash recovery is fast', 'Requires monitoring setup'] },
      'Portability': { reason: 'Fully open-source, runs anywhere Linux runs. Config files portable.', factors: ['BSD license, no vendor lock-in', 'Runs on VMs, bare metal, containers', 'Config is Nginx-specific but well-documented'] },
      'Learning Curve': { reason: 'Config syntax is unique and requires practice. No GUI simplifies initial barrier.', factors: ['Config syntax has conventions to learn', 'Debugging via logs only', 'Large community support'] }
    },
    'aws-alb': {
      'Latency': { reason: 'Managed service adds network hops: edge → regional LB → targets. Higher than self-hosted.', factors: ['Multi-hop architecture', 'Potential cold-start on new connections', 'AWS network overhead'] },
      'Throughput': { reason: 'Auto-scales to handle traffic but with AWS-imposed soft limits and billing throttles.', factors: ['Auto-scaling handles spikes', 'Default limits apply (configurable)', 'Managed service overhead'] },
      'Cost Efficiency': { reason: 'Pay-per-hour plus per-GB processed. Expensive at high traffic volumes.', factors: ['~$16/month base + $0.008/LCU-hour', 'Data transfer charges', 'Cost grows with traffic'] },
      'Op. Simplicity': { reason: 'Fully managed: zero server ops, auto-scaling, built-in monitoring.', factors: ['No server management', 'CloudWatch integration', 'Simple console configuration'] },
      'Reliability': { reason: 'AWS-managed with 99.99% SLA, multi-AZ by default, automatic failover.', factors: ['99.99% SLA', 'Multi-AZ deployment', 'Automatic health checks'] },
      'Portability': { reason: 'AWS-specific. Migration requires reconfiguring LB on new platform.', factors: ['AWS-only service', 'Config not portable to other clouds', 'Ties to AWS networking'] },
      'Learning Curve': { reason: 'AWS console is intuitive, good docs. IAM permissions add complexity.', factors: ['Console-driven setup', 'Well-documented', 'IAM learning curve'] }
    },
    'envoy': {
      'Latency': { reason: 'Modern C++ proxy with fast request processing, but richer feature set adds slight overhead vs raw Nginx.', factors: ['C++ compiled binary', 'Dynamic config processing', 'gRPC/HTTP/2 support'] },
      'Throughput': { reason: 'High throughput, optimized for service mesh use cases with concurrent request handling.', factors: ['Async I/O model', 'Efficient connection pooling', 'Multi-protocol support'] },
      'Cost Efficiency': { reason: 'Open-source, self-hosted. Operational complexity slightly higher than Nginx.', factors: ['No license cost', 'Requires orchestration (e.g., with Istio)', 'More resource-intensive than Nginx'] },
      'Op. Simplicity': { reason: 'Complex config (YAML/JSON), designed for service mesh orchestration, not standalone use.', factors: ['Dynamic config via xDS APIs', 'Steep learning curve', 'Requires control plane (Istio, Consul)'] },
      'Reliability': { reason: 'Battle-tested in large-scale service meshes, but complexity increases failure surface.', factors: ['Proven in production at scale', 'Dynamic config can introduce errors', 'Health checks and outlier detection built-in'] },
      'Portability': { reason: 'Open-source (Apache 2.0), cloud-agnostic, but often tied to service mesh infrastructure.', factors: ['Open-source, portable', 'Config format is Envoy-specific', 'Works best with control plane'] },
      'Learning Curve': { reason: 'Hardest of the three: config is verbose, dynamic xDS APIs require deep understanding.', factors: ['Verbose YAML config', 'xDS control plane concepts', 'Service mesh architecture knowledge'] }
    }
  },
  'timeline-api': {
    'express': {
      'Latency': { reason: 'Middleware chain processes sequentially. No built-in optimization for JSON serialization.', factors: ['Middleware adds ~0.1ms each', 'No schema compilation', 'Simple routing'] },
      'Throughput': { reason: 'Single-threaded event loop. JSON.stringify on every response, no optimization.', factors: ['No compiled serializers', 'Standard JSON.stringify overhead', 'Middleware chain accumulates'] },
      'Cost Efficiency': { reason: 'Minimal footprint, low memory usage, runs anywhere.', factors: ['Tiny package size', '~30MB baseline memory', 'No license cost'] },
      'Op. Simplicity': { reason: 'Minimal, unopinionated. Easy to start, but manual structure at scale.', factors: ['5 lines to working server', 'Massive ecosystem', 'No enforced patterns'] },
      'Reliability': { reason: 'No built-in error boundaries. Uncaught exceptions crash the process.', factors: ['Uncaught exceptions fatal', 'No clustering built-in', 'Manual error handling'] },
      'Portability': { reason: 'Standard Node.js, MIT license. Runs anywhere.', factors: ['Open-source', 'No proprietary APIs', 'Widely portable'] },
      'Learning Curve': { reason: 'Most JS developers productive within hours. Huge community.', factors: ['Familiar patterns', 'Massive community', 'Simple API'] }
    },
    'fastify': {
      'Latency': { reason: 'Compiles JSON schemas at startup into fast serializers, reducing per-request overhead.', factors: ['fast-json-stringify compilation', 'Radix-tree routing', 'Schema validation optimized'] },
      'Throughput': { reason: '2-3x faster than Express due to compiled serialization and efficient routing.', factors: ['Compiled JSON serializers', 'Efficient routing', 'Lower per-request overhead'] },
      'Cost Efficiency': { reason: 'Higher throughput per instance means fewer servers for same load.', factors: ['Fewer instances needed', 'Comparable memory to Express', 'Open-source'] },
      'Op. Simplicity': { reason: 'Plugin system differs from Express middleware. Schema-first requires design upfront.', factors: ['Plugin encapsulation', 'Schema-first mindset', 'Smaller community'] },
      'Reliability': { reason: 'Schema validation catches bad input early. Plugin encapsulation isolates failures.', factors: ['Schema validation', 'Encapsulated plugins', 'onError hooks'] },
      'Portability': { reason: 'Open-source, standard Node.js. Plugin patterns are Fastify-specific but portable.', factors: ['MIT license', 'Standard Node.js', 'Plugin API portable'] },
      'Learning Curve': { reason: 'Different from Express: plugin system and schema-first require mental model shift.', factors: ['Plugin vs middleware', 'JSON Schema required', 'Smaller community'] }
    },
    'go-api': {
      'Latency': { reason: 'Compiled Go binary with goroutines for concurrency. Minimal per-request overhead.', factors: ['Native compiled speed', 'Goroutines for parallelism', 'Efficient struct serialization'] },
      'Throughput': { reason: 'Go\'s goroutines enable massive concurrency. Handles more requests per instance than Node.', factors: ['Goroutines scale to thousands', 'Compiled performance', 'Efficient runtime'] },
      'Cost Efficiency': { reason: 'Higher throughput means fewer instances. Compiles to single binary.', factors: ['Fewer servers needed', 'Low memory per goroutine', 'No runtime dependencies'] },
      'Op. Simplicity': { reason: 'Single binary deployment is simple, but lacks Node.js ecosystem richness.', factors: ['Single binary', 'No runtime needed', 'Smaller web ecosystem'] },
      'Reliability': { reason: 'Strong type safety catches errors at compile time. Panic recovery for runtime errors.', factors: ['Compile-time type checking', 'Panic recovery', 'Stable runtime'] },
      'Portability': { reason: 'Cross-compiles to any OS. BSD license, no vendor lock-in.', factors: ['Cross-platform', 'Open-source', 'No dependencies'] },
      'Learning Curve': { reason: 'Different paradigm from Node.js: static typing, goroutines, error handling.', factors: ['Static typing', 'Goroutine concurrency model', 'Explicit error handling'] }
    }
  },
  'fanout-service': {
    'fanout-write': {
      'Read Perf': { reason: 'Timelines are pre-built in cache. Reads are instant cache lookups.', factors: ['Pre-computed timelines', 'Redis LIST LRANGE operation', 'No database query needed'] },
      'Write Perf': { reason: 'Every tweet triggers N cache writes (N = follower count). Celebrity = millions of writes.', factors: ['Write amplification by follower count', '10M followers = 10M cache writes', 'Synchronous or queued, still expensive'] },
      'Scalability': { reason: 'Celebrity bottleneck: a single tweet can take minutes to fan out. Not horizontally scalable for celebs.', factors: ['Single celebrity post blocks fan-out queue', 'Cannot parallelize per-tweet (same followers)', 'Celebrity edge case kills scaling'] },
      'Cost Efficiency': { reason: 'High cache memory cost (per-user timelines) and expensive writes.', factors: ['Memory cost per user', 'Wasted writes if user never reads', 'High write throughput needed'] },
      'Op. Simplicity': { reason: 'Simple write logic: loop over followers, push to cache. But queue management needed.', factors: ['Straightforward fan-out loop', 'Queue to handle bursts', 'Celebrity edge case requires special handling'] },
      'Reliability': { reason: 'Cache dependency: if cache fails, timelines vanish. Requires cache replication.', factors: ['Cache is single source of truth', 'Cache failure = timeline loss', 'Replication adds complexity'] },
      'Learning Curve': { reason: 'Simple concept: pre-compute timelines at write time. Edge cases add complexity.', factors: ['Intuitive pre-computation model', 'Celebrity edge case non-obvious', 'Queue tuning required'] }
    },
    'fanout-read': {
      'Read Perf': { reason: 'Timeline reads query database for all followed users\' tweets. Slow at scale.', factors: ['Query all followed users', 'JOIN or multi-query', 'Sort and limit on app side'] },
      'Write Perf': { reason: 'Writes are single tweet INSERT. No fan-out, no amplification.', factors: ['Single DB write per tweet', 'No cache updates', 'Cheap and fast writes'] },
      'Scalability': { reason: 'Writes scale linearly. Reads are the bottleneck but cacheable at user level.', factors: ['Writes scale with tweet volume', 'Read caching per user helps', 'Database can handle celebrity writes'] },
      'Cost Efficiency': { reason: 'No per-user cache storage. Database queries on every read, but cheaper overall.', factors: ['No cache storage cost', 'Database read cost', 'Cheaper for write-heavy celebs'] },
      'Op. Simplicity': { reason: 'Simple write path. Read path requires complex query logic and caching strategy.', factors: ['Simple tweet INSERT', 'Complex read query construction', 'Cache invalidation needed'] },
      'Reliability': { reason: 'Database is source of truth. Reads can be cached, but cache misses hit DB.', factors: ['Database-backed reliability', 'Cache optional, not critical', 'Read latency on cache miss'] },
      'Learning Curve': { reason: 'Requires understanding query optimization, indexing, and read caching strategies.', factors: ['Query optimization critical', 'Index tuning needed', 'Caching strategy non-trivial'] }
    },
    'hybrid': {
      'Read Perf': { reason: 'Fast for normal users (cached), slower for celebrity followers (query-time merge).', factors: ['Cached reads for normal users', 'Celebrity tweets queried on read', 'Merge logic adds complexity'] },
      'Write Perf': { reason: 'Normal users fan out (fast), celebrities skip fan-out (instant).', factors: ['Fan-out for normal users', 'Single INSERT for celebrities', 'Threshold logic adds overhead'] },
      'Scalability': { reason: 'Scales well: celebrities don\'t fan out, normal users do. Best of both.', factors: ['Celebrity writes don\'t amplify', 'Normal user fan-out parallelizes', 'Threshold tuning needed'] },
      'Cost Efficiency': { reason: 'Balances cache cost (normal users) vs query cost (celebrity followers).', factors: ['Cache cost for majority', 'Query cost for celebrity followers', 'Overall cheaper than pure fan-out'] },
      'Op. Simplicity': { reason: 'Most complex: two code paths, threshold management, merge logic on reads.', factors: ['Two write paths', 'Celebrity threshold logic', 'Read-time merge for celebs'] },
      'Reliability': { reason: 'Dual dependency: cache for normal, database for celebs. More failure modes.', factors: ['Cache and DB both critical', 'Merge logic can fail', 'Debugging is harder'] },
      'Learning Curve': { reason: 'Hardest approach: requires understanding both fan-out strategies and when to use each.', factors: ['Two mental models', 'Threshold tuning non-obvious', 'Debugging is complex'] }
    }
  },
  'tweet-store': {
    'postgresql': {
      'Read Perf': { reason: 'JOINs between tweets, users, and follows add query planning overhead. Fast with proper indexes.', factors: ['Multi-table JOINs for timeline queries', 'Indexed lookups on author_id and created_at', 'Query planner optimizes join order'] },
      'Write Perf': { reason: 'Single INSERT per tweet. ACID transactions ensure consistency.', factors: ['Single-row INSERT per tweet', 'Indexed foreign keys (author_id)', 'WAL write for durability'] },
      'Scalability': { reason: 'Vertical scaling for writes. Read replicas help reads but JOINs limit horizontal scaling.', factors: ['Write bottleneck on primary', 'Read replicas for read scaling', 'Foreign key constraints limit sharding'] },
      'Consistency': { reason: 'Full ACID compliance. Strongest consistency guarantees.', factors: ['ACID transactions', 'Foreign key enforcement', 'Immediate consistency'] },
      'Op. Simplicity': { reason: 'Standard PostgreSQL. Well-understood operational model.', factors: ['Standard PostgreSQL tooling', 'Mature backup/restore', 'Schema migrations via DDL'] },
      'Reliability': { reason: 'Decades of battle-testing. WAL for crash recovery, streaming replication for HA.', factors: ['WAL ensures durability', 'Streaming replication', 'Point-in-time recovery'] },
      'Learning Curve': { reason: 'SQL is widely taught. Relational modeling is standard curriculum.', factors: ['SQL is universal', 'Extensive documentation', 'Large community'] }
    },
    'cassandra': {
      'Read Perf': { reason: 'Partition by author_id for fast single-user queries. Cross-partition queries slower.', factors: ['Single-partition reads are fast', 'Clustering order on timestamp', 'No JOINs — denormalized reads'] },
      'Write Perf': { reason: 'Optimized for writes. Append-only log structure, no random I/O.', factors: ['Append-only writes', 'Parallel writes across nodes', 'No foreign key checks'] },
      'Scalability': { reason: 'Linear horizontal scaling. Add nodes to increase capacity.', factors: ['Linear scale-out', 'No single write bottleneck', 'Multi-datacenter replication'] },
      'Consistency': { reason: 'Tunable consistency. Eventual consistency by default.', factors: ['Configurable consistency levels', 'Eventual consistency default', 'No ACID transactions'] },
      'Op. Simplicity': { reason: 'Complex operational model. Requires understanding of partitioning, compaction, repair.', factors: ['Nodetool for ops', 'Compaction tuning needed', 'Repair required for consistency'] },
      'Reliability': { reason: 'No single point of failure. Replicas ensure availability.', factors: ['Replication factor ensures durability', 'No SPOF', 'Self-healing via gossip'] },
      'Learning Curve': { reason: 'Steep curve: CQL looks like SQL but behaves differently. Partition design critical.', factors: ['CQL vs SQL differences', 'Partition key design', 'Denormalization required'] }
    },
    'dynamodb': {
      'Read Perf': { reason: 'Partition by author_id. Fast single-partition queries, GSI for timeline queries.', factors: ['Single-partition reads fast', 'GSI for secondary access patterns', 'Auto-scaling for throughput'] },
      'Write Perf': { reason: 'Fast single-item writes. Auto-scaling handles bursts.', factors: ['Sub-10ms writes', 'Auto-scaling capacity', 'On-demand billing option'] },
      'Scalability': { reason: 'Auto-scales transparently. Handles massive scale with no ops overhead.', factors: ['Auto-scaling built-in', 'No node management', 'Handles petabyte scale'] },
      'Consistency': { reason: 'Eventual consistency by default. Strong consistency available but slower.', factors: ['Eventual by default', 'Strong consistency option', 'Transaction support (limited)'] },
      'Op. Simplicity': { reason: 'Fully managed. Zero operational overhead for scaling, backups, patches.', factors: ['Fully managed service', 'Auto-backups', 'No patching needed'] },
      'Reliability': { reason: 'AWS-managed 99.99% SLA. Multi-AZ replication by default.', factors: ['99.99% SLA', 'Multi-AZ by default', 'Point-in-time recovery'] },
      'Learning Curve': { reason: 'Key-value model requires rethinking data access patterns. GSI design non-trivial.', factors: ['NoSQL data modeling', 'Partition key design', 'GSI cost optimization'] }
    }
  },
  'timeline-cache': {
    'redis': {
      'Read Perf': { reason: 'Sub-millisecond reads from memory. LIST LRANGE for timeline retrieval is extremely fast.', factors: ['In-memory reads <1ms', 'LIST data structure optimized for ranges', 'No disk I/O on reads'] },
      'Write Perf': { reason: 'Fast in-memory writes. LPUSH to prepend tweets to timeline lists. Single-threaded limits throughput.', factors: ['In-memory writes ~0.1ms', 'Single-threaded bottleneck', 'AOF persistence adds latency'] },
      'Scalability': { reason: 'Single-threaded limits write throughput. Clustering required for horizontal scaling.', factors: ['Single-threaded Redis', 'Clustering for scale-out', 'Memory-bound scaling'] },
      'Cost Efficiency': { reason: 'Memory cost per user. Cached timelines use significant RAM.', factors: ['Per-user timeline memory cost', 'No disk storage', 'Memory scales with user count'] },
      'Op. Simplicity': { reason: 'Simple to operate. Well-understood tooling and patterns.', factors: ['Standard Redis tooling', 'Simple backup/restore', 'Mature ecosystem'] },
      'Reliability': { reason: 'In-memory means potential data loss. RDB/AOF persistence helps but adds complexity.', factors: ['In-memory = volatile', 'RDB/AOF for persistence', 'Replication for HA'] },
      'Learning Curve': { reason: 'Simple commands. LIST, LPUSH, LRANGE are intuitive.', factors: ['Simple commands', 'Extensive documentation', 'Large community'] }
    },
    'memcached': {
      'Read Perf': { reason: 'Sub-millisecond reads. Slightly faster than Redis for simple key-value.', factors: ['Pure key-value, no data structures', 'Multi-threaded reads', 'No persistence overhead'] },
      'Write Perf': { reason: 'Multi-threaded writes. Higher write throughput than single-threaded Redis.', factors: ['Multi-threaded writes', 'No persistence (pure cache)', 'Simple SET operations'] },
      'Scalability': { reason: 'Multi-threaded scales better per node. Client-side sharding for horizontal scaling.', factors: ['Multi-threaded utilizes all cores', 'Client-side sharding', 'Simple hash distribution'] },
      'Cost Efficiency': { reason: 'Lower memory overhead than Redis. No persistence means cheaper RAM usage.', factors: ['Lower memory per key', 'No persistence files', 'Efficient memory allocator'] },
      'Op. Simplicity': { reason: 'Simpler than Redis: no persistence, no data structures. Less to configure.', factors: ['No persistence config', 'No RDB/AOF complexity', 'Simple restart = empty cache'] },
      'Reliability': { reason: 'No persistence. Cache restart = data loss. Designed for volatility.', factors: ['No persistence', 'Restart = data loss', 'Simple failure mode'] },
      'Learning Curve': { reason: 'Simplest caching solution. GET/SET only.', factors: ['Minimal API surface', 'No data structures to learn', 'Simple mental model'] }
    },
    'keydb': {
      'Read Perf': { reason: 'Multi-threaded Redis clone. Same data structures, higher throughput.', factors: ['Multi-threaded I/O', 'Redis-compatible commands', 'Better core utilization'] },
      'Write Perf': { reason: 'Multi-threaded writes. 5x write throughput vs single-threaded Redis.', factors: ['Multi-threaded writes', 'Parallel command processing', 'Better CPU utilization'] },
      'Scalability': { reason: 'Vertical scaling via multi-threading. Clustering for horizontal scaling.', factors: ['Multi-threaded per instance', 'Better core usage', 'Clustering supported'] },
      'Cost Efficiency': { reason: 'Same memory model as Redis. Better throughput means fewer instances.', factors: ['Same memory usage as Redis', 'Higher throughput = fewer nodes', 'Open-source'] },
      'Op. Simplicity': { reason: 'Redis-compatible. Drop-in replacement. Slightly more config for multi-threading.', factors: ['Redis-compatible tooling', 'Drop-in replacement', 'Multi-threading config'] },
      'Reliability': { reason: 'Same persistence model as Redis. Multi-threading adds complexity.', factors: ['RDB/AOF like Redis', 'Multi-threading adds race potential', 'Replication supported'] },
      'Learning Curve': { reason: 'Redis knowledge transfers directly. Minor learning for multi-threading config.', factors: ['Redis-compatible', 'Minor new concepts', 'Growing community'] }
    }
  },
  'message-queue': {
    'kafka': {
      'Throughput': { reason: 'Optimized for high throughput. Multi-partition parallelism enables millions of msgs/sec.', factors: ['Parallel writes across partitions', 'Sequential disk I/O', 'Zero-copy transfer'] },
      'Ordering': { reason: 'Per-partition ordering only. Key-based partitioning for partial ordering.', factors: ['Partition-level ordering', 'Key determines partition', 'No global ordering'] },
      'Scalability': { reason: 'Add partitions and brokers for linear horizontal scaling.', factors: ['Linear scale-out', 'Partition parallelism', 'Broker clustering'] },
      'Op. Simplicity': { reason: 'Complex: ZooKeeper dependency, partition management, consumer group rebalancing.', factors: ['ZooKeeper required (pre-3.x)', 'Partition tuning', 'Consumer rebalancing complexity'] },
      'Reliability': { reason: 'Durable event log with replication. Survives broker failures.', factors: ['Replication factor ensures durability', 'Leader election on failure', 'Disk-backed persistence'] },
      'Portability': { reason: 'Open-source Apache Kafka. Runs self-hosted or on managed services.', factors: ['Apache 2.0 license', 'Multiple providers (Confluent, MSK)', 'Open protocol'] },
      'Learning Curve': { reason: 'Steep: partitioning, consumer groups, offset management, rebalancing semantics.', factors: ['Partition key design', 'Consumer group rebalancing', 'Offset commit strategies'] }
    },
    'rabbitmq': {
      'Throughput': { reason: 'Lower throughput than Kafka. Optimized for reliability over raw speed.', factors: ['Per-message acknowledgments', 'AMQP protocol overhead', 'Memory-bound queues'] },
      'Ordering': { reason: 'Per-queue ordering. Fanout exchange provides broadcast semantics.', factors: ['Queue-level ordering', 'Fanout broadcast', 'No partition concept'] },
      'Scalability': { reason: 'Vertical scaling per queue. Clustering for HA but not for throughput.', factors: ['Queue sharding required for scale', 'Clustering for HA', 'Memory-bound scaling'] },
      'Op. Simplicity': { reason: 'Simpler than Kafka: no partitions, straightforward queue model.', factors: ['Classic queue model', 'Well-understood patterns', 'Good management UI'] },
      'Reliability': { reason: 'Message acknowledgments ensure delivery. Durable queues persist to disk.', factors: ['Per-message ACKs', 'Durable queue option', 'Clustering for HA'] },
      'Portability': { reason: 'AMQP standard protocol. Portable across AMQP brokers.', factors: ['AMQP standard', 'Multiple broker implementations', 'Open-source'] },
      'Learning Curve': { reason: 'Moderate: exchange types, routing keys, acknowledgment modes.', factors: ['Exchange types (fanout, topic, direct)', 'Routing key design', 'ACK strategies'] }
    },
    'redis-streams': {
      'Throughput': { reason: 'High throughput for in-memory delivery. Lower than Kafka for disk-backed durability.', factors: ['In-memory speed', 'Append-only log', 'AOF persistence optional'] },
      'Ordering': { reason: 'Stream-level ordering. Consumer groups for parallel processing.', factors: ['Stream is ordered log', 'Consumer groups supported', 'ID-based ordering'] },
      'Scalability': { reason: 'Memory-bound. Clustering for horizontal scaling but more complex than Kafka.', factors: ['Memory-bound', 'Redis Cluster for scale-out', 'Single-threaded per stream'] },
      'Op. Simplicity': { reason: 'Simpler than Kafka: no ZooKeeper, familiar Redis tooling.', factors: ['Redis tooling', 'No ZooKeeper', 'Simpler config'] },
      'Reliability': { reason: 'In-memory by default. AOF persistence adds durability but latency.', factors: ['In-memory = volatile', 'AOF for durability', 'Replication for HA'] },
      'Portability': { reason: 'Redis protocol. Portable across Redis-compatible services.', factors: ['Redis protocol', 'Multiple providers', 'Open-source'] },
      'Learning Curve': { reason: 'Moderate: XREAD, XADD, consumer groups. Simpler than Kafka, more than RabbitMQ.', factors: ['Stream commands', 'Consumer group management', 'Pending entry list'] }
    }
  }
};

// Component catalog — full list of available components grouped by category
const COMPONENT_CATALOG = {
  'Delivery/Network': [
    { name: 'Nginx', sub: 'Reverse proxy', connectsFrom: ['Clients', 'CDN'], connectsTo: ['Compute'] },
    { name: 'AWS API Gateway', sub: 'Managed gateway', connectsFrom: ['Clients'], connectsTo: ['Compute', 'Auth/Security'] },
    { name: 'Kong', sub: 'Plugin ecosystem', connectsFrom: ['Clients'], connectsTo: ['Compute', 'Auth/Security'] },
    { name: 'Traefik', sub: 'Cloud-native', connectsFrom: ['Clients', 'DevOps'], connectsTo: ['Compute'] },
    { name: 'HAProxy', sub: 'TCP/HTTP LB', connectsFrom: ['Clients'], connectsTo: ['Compute'] },
    { name: 'Envoy', sub: 'Service mesh', connectsFrom: ['Compute'], connectsTo: ['Compute'] },
    { name: 'CloudFront', sub: 'CDN + edge', connectsFrom: ['Clients'], connectsTo: ['Delivery/Network', 'Compute'] }
  ],
  'Compute': [
    { name: 'Node.js', sub: 'Event-driven I/O', connectsFrom: ['Delivery/Network'], connectsTo: ['Data Storage', 'Caching', 'Messaging', 'Search'] },
    { name: 'Go', sub: 'Concurrency', connectsFrom: ['Delivery/Network'], connectsTo: ['Data Storage', 'Caching', 'Messaging'] },
    { name: 'Python FastAPI', sub: 'ML-friendly', connectsFrom: ['Delivery/Network'], connectsTo: ['Data Storage', 'Caching', 'Messaging'] },
    { name: 'Rust Actix', sub: 'Max performance', connectsFrom: ['Delivery/Network'], connectsTo: ['Data Storage', 'Caching', 'Messaging'] },
    { name: 'Java Spring', sub: 'Enterprise', connectsFrom: ['Delivery/Network'], connectsTo: ['Data Storage', 'Caching', 'Messaging'] },
    { name: '.NET / C#', sub: 'Microsoft stack', connectsFrom: ['Delivery/Network'], connectsTo: ['Data Storage', 'Caching', 'Messaging'] }
  ],
  'Data Storage': [
    { name: 'PostgreSQL', sub: 'Relational ACID', connectsFrom: ['Compute'], connectsTo: ['Search', 'Monitoring'] },
    { name: 'MongoDB', sub: 'Document DB', connectsFrom: ['Compute'], connectsTo: ['Search'] },
    { name: 'MySQL', sub: 'Web standard', connectsFrom: ['Compute'], connectsTo: ['Search'] },
    { name: 'CockroachDB', sub: 'Distributed SQL', connectsFrom: ['Compute'], connectsTo: [] },
    { name: 'DynamoDB', sub: 'Serverless NoSQL', connectsFrom: ['Compute'], connectsTo: [] },
    { name: 'Cassandra', sub: 'Wide-column', connectsFrom: ['Compute'], connectsTo: [] }
  ],
  'Caching': [
    { name: 'Redis', sub: 'Data structures', connectsFrom: ['Compute'], connectsTo: ['Real-Time'] },
    { name: 'Memcached', sub: 'Simple cache', connectsFrom: ['Compute'], connectsTo: [] },
    { name: 'KeyDB', sub: 'Multi-thread Redis', connectsFrom: ['Compute'], connectsTo: [] },
    { name: 'Dragonfly', sub: 'Modern cache', connectsFrom: ['Compute'], connectsTo: [] },
    { name: 'Varnish', sub: 'HTTP cache', connectsFrom: ['Delivery/Network'], connectsTo: ['Compute'] }
  ],
  'Messaging': [
    { name: 'Kafka', sub: 'Event streaming', connectsFrom: ['Compute'], connectsTo: ['Compute', 'Data Storage', 'Real-Time'] },
    { name: 'RabbitMQ', sub: 'Classic MQ', connectsFrom: ['Compute'], connectsTo: ['Compute'] },
    { name: 'AWS SQS', sub: 'Managed queue', connectsFrom: ['Compute'], connectsTo: ['Compute'] },
    { name: 'Apache Pulsar', sub: 'Multi-tenant', connectsFrom: ['Compute'], connectsTo: ['Compute', 'Data Storage'] },
    { name: 'NATS', sub: 'Lightweight', connectsFrom: ['Compute'], connectsTo: ['Compute'] }
  ],
  'Real-Time': [
    { name: 'Socket.io', sub: 'WebSocket + fallback', connectsFrom: ['Compute', 'Caching'], connectsTo: ['Clients'] },
    { name: 'Pusher', sub: 'Managed realtime', connectsFrom: ['Compute'], connectsTo: ['Clients'] },
    { name: 'Ably', sub: 'Global pub/sub', connectsFrom: ['Compute'], connectsTo: ['Clients'] },
    { name: 'Centrifugo', sub: 'Self-hosted', connectsFrom: ['Compute', 'Messaging'], connectsTo: ['Clients'] },
    { name: 'SSE Endpoint', sub: 'Server-sent events', connectsFrom: ['Compute'], connectsTo: ['Clients'] }
  ],
  'Auth/Security': [
    { name: 'Auth0', sub: 'Managed auth', connectsFrom: ['Delivery/Network', 'Compute'], connectsTo: ['Data Storage'] },
    { name: 'Keycloak', sub: 'Self-hosted IAM', connectsFrom: ['Delivery/Network'], connectsTo: ['Data Storage'] },
    { name: 'AWS Cognito', sub: 'AWS auth', connectsFrom: ['Delivery/Network'], connectsTo: [] },
    { name: 'Custom JWT', sub: 'In-house', connectsFrom: ['Compute'], connectsTo: ['Caching', 'Data Storage'] },
    { name: 'OAuth2 Proxy', sub: 'Gateway auth', connectsFrom: ['Delivery/Network'], connectsTo: ['Compute'] }
  ],
  'Monitoring': [
    { name: 'Datadog', sub: 'Full observability', connectsFrom: ['All components'], connectsTo: ['Alerting'] },
    { name: 'Grafana + Prometheus', sub: 'OSS metrics', connectsFrom: ['Compute', 'Data Storage'], connectsTo: ['Alerting'] },
    { name: 'ELK Stack', sub: 'Log analytics', connectsFrom: ['All components'], connectsTo: [] },
    { name: 'Jaeger', sub: 'Distributed tracing', connectsFrom: ['Compute'], connectsTo: [] },
    { name: 'Sentry', sub: 'Error tracking', connectsFrom: ['Compute'], connectsTo: ['Alerting'] }
  ],
  'Search': [
    { name: 'Elasticsearch', sub: 'Full-text + analytics', connectsFrom: ['Data Storage', 'Compute'], connectsTo: ['Compute'] },
    { name: 'Algolia', sub: 'Managed search', connectsFrom: ['Compute'], connectsTo: [] },
    { name: 'Meilisearch', sub: 'Fast + simple', connectsFrom: ['Compute'], connectsTo: [] },
    { name: 'Typesense', sub: 'Typo-tolerant', connectsFrom: ['Compute'], connectsTo: [] }
  ],
  'DevOps': [
    { name: 'Docker', sub: 'Containers', connectsFrom: [], connectsTo: ['All components'] },
    { name: 'Kubernetes', sub: 'Orchestration', connectsFrom: ['DevOps'], connectsTo: ['All components'] },
    { name: 'Terraform', sub: 'IaC', connectsFrom: [], connectsTo: ['All components'] },
    { name: 'GitHub Actions', sub: 'CI/CD', connectsFrom: [], connectsTo: ['DevOps'] },
    { name: 'ArgoCD', sub: 'GitOps', connectsFrom: ['DevOps'], connectsTo: ['Compute'] }
  ]
};

// Swap icon SVG
const SWAP_ICON = '<svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M4 6l-2 2 2 2"/><path d="M2 8h10"/><path d="M12 10l2-2-2-2"/><path d="M14 8H4"/></svg>';

// Alternative components per category (for swap feature)
const ALTERNATIVES = {
  'load-balancer': [
    { id: 'load-balancer', name: 'Nginx', sub: 'Current' },
    { id: 'aws-alb', name: 'AWS ALB', sub: 'Managed' },
    { id: 'envoy', name: 'Envoy Proxy', sub: 'Service mesh' },
    { id: 'haproxy', name: 'HAProxy', sub: 'TCP/HTTP LB' }
  ],
  'timeline-api': [
    { id: 'timeline-api', name: 'Express.js', sub: 'Current' },
    { id: 'fastify', name: 'Fastify', sub: 'Schema-first' },
    { id: 'go-api', name: 'Go API', sub: 'Concurrency' },
    { id: 'nestjs', name: 'NestJS', sub: 'Enterprise' }
  ],
  'fanout-service': [
    { id: 'fanout-service', name: 'Fan-out on Write', sub: 'Current' },
    { id: 'fanout-read', name: 'Fan-out on Read', sub: 'Query-time' },
    { id: 'hybrid', name: 'Hybrid Approach', sub: 'Best of both' },
    { id: 'lambda-fanout', name: 'Lambda Fan-out', sub: 'Serverless' }
  ],
  'tweet-store': [
    { id: 'tweet-store', name: 'PostgreSQL', sub: 'Current' },
    { id: 'cassandra', name: 'Cassandra', sub: 'Wide-column' },
    { id: 'dynamodb', name: 'DynamoDB', sub: 'Managed NoSQL' },
    { id: 'mongodb', name: 'MongoDB', sub: 'Document DB' }
  ],
  'timeline-cache': [
    { id: 'timeline-cache', name: 'Redis', sub: 'Current' },
    { id: 'memcached', name: 'Memcached', sub: 'Simple cache' },
    { id: 'keydb', name: 'KeyDB', sub: 'Multi-thread' },
    { id: 'dragonfly', name: 'Dragonfly', sub: 'Modern cache' }
  ],
  'message-queue': [
    { id: 'message-queue', name: 'Kafka', sub: 'Current' },
    { id: 'rabbitmq', name: 'RabbitMQ', sub: 'Classic MQ' },
    { id: 'redis-streams', name: 'Redis Streams', sub: 'Lightweight' },
    { id: 'pulsar', name: 'Apache Pulsar', sub: 'Multi-tenant' }
  ]
};

// Connection type icons (SVG path data for canvas labels, viewBox 0 0 10 10)
const CONN_TYPE_DEFS = {
  http: { color: '#06b6d4', name: 'HTTP/REST',
    path: 'M1,5H9M7,3l2,2-2,2M3,7L1,5l2-2' },
  database: { color: '#22c55e', name: 'Database',
    path: 'M3,2.5C3,1.5,7,1.5,7,2.5V7.5C7,8.5,3,8.5,3,7.5ZM3,5C3,6,7,6,7,5' },
  cache: { color: '#f97316', name: 'Cache',
    path: 'M6,1L3,5.5H5.2L4,9L7.5,4.5H5.3Z' },
  queue: { color: '#a855f7', name: 'Message Queue',
    path: 'M1,3H6L4.5,1.5M6,3L4.5,4.5M1,7H6L4.5,5.5M6,7L4.5,8.5' }
};

// Category info for info popups
const CATEGORY_INFO = {
  'Compute': {
    desc: 'Application servers that handle business logic, request processing, and service orchestration.',
    role: 'The brain of your architecture — processes requests, runs business rules, and coordinates between services.',
    examples: 'Node.js, Go, Python FastAPI, Java Spring, Rust Actix',
    key: 'Choose based on I/O patterns (event-driven vs thread-per-request), ecosystem needs, and team expertise.'
  },
  'Data Storage': {
    desc: 'Persistent databases for structured data with ACID guarantees and complex query support.',
    role: 'The long-term memory — stores everything that needs to survive restarts: users, messages, settings.',
    examples: 'PostgreSQL, MongoDB, MySQL, CockroachDB, DynamoDB',
    key: 'Choose based on data model (relational vs document), consistency needs, and scaling requirements.'
  },
  'Caching': {
    desc: 'In-memory stores for fast data access, session management, and reducing database load.',
    role: 'The short-term memory — holds frequently accessed data close to compute for sub-millisecond reads.',
    examples: 'Redis, Memcached, KeyDB, Dragonfly',
    key: 'Choose based on data structure needs, persistence requirements, and cache invalidation strategy.'
  },
  'Messaging': {
    desc: 'Event streaming and message queue platforms for asynchronous, decoupled communication.',
    role: 'The nervous system — carries events between services without requiring them to be online simultaneously.',
    examples: 'Kafka, RabbitMQ, AWS SQS, Apache Pulsar, NATS',
    key: 'Choose based on ordering guarantees, throughput needs, and whether you need replay capability.'
  },
  'Delivery/Network': {
    desc: 'API gateways, load balancers, CDNs, and reverse proxies that route and manage network traffic.',
    role: 'The front door — manages how traffic enters your system, applies security policies, and distributes load.',
    examples: 'Nginx, AWS API Gateway, Kong, Traefik, CloudFront',
    key: 'Choose based on routing complexity, auth integration, and whether you need managed vs self-hosted.'
  },
  'Real-Time': {
    desc: 'WebSocket servers, SSE endpoints, and pub/sub systems for live data delivery to clients.',
    role: 'The live wire — pushes updates to clients instantly without polling, enabling chat and live dashboards.',
    examples: 'Socket.io, Pusher, Ably, Centrifugo, Phoenix Channels',
    key: 'Choose based on connection scale, message fanout patterns, and client platform requirements.'
  },
  'Auth/Security': {
    desc: 'Authentication providers, authorization engines, and security infrastructure.',
    role: 'The gatekeeper — verifies identity, enforces permissions, and protects data at rest and in transit.',
    examples: 'Auth0, Keycloak, AWS Cognito, custom JWT, OAuth2',
    key: 'Choose based on auth flow complexity (SSO, MFA), compliance requirements, and team capacity.'
  },
  'Monitoring': {
    desc: 'Observability platforms for metrics, logging, tracing, and alerting across your infrastructure.',
    role: 'The eyes and ears — shows what is happening, what broke, and why, before users report it.',
    examples: 'Datadog, Grafana, Prometheus, ELK Stack, Jaeger',
    key: 'Choose based on data volume, retention needs, and whether you need metrics, logs, traces, or all three.'
  },
  'Search': {
    desc: 'Full-text search engines and indexing systems for fast, relevance-ranked content retrieval.',
    role: 'The librarian — indexes your data for fast, fuzzy, and relevance-ranked search experiences.',
    examples: 'Elasticsearch, Algolia, Meilisearch, Typesense',
    key: 'Choose based on index size, query complexity, and whether you need analytics alongside search.'
  },
  'DevOps': {
    desc: 'CI/CD pipelines, container orchestration, infrastructure-as-code, and deployment automation.',
    role: 'The assembly line — automates building, testing, deploying, and scaling your applications.',
    examples: 'Docker, Kubernetes, Terraform, GitHub Actions, ArgoCD',
    key: 'Choose based on deployment frequency, infrastructure complexity, and team DevOps maturity.'
  }
};

// Dashboard metric category info
const DASHBOARD_INFO = {
  perf: {
    name: 'Performance',
    desc: 'How fast your architecture responds to requests and processes data.',
    metrics: 'Latency (p50/p95/p99), throughput (req/s), response time, TTFB',
    impact: 'Directly affects user experience. Every 100ms of added latency reduces conversion by ~1%. Bottlenecks cascade through connected components.',
    improve: 'Cache hot paths, reduce network hops, use connection pooling, optimize queries, consider async processing.'
  },
  cost: {
    name: 'Cost',
    desc: 'Total cost of ownership including infrastructure, licensing, operations, and engineering time.',
    metrics: 'Monthly infra cost, cost per request, license fees, maintenance hours',
    impact: 'Determines sustainability. Over-provisioning wastes money; under-provisioning causes outages.',
    improve: 'Right-size instances, use spot instances, optimize queries, consider serverless for bursty workloads.'
  },
  rel: {
    name: 'Reliability',
    desc: 'How well your architecture handles failures, maintains uptime, and recovers from incidents.',
    metrics: 'Uptime (99.9% = 8.7h/yr downtime), MTTR, error rates, failover success rate',
    impact: 'Trust and reputation. Every minute of downtime erodes user confidence. Requires redundancy.',
    improve: 'Add redundancy, circuit breakers, health checks, graceful degradation, chaos engineering.'
  },
  ops: {
    name: 'Operational Complexity',
    desc: 'How easy your architecture is to deploy, monitor, debug, and maintain day-to-day.',
    metrics: 'Deploy frequency, change failure rate, MTTR, on-call burden, runbook coverage',
    impact: 'Team productivity and morale. Complex ops mean slower shipping and more incidents.',
    improve: 'Automate deployments, improve observability, reduce moving parts, use managed services.'
  },
  scale: {
    name: 'Scalability',
    desc: 'How well your architecture grows with increasing users, data, and traffic.',
    metrics: 'Max concurrent users, horizontal scale factor, auto-scaling responsiveness',
    impact: 'Growth readiness. Non-scalable architectures force expensive rewrites.',
    improve: 'Stateless services, horizontal scaling, data partitioning, caching layers, queue decoupling.'
  },
  strat: {
    name: 'Strategic Flexibility',
    desc: 'Long-term flexibility including vendor independence, technology currency, and hiring.',
    metrics: 'Vendor lock-in score, technology freshness, community size, migration effort',
    impact: 'Future-proofing. Strategic debt accumulates silently until you need to pivot or hire.',
    improve: 'Use open standards, abstract vendor APIs, keep dependencies current, invest in documentation.'
  },
  dev: {
    name: 'Developer Experience',
    desc: 'How productive and happy developers are when building features and fixing bugs.',
    metrics: 'New dev setup time, build time, test feedback loop, debugging ease, docs quality',
    impact: 'Velocity and retention. Good DX means faster shipping. Bad DX means slow onboarding and turnover.',
    improve: 'Fast local setup, comprehensive tests, good docs, consistent patterns, fast CI/CD feedback.'
  }
};

// Code patterns per component + variant — shows WHAT changes at implementation level
const CODE_PATTERNS = {
  'load-balancer': {
    'nginx': `<span class="cm">// Nginx: upstream to timeline API</span>
<span class="kw">upstream</span> timeline_api {
  <span class="kw">server</span> api1:<span class="num">3000</span>;
  <span class="kw">server</span> api2:<span class="num">3000</span>;
}
<span class="kw">server</span> {
  <span class="kw">listen</span> <span class="num">443</span> ssl;
  <span class="kw">location</span> /timeline/ {
    <span class="fn">proxy_pass</span> http://timeline_api;
  }
}`,
    'aws-alb': `<span class="cm">// AWS ALB: managed load balancing</span>
<span class="kw">const</span> alb = <span class="kw">new</span> <span class="fn">ApplicationLoadBalancer</span>(stack, <span class="str">'ALB'</span>, {
  vpc, <span class="fn">internetFacing</span>: <span class="num">true</span>
})
<span class="kw">const</span> listener = alb.<span class="fn">addListener</span>(<span class="str">'Listener'</span>, {
  port: <span class="num">443</span>, <span class="fn">certificates</span>: [cert]
})
listener.<span class="fn">addTargets</span>(<span class="str">'API'</span>, {
  port: <span class="num">3000</span>, targets: [apiService]
})`,
    'envoy': `<span class="cm">// Envoy: service mesh routing</span>
static_resources:
  listeners:
    - address: { <span class="fn">socket_address</span>: { address: <span class="str">0.0.0.0</span>, port: <span class="num">443</span> }}
      filter_chains:
        - filters:
          - name: <span class="fn">envoy.http_connection_manager</span>
            routes:
              - match: { prefix: <span class="str">/timeline</span> }
                route: { cluster: <span class="str">timeline_api</span> }`
  },
  'timeline-api': {
    'express': `<span class="cm">// Express: POST tweet, GET timeline</span>
app.<span class="fn">post</span>(<span class="str">'/tweet'</span>,
  <span class="fn">authMiddleware</span>,
  <span class="kw">async</span> (req, res) => {
    <span class="kw">await</span> db.<span class="fn">insertTweet</span>(req.body)
    <span class="kw">await</span> queue.<span class="fn">publish</span>(<span class="str">'new-tweet'</span>, req.body)
    res.<span class="fn">json</span>({ ok: <span class="num">true</span> })
  })`,
    'fastify': `<span class="cm">// Fastify: schema-first, faster JSON</span>
fastify.<span class="fn">post</span>(<span class="str">'/tweet'</span>, {
  schema: { body: <span class="fn">tweetSchema</span> },
  preHandler: [<span class="fn">authHook</span>]
}, <span class="kw">async</span> (req) => {
  <span class="kw">await</span> db.<span class="fn">insertTweet</span>(req.body)
  <span class="kw">await</span> queue.<span class="fn">publish</span>(<span class="str">'new-tweet'</span>, req.body)
  <span class="kw">return</span> { ok: <span class="num">true</span> }
})`,
    'go-api': `<span class="cm">// Go API: concurrent tweet handling</span>
<span class="kw">func</span> <span class="fn">PostTweet</span>(w http.ResponseWriter, r *http.Request) {
  <span class="kw">var</span> tweet Tweet
  json.<span class="fn">NewDecoder</span>(r.Body).<span class="fn">Decode</span>(&tweet)
  <span class="kw">go</span> db.<span class="fn">InsertTweet</span>(tweet)
  <span class="kw">go</span> queue.<span class="fn">Publish</span>(<span class="str">"new-tweet"</span>, tweet)
  json.<span class="fn">NewEncoder</span>(w).<span class="fn">Encode</span>(map[<span class="kw">string</span>]<span class="kw">bool</span>{<span class="str">"ok"</span>: <span class="num">true</span>})
}`
  },
  'fanout-service': {
    'fanout-write': `<span class="cm">// Fan-out on Write: push to all followers</span>
<span class="kw">async function</span> <span class="fn">fanoutTweet</span>(tweet, authorId) {
  <span class="kw">const</span> followers = <span class="kw">await</span> db.<span class="fn">getFollowers</span>(authorId)
  <span class="kw">for</span> (<span class="kw">const</span> follower <span class="kw">of</span> followers) {
    <span class="kw">await</span> cache.<span class="fn">lpush</span>(<span class="str">\`timeline:\${follower}\`</span>, tweet)
  }
  <span class="cm">// Fast reads, expensive writes</span>
}`,
    'fanout-read': `<span class="cm">// Fan-out on Read: query on timeline fetch</span>
<span class="kw">async function</span> <span class="fn">getTimeline</span>(userId) {
  <span class="kw">const</span> following = <span class="kw">await</span> db.<span class="fn">getFollowing</span>(userId)
  <span class="kw">const</span> tweets = <span class="kw">await</span> db.<span class="fn">getTweets</span>({ author: following })
  <span class="kw">return</span> tweets.<span class="fn">sort</span>((a,b) => b.ts - a.ts).<span class="fn">slice</span>(<span class="num">0</span>,<span class="num">50</span>)
  <span class="cm">// Cheap writes, slow reads</span>
}`,
    'hybrid': `<span class="cm">// Hybrid: fan-out for normal, query for celebs</span>
<span class="kw">async function</span> <span class="fn">fanoutTweet</span>(tweet, author) {
  <span class="kw">if</span> (author.followers > <span class="num">1000000</span>) {
    <span class="cm">// Celebrity: skip fan-out, query on read</span>
    <span class="kw">await</span> db.<span class="fn">insertTweet</span>(tweet)
  } <span class="kw">else</span> {
    <span class="kw">const</span> followers = <span class="kw">await</span> db.<span class="fn">getFollowers</span>(author.id)
    <span class="kw">await</span> cache.<span class="fn">fanout</span>(followers, tweet)
  }
}`
  },
  'tweet-store': {
    'postgresql': `<span class="cm">-- PostgreSQL: relational tweets + users</span>
<span class="kw">SELECT</span> t.*, u.username, u.avatar
<span class="kw">FROM</span> tweets t
<span class="kw">JOIN</span> users u <span class="kw">ON</span> t.author_id = u.id
<span class="kw">WHERE</span> t.author_id <span class="kw">IN</span> (
  <span class="kw">SELECT</span> following_id <span class="kw">FROM</span> follows <span class="kw">WHERE</span> user_id = <span class="num">?</span>
)
<span class="kw">ORDER BY</span> t.created_at <span class="kw">DESC</span> <span class="kw">LIMIT</span> <span class="num">50</span>`,
    'cassandra': `<span class="cm">-- Cassandra: wide-column, partition by user</span>
<span class="kw">CREATE TABLE</span> tweets (
  author_id <span class="kw">uuid</span>,
  tweet_id <span class="kw">timeuuid</span>,
  content <span class="kw">text</span>,
  <span class="kw">PRIMARY KEY</span> (author_id, tweet_id)
) <span class="kw">WITH CLUSTERING ORDER BY</span> (tweet_id <span class="kw">DESC</span>)
<span class="cm">-- Fast writes, denormalized reads</span>`,
    'dynamodb': `<span class="cm">// DynamoDB: partition by author_id</span>
<span class="kw">const</span> params = {
  TableName: <span class="str">'Tweets'</span>,
  KeyConditionExpression: <span class="str">'author_id = :aid'</span>,
  ExpressionAttributeValues: { <span class="str">':aid'</span>: authorId },
  ScanIndexForward: <span class="num">false</span>,
  Limit: <span class="num">50</span>
}
<span class="kw">const</span> result = <span class="kw">await</span> dynamodb.<span class="fn">query</span>(params)`
  },
  'timeline-cache': {
    'redis': `<span class="cm">// Redis: per-user timeline cache</span>
<span class="kw">async function</span> <span class="fn">getTimeline</span>(userId) {
  <span class="kw">let</span> timeline = <span class="kw">await</span> redis.<span class="fn">lrange</span>(<span class="str">\`timeline:\${userId}\`</span>, <span class="num">0</span>, <span class="num">49</span>)
  <span class="kw">if</span> (timeline.length === <span class="num">0</span>) {
    timeline = <span class="kw">await</span> db.<span class="fn">fetchTimeline</span>(userId)
    <span class="kw">await</span> redis.<span class="fn">lpush</span>(<span class="str">\`timeline:\${userId}\`</span>, ...timeline)
  }
  <span class="kw">return</span> timeline
}`,
    'memcached': `<span class="cm">// Memcached: simple key-value cache</span>
<span class="kw">const</span> key = <span class="str">\`timeline:\${userId}\`</span>
<span class="kw">let</span> timeline = <span class="kw">await</span> memcached.<span class="fn">get</span>(key)
<span class="kw">if</span> (!timeline) {
  timeline = <span class="kw">await</span> db.<span class="fn">fetchTimeline</span>(userId)
  <span class="kw">await</span> memcached.<span class="fn">set</span>(key, timeline, <span class="num">300</span>)
}
<span class="kw">return</span> timeline`,
    'keydb': `<span class="cm">// KeyDB: multi-threaded Redis clone</span>
<span class="cm">// Same API as Redis but parallel I/O</span>
<span class="kw">await</span> keydb.<span class="fn">lpush</span>(<span class="str">\`timeline:\${userId}\`</span>, tweet)
<span class="kw">await</span> keydb.<span class="fn">ltrim</span>(<span class="str">\`timeline:\${userId}\`</span>, <span class="num">0</span>, <span class="num">999</span>)
<span class="kw">const</span> timeline = <span class="kw">await</span> keydb.<span class="fn">lrange</span>(<span class="str">\`timeline:\${userId}\`</span>, <span class="num">0</span>, <span class="num">49</span>)
<span class="cm">// 5x throughput vs single-threaded Redis</span>`
  },
  'message-queue': {
    'kafka': `<span class="cm">// Kafka: tweet events for fan-out</span>
<span class="kw">await</span> producer.<span class="fn">send</span>({
  topic: <span class="str">'tweet-events'</span>,
  key: authorId,
  value: <span class="fn">JSON.stringify</span>(tweet)
})
<span class="cm">// Fan-out service consumes and distributes</span>
<span class="kw">await</span> consumer.<span class="fn">run</span>({
  <span class="fn">eachMessage</span>: <span class="kw">async</span> ({ message }) => {
    <span class="kw">await</span> fanoutService.<span class="fn">process</span>(message.value)
  }
})`,
    'rabbitmq': `<span class="cm">// RabbitMQ: fanout exchange for followers</span>
<span class="kw">await</span> channel.<span class="fn">publish</span>(<span class="str">'tweet-fanout'</span>, <span class="str">''</span>,
  <span class="fn">Buffer.from</span>(<span class="fn">JSON.stringify</span>(tweet))
)
<span class="cm">// Each follower queue gets a copy</span>
<span class="kw">await</span> channel.<span class="fn">consume</span>(userQueue, (msg) => {
  <span class="kw">const</span> tweet = <span class="fn">JSON.parse</span>(msg.content)
  cache.<span class="fn">addToTimeline</span>(userId, tweet)
})`,
    'redis-streams': `<span class="cm">// Redis Streams: lightweight event log</span>
<span class="kw">await</span> redis.<span class="fn">xadd</span>(<span class="str">'tweet-stream'</span>, <span class="str">'*'</span>,
  <span class="str">'author'</span>, authorId,
  <span class="str">'tweet'</span>, <span class="fn">JSON.stringify</span>(tweet)
)
<span class="cm">// Consumer group reads and processes</span>
<span class="kw">const</span> msgs = <span class="kw">await</span> redis.<span class="fn">xreadgroup</span>(
  <span class="str">'GROUP'</span>, <span class="str">'fanout-workers'</span>, <span class="str">'consumer-1'</span>,
  <span class="str">'STREAMS'</span>, <span class="str">'tweet-stream'</span>, <span class="str">'>'</span>
)`
  }
};

// ═══════════════ DATA ═══════════════
const CATEGORIES = {
  'Compute':          { color: '#3b82f6', shape: 'rectangle' },
  'Data Storage':     { color: '#22c55e', shape: 'cylinder' },
  'Caching':          { color: '#f97316', shape: 'pill' },
  'Messaging':        { color: '#a855f7', shape: 'hexish' },
  'Delivery/Network': { color: '#06b6d4', shape: 'stadium' },
  'Real-Time':        { color: '#ec4899', shape: 'pill' },
  'Auth/Security':    { color: '#ef4444', shape: 'rectangle' },
  'Monitoring':       { color: '#eab308', shape: 'stadium' },
  'Search':           { color: '#14b8a6', shape: 'pill' },
  'DevOps':           { color: '#8b5cf6', shape: 'hexish' }
};

const components = {
  'load-balancer': {
    name: 'Load Balancer', category: 'Delivery/Network',
    is: 'Routes incoming HTTP traffic across Timeline API instances',
    gain: 'Single entry point, SSL termination, health checking',
    cost: 'Additional network hop, configuration complexity',
    position: { x: 330, y: 20 },
    heatStatus: 'green',
    connections: [
      { target: 'timeline-api', label: 'HTTP', connType: 'http', protocol: 'HTTP/1.1 · HTTP/2', pattern: 'Request → Response',
        direction: 'Load balancer distributes requests to timeline API servers',
        role: 'Reverse Proxy',
        summary: 'All user requests hit the load balancer first. It terminates SSL, performs health checks on API instances, and routes traffic using round-robin or least-connections. The LB provides a single stable endpoint for clients.',
        latency: '~1-3ms (reverse proxy hop)', colocatable: true,
        code: `<span class="cm">// Nginx upstream to Timeline API</span>\n<span class="kw">upstream</span> timeline_api {\n  <span class="kw">server</span> api1:<span class="num">3000</span>;\n  <span class="kw">server</span> api2:<span class="num">3000</span>;\n  <span class="fn">keepalive</span> <span class="num">32</span>;\n}\n<span class="kw">location</span> /timeline/ {\n  <span class="fn">proxy_pass</span> http://timeline_api;\n}` }
    ],
    dataContext: [
      { name: 'SSL Termination', icon: 'ssl', behaviors: {
        'nginx': { fit: 'great', note: 'Native SSL, minimal overhead' },
        'aws-alb': { fit: 'great', note: 'Managed certs, auto-renewal' },
        'envoy': { fit: 'great', note: 'Modern TLS, service mesh integration' }
      }},
      { name: 'Health Checks', icon: 'health', behaviors: {
        'nginx': { fit: 'good', note: 'Passive health checks via error thresholds' },
        'aws-alb': { fit: 'great', note: 'Active health checks with configurable intervals' },
        'envoy': { fit: 'great', note: 'Rich health checking, outlier detection' }
      }},
      { name: 'WebSocket Support', icon: 'ws', behaviors: {
        'nginx': { fit: 'great', note: 'Upgrade header support, connection persistence' },
        'aws-alb': { fit: 'good', note: 'WebSocket supported but adds latency' },
        'envoy': { fit: 'great', note: 'Native HTTP/2, WebSocket, gRPC support' }
      }}
    ],
    variants: {
      'nginx': { label: 'Nginx',
        metrics: { 'Latency': 90, 'Throughput': 92, 'Cost Efficiency': 88, 'Op. Simplicity': 60, 'Reliability': 75, 'Portability': 95, 'Learning Curve': 65 },
        pros: ['Ultra-low latency','High throughput','Battle-tested'], cons: ['Manual config','No dynamic service discovery'] },
      'aws-alb': { label: 'AWS ALB',
        metrics: { 'Latency': 65, 'Throughput': 75, 'Cost Efficiency': 50, 'Op. Simplicity': 92, 'Reliability': 95, 'Portability': 25, 'Learning Curve': 80 },
        pros: ['Fully managed','Auto-scaling','Built-in monitoring'], cons: ['Vendor lock-in','Higher latency','Cost at scale'] },
      'envoy': { label: 'Envoy Proxy',
        metrics: { 'Latency': 82, 'Throughput': 85, 'Cost Efficiency': 70, 'Op. Simplicity': 45, 'Reliability': 80, 'Portability': 85, 'Learning Curve': 38 },
        pros: ['Service mesh ready','Dynamic config','Rich observability'], cons: ['Complex config','Steep learning curve'] }
    },
    currentVariant: 'nginx'
  },
  'timeline-api': {
    name: 'Timeline API', category: 'Compute',
    is: 'Application server handling tweet posting and timeline reads',
    gain: 'Non-blocking I/O, fast JSON processing, REST endpoints',
    cost: 'Single-threaded CPU bottleneck, framework overhead',
    position: { x: 330, y: 170 },
    heatStatus: 'yellow',
    connections: [
      { target: 'tweet-store', label: 'TCP/DB', connType: 'database', protocol: 'Database Wire Protocol (TCP:5432)', pattern: 'Connection Pool → Query → Response',
        direction: 'API writes tweets and reads user data from the database',
        role: 'Primary Data Store',
        summary: 'The API maintains a connection pool to the tweet store for all persistent operations: inserting new tweets, querying user profiles, reading follow graphs. Connection pooling prevents exhaustion on high traffic.',
        latency: '~2-10ms (query dependent)', colocatable: true,
        code: `<span class="cm">// Timeline API → Tweet Store</span>\n<span class="kw">const</span> pool = <span class="kw">new</span> <span class="fn">Pool</span>({\n  host: <span class="str">'db'</span>,\n  port: <span class="num">5432</span>,\n  max: <span class="num">25</span>\n})\n<span class="kw">const</span> { rows } = <span class="kw">await</span> pool.<span class="fn">query</span>(\n  <span class="str">'INSERT INTO tweets (author_id, content) VALUES ($1, $2)'</span>,\n  [userId, content]\n)` },
      { target: 'timeline-cache', label: 'RESP', connType: 'cache', protocol: 'RESP (Redis Serialization Protocol, TCP:6379)', pattern: 'GET/SET → Sub-ms Response',
        direction: 'API reads cached timelines before querying the database',
        role: 'Read Cache',
        summary: 'The API checks the timeline cache on every GET /timeline request. Cache hits return pre-built timelines instantly. On cache miss, the API queries the database and populates the cache for future requests.',
        latency: '~0.1-0.5ms (sub-millisecond)', colocatable: true,
        code: `<span class="cm">// Timeline API → Timeline Cache</span>\n<span class="kw">const</span> redis = <span class="kw">new</span> <span class="fn">Redis</span>({\n  host: <span class="str">'cache'</span>,\n  port: <span class="num">6379</span>\n})\n<span class="kw">let</span> timeline = <span class="kw">await</span> redis.<span class="fn">lrange</span>(<span class="str">\`timeline:\${userId}\`</span>, <span class="num">0</span>, <span class="num">49</span>)\n<span class="kw">if</span> (!timeline.length) {\n  timeline = <span class="kw">await</span> db.<span class="fn">fetchTimeline</span>(userId)\n}` },
      { target: 'message-queue', label: 'Produce', connType: 'queue', protocol: 'Kafka Binary Protocol (TCP:9092)', pattern: 'Produce → Ack (async)',
        direction: 'API produces new tweet events to Kafka for async fan-out',
        role: 'Event Producer',
        summary: 'When a user posts a tweet, the API acknowledges the write quickly and publishes a "new-tweet" event to Kafka. The fan-out service consumes these events and distributes tweets to followers\' timelines asynchronously.',
        latency: '~5-15ms (broker ack + replication)', colocatable: false,
        code: `<span class="cm">// Timeline API → Message Queue</span>\n<span class="kw">const</span> producer = kafka.<span class="fn">producer</span>()\n<span class="kw">await</span> producer.<span class="fn">send</span>({\n  topic: <span class="str">'tweet-events'</span>,\n  key: authorId,\n  value: <span class="fn">JSON.stringify</span>({\n    tweetId, authorId, content, timestamp\n  })\n})` }
    ],
    dataContext: [
      { name: 'POST /tweet', icon: 'endpoint', behaviors: {
        'express': { fit: 'good', note: 'Middleware chain, manual validation' },
        'fastify': { fit: 'great', note: 'Schema-validated input, 2x faster serialization' },
        'go-api': { fit: 'great', note: 'Goroutines for async Kafka publish' }
      }},
      { name: 'GET /timeline', icon: 'endpoint', behaviors: {
        'express': { fit: 'tradeoff', note: 'No built-in caching logic' },
        'fastify': { fit: 'good', note: 'Fast JSON serialization for timeline arrays' },
        'go-api': { fit: 'great', note: 'Concurrent cache + DB queries' }
      }},
      { name: 'GET /user/:id', icon: 'endpoint', behaviors: {
        'express': { fit: 'good', note: 'Simple param routing' },
        'fastify': { fit: 'good', note: 'Schema-driven params + response' },
        'go-api': { fit: 'great', note: 'Struct serialization, type-safe' }
      }}
    ],
    variants: {
      'express': { label: 'Express.js',
        metrics: { 'Latency': 72, 'Throughput': 68, 'Cost Efficiency': 90, 'Op. Simplicity': 85, 'Reliability': 65, 'Portability': 95, 'Learning Curve': 90 },
        pros: ['Minimal footprint','Huge ecosystem','Easy to learn'], cons: ['No built-in validation','Manual structure'] },
      'fastify': { label: 'Fastify',
        metrics: { 'Latency': 88, 'Throughput': 85, 'Cost Efficiency': 88, 'Op. Simplicity': 70, 'Reliability': 72, 'Portability': 92, 'Learning Curve': 70 },
        pros: ['2-3x faster than Express','Schema validation built-in','Plugin system'], cons: ['Smaller ecosystem','Different patterns'] },
      'go-api': { label: 'Go API',
        metrics: { 'Latency': 92, 'Throughput': 95, 'Cost Efficiency': 85, 'Op. Simplicity': 60, 'Reliability': 80, 'Portability': 88, 'Learning Curve': 50 },
        pros: ['Goroutines for concurrency','Native compiled speed','Type safety'], cons: ['More boilerplate','Smaller web ecosystem'] }
    },
    currentVariant: 'express'
  },
  'fanout-service': {
    name: 'Fan-out Service', category: 'Compute',
    is: 'Distributes new tweets to followers\' timeline caches',
    gain: 'Decouples write path from read path, enables async processing',
    cost: 'Celebrity edge case (millions of followers), cache write amplification',
    position: { x: 590, y: 170 },
    heatStatus: 'red',
    connections: [
      { target: 'timeline-cache', label: 'Write', connType: 'cache', protocol: 'RESP (TCP:6379)', pattern: 'LPUSH → Cache Update',
        direction: 'Fan-out service writes to followers\' timeline caches',
        role: 'Cache Writer',
        summary: 'For each new tweet, the fan-out service pushes it to all followers\' cached timelines. This pre-computes timelines at write time, making reads instant. The trade-off: a celebrity with 10M followers triggers 10M cache writes.',
        latency: '~0.2ms per write (batched)', colocatable: true,
        code: `<span class="cm">// Fan-out → Timeline Cache</span>\n<span class="kw">for</span> (<span class="kw">const</span> follower <span class="kw">of</span> followers) {\n  <span class="kw">await</span> redis.<span class="fn">lpush</span>(\n    <span class="str">\`timeline:\${follower}\`</span>,\n    <span class="fn">JSON.stringify</span>(tweet)\n  )\n  <span class="kw">await</span> redis.<span class="fn">ltrim</span>(<span class="str">\`timeline:\${follower}\`</span>, <span class="num">0</span>, <span class="num">999</span>)\n}` },
      { target: 'tweet-store', label: 'Read', connType: 'database', protocol: 'DB Wire Protocol', pattern: 'Query → Follower List',
        direction: 'Fan-out service reads follower lists from the database',
        role: 'Follow Graph Query',
        summary: 'On each tweet event, the fan-out service queries the follow graph to get the list of followers. For hybrid mode, it also checks if the author is a celebrity (follower count threshold) to decide whether to fan out or skip.',
        latency: '~2-5ms (indexed query)', colocatable: true,
        code: `<span class="cm">// Fan-out → Tweet Store (follow graph)</span>\n<span class="kw">const</span> { rows } = <span class="kw">await</span> db.<span class="fn">query</span>(\n  <span class="str">'SELECT follower_id FROM follows WHERE user_id = $1'</span>,\n  [authorId]\n)\n<span class="kw">const</span> followers = rows.<span class="fn">map</span>(r => r.follower_id)` }
    ],
    dataContext: [
      { name: 'Celebrity Posts (10M+ followers)', icon: 'celebrity', behaviors: {
        'fanout-write': { fit: 'poor', note: '10M cache writes = minutes of work, unsustainable' },
        'fanout-read': { fit: 'great', note: 'Single tweet insert, no fan-out — cheap and fast' },
        'hybrid': { fit: 'great', note: 'Skip fan-out for celebrities, query on read instead' }
      }},
      { name: 'Normal User Posts', icon: 'user', behaviors: {
        'fanout-write': { fit: 'great', note: 'Few hundred cache writes, completes in <100ms' },
        'fanout-read': { fit: 'poor', note: 'Slow timeline reads — must query all followed users' },
        'hybrid': { fit: 'great', note: 'Fan out for normal users — fast reads, cheap writes' }
      }},
      { name: 'Timeline Assembly', icon: 'timeline', behaviors: {
        'fanout-write': { fit: 'great', note: 'Pre-built timelines, instant reads from cache' },
        'fanout-read': { fit: 'tradeoff', note: 'Assemble on-demand from followed users, slower' },
        'hybrid': { fit: 'great', note: 'Mix: cached for normal, query-merged for celebrities' }
      }}
    ],
    variants: {
      'fanout-write': { label: 'Fan-out on Write',
        metrics: { 'Read Perf': 95, 'Write Perf': 25, 'Scalability': 35, 'Cost Efficiency': 40, 'Op. Simplicity': 70, 'Reliability': 65, 'Learning Curve': 75 },
        pros: ['Instant timeline reads','Pre-computed timelines','Simple read logic'], cons: ['Celebrity bottleneck','Expensive writes','Cache storage cost'] },
      'fanout-read': { label: 'Fan-out on Read',
        metrics: { 'Read Perf': 35, 'Write Perf': 95, 'Scalability': 85, 'Cost Efficiency': 80, 'Op. Simplicity': 60, 'Reliability': 75, 'Learning Curve': 65 },
        pros: ['Cheap writes','Scales with celebrities','No cache write amplification'], cons: ['Slow timeline reads','Complex query logic','Database load'] },
      'hybrid': { label: 'Hybrid Approach',
        metrics: { 'Read Perf': 82, 'Write Perf': 65, 'Scalability': 72, 'Cost Efficiency': 60, 'Op. Simplicity': 30, 'Reliability': 70, 'Learning Curve': 35 },
        pros: ['Best of both worlds','Handles celebrities','Fast reads for most users'], cons: ['Complex routing logic','Two code paths','Harder to debug'] }
    },
    currentVariant: 'fanout-write'
  },
  'tweet-store': {
    name: 'Tweet Store', category: 'Data Storage',
    is: 'Persistent database for tweet data, user profiles, and follow graph',
    gain: 'ACID compliance, strong consistency, complex queries',
    cost: 'Scaling limits, schema rigidity, join overhead',
    position: { x: 80, y: 380 },
    heatStatus: 'green',
    connections: [],
    dataContext: [
      { name: 'Tweets Table', icon: 'table', behaviors: {
        'postgresql': { fit: 'great', note: 'Relational model, indexed by author_id and created_at' },
        'cassandra': { fit: 'great', note: 'Wide-column store, partition by author_id for fast writes' },
        'dynamodb': { fit: 'good', note: 'Key-value, partition by author_id, LSI for timeline queries' }
      }},
      { name: 'Follow Graph', icon: 'graph', behaviors: {
        'postgresql': { fit: 'great', note: 'JOIN-friendly, bi-directional follows with foreign keys' },
        'cassandra': { fit: 'tradeoff', note: 'Denormalized: two tables (followers + following) for fast lookups' },
        'dynamodb': { fit: 'good', note: 'GSI on follower_id for reverse lookups' }
      }},
      { name: 'User Profiles', icon: 'session', behaviors: {
        'postgresql': { fit: 'great', note: 'Clean relational model, easy JOINs to tweets and follows' },
        'cassandra': { fit: 'good', note: 'Partition by user_id, fast point lookups' },
        'dynamodb': { fit: 'great', note: 'Simple key-value, DynamoDB streams for change capture' }
      }}
    ],
    variants: {
      'postgresql': { label: 'PostgreSQL',
        metrics: { 'Read Perf': 75, 'Write Perf': 80, 'Scalability': 55, 'Consistency': 95, 'Op. Simplicity': 70, 'Reliability': 90, 'Learning Curve': 75 },
        pros: ['Strong consistency','Complex queries','ACID guarantees'], cons: ['Vertical scaling limits','Schema migrations','JOIN overhead at scale'] },
      'cassandra': { label: 'Cassandra',
        metrics: { 'Read Perf': 85, 'Write Perf': 95, 'Scalability': 95, 'Consistency': 65, 'Op. Simplicity': 35, 'Reliability': 85, 'Learning Curve': 30 },
        pros: ['Linear write scaling','Multi-datacenter replication','No single point of failure'], cons: ['Eventual consistency','Denormalization complexity','Operational overhead'] },
      'dynamodb': { label: 'DynamoDB',
        metrics: { 'Read Perf': 82, 'Write Perf': 88, 'Scalability': 92, 'Consistency': 70, 'Op. Simplicity': 85, 'Reliability': 95, 'Learning Curve': 60 },
        pros: ['Fully managed','Auto-scaling','Low operational overhead'], cons: ['Vendor lock-in','Eventual consistency (default)','Cost at scale'] }
    },
    currentVariant: 'postgresql'
  },
  'timeline-cache': {
    name: 'Timeline Cache', category: 'Caching',
    is: 'In-memory cache holding pre-computed home timelines per user',
    gain: 'Sub-millisecond reads, pre-built timelines',
    cost: 'Memory cost per user, cache invalidation complexity',
    position: { x: 330, y: 380 },
    heatStatus: 'yellow',
    connections: [],
    dataContext: [
      { name: 'Home Timeline (per-user cached list)', icon: 'timeline', behaviors: {
        'redis': { fit: 'great', note: 'LIST data structure, LPUSH for new tweets, LRANGE for reads' },
        'memcached': { fit: 'tradeoff', note: 'Simple key-value, must serialize/deserialize full timeline' },
        'keydb': { fit: 'great', note: 'Multi-threaded Redis clone, 5x throughput on writes' }
      }},
      { name: 'User Timeline', icon: 'user', behaviors: {
        'redis': { fit: 'great', note: 'Per-user sorted set, ZADD with timestamp scores' },
        'memcached': { fit: 'good', note: 'Simple cache, TTL-based expiry' },
        'keydb': { fit: 'great', note: 'Parallel I/O handles concurrent user timeline requests' }
      }},
      { name: 'Trending Cache', icon: 'trending', behaviors: {
        'redis': { fit: 'great', note: 'ZSET with scores for trending topics, ZINCRBY for vote counting' },
        'memcached': { fit: 'poor', note: 'No native sorted set support' },
        'keydb': { fit: 'great', note: 'Multi-threaded ZINCRBY scales for high-traffic trending updates' }
      }}
    ],
    variants: {
      'redis': { label: 'Redis',
        metrics: { 'Read Perf': 95, 'Write Perf': 85, 'Scalability': 70, 'Cost Efficiency': 65, 'Op. Simplicity': 75, 'Reliability': 75, 'Portability': 90, 'Learning Curve': 80 },
        pros: ['Sub-ms latency','Rich data structures','Persistence options'], cons: ['Single-threaded (one core)','Memory cost per user','Persistence trade-offs'] },
      'memcached': { label: 'Memcached',
        metrics: { 'Read Perf': 92, 'Write Perf': 90, 'Scalability': 85, 'Cost Efficiency': 75, 'Op. Simplicity': 85, 'Reliability': 70, 'Portability': 95, 'Learning Curve': 90 },
        pros: ['Simple key-value','Multi-threaded','Low memory overhead'], cons: ['No persistence','No data structures (only strings)','Manual serialization'] },
      'keydb': { label: 'KeyDB',
        metrics: { 'Read Perf': 95, 'Write Perf': 95, 'Scalability': 85, 'Cost Efficiency': 70, 'Op. Simplicity': 72, 'Reliability': 78, 'Portability': 85, 'Learning Curve': 75 },
        pros: ['Multi-threaded Redis clone','5x write throughput','Redis-compatible API'], cons: ['Smaller community','Less mature','Fewer managed offerings'] }
    },
    currentVariant: 'redis'
  },
  'message-queue': {
    name: 'Message Queue', category: 'Messaging',
    is: 'Event streaming platform for async tweet distribution',
    gain: 'Decoupled processing, replay capability, high throughput',
    cost: 'Operational complexity, ordering trade-offs',
    position: { x: 590, y: 380 },
    heatStatus: 'yellow',
    connections: [
      { target: 'fanout-service', label: 'Consume', connType: 'queue', protocol: 'Kafka Binary Protocol (TCP:9092)', pattern: 'Poll → Process → Commit',
        direction: 'Queue delivers tweet events to fan-out service for distribution',
        role: 'Event Stream',
        summary: 'The fan-out service runs as a Kafka consumer, polling for new tweet events. On each event, it queries the follow graph and pushes the tweet to all followers\' caches. Consumer group ensures parallel processing across multiple fan-out workers.',
        latency: '~10-50ms (poll interval)', colocatable: false,
        code: `<span class="cm">// Message Queue → Fan-out Service</span>\n<span class="kw">const</span> consumer = kafka.<span class="fn">consumer</span>({ groupId: <span class="str">'fanout'</span> })\n<span class="kw">await</span> consumer.<span class="fn">subscribe</span>({ topic: <span class="str">'tweet-events'</span> })\n<span class="kw">await</span> consumer.<span class="fn">run</span>({\n  <span class="fn">eachMessage</span>: <span class="kw">async</span> ({ message }) => {\n    <span class="kw">await</span> fanoutService.<span class="fn">process</span>(message.value)\n  }\n})` }
    ],
    dataContext: [
      { name: 'New Tweet Events', icon: 'message', behaviors: {
        'kafka': { fit: 'great', note: 'Partitioned by author_id, ordered per-user, parallel processing' },
        'rabbitmq': { fit: 'good', note: 'Fanout exchange broadcasts to all follower queues' },
        'redis-streams': { fit: 'good', note: 'Lightweight streams, consumer groups for parallel processing' }
      }},
      { name: 'Follow/Unfollow Events', icon: 'event', behaviors: {
        'kafka': { fit: 'great', note: 'Compacted topic keeps latest follow state per user pair' },
        'rabbitmq': { fit: 'tradeoff', note: 'No native compaction, must manage state externally' },
        'redis-streams': { fit: 'good', note: 'Streams with XTRIM for bounded size' }
      }},
      { name: 'Notification Triggers', icon: 'notification', behaviors: {
        'kafka': { fit: 'great', note: 'Multi-partition, parallel notification workers' },
        'rabbitmq': { fit: 'great', note: 'Classic use case: work queues with acknowledgments' },
        'redis-streams': { fit: 'good', note: 'Fast in-memory delivery, pending entry tracking' }
      }}
    ],
    variants: {
      'kafka': { label: 'Kafka',
        metrics: { 'Throughput': 95, 'Ordering': 70, 'Scalability': 92, 'Op. Simplicity': 40, 'Reliability': 90, 'Portability': 75, 'Learning Curve': 35 },
        pros: ['Massive throughput','Replay capability','Durable event log'], cons: ['Operational complexity','Zookeeper dependency','Steep learning curve'] },
      'rabbitmq': { label: 'RabbitMQ',
        metrics: { 'Throughput': 70, 'Ordering': 85, 'Scalability': 70, 'Op. Simplicity': 65, 'Reliability': 85, 'Portability': 85, 'Learning Curve': 60 },
        pros: ['Flexible routing','Mature ecosystem','Good tooling'], cons: ['Lower throughput than Kafka','No native replay','Memory-bound'] },
      'redis-streams': { label: 'Redis Streams',
        metrics: { 'Throughput': 88, 'Ordering': 75, 'Scalability': 65, 'Op. Simplicity': 78, 'Reliability': 70, 'Portability': 80, 'Learning Curve': 72 },
        pros: ['Simple setup','Fast in-memory delivery','Consumer groups built-in'], cons: ['Limited durability','Memory-bound','Less mature than Kafka'] }
    },
    currentVariant: 'kafka'
  }
};

const dashboardCategories = [
  { name: 'Perf', key: 'perf', icon: 'perf' },
  { name: 'Cost', key: 'cost', icon: 'cost_dash' },
  { name: 'Reliab', key: 'rel', icon: 'rel' },
  { name: 'Ops', key: 'ops', icon: 'ops' },
  { name: 'Scale', key: 'scale', icon: 'scale' },
  { name: 'Strat', key: 'strat', icon: 'strat' },
  { name: 'Dev', key: 'dev', icon: 'dev_dash' }
];

// Maps each component metric to a dashboard category key
const METRIC_TO_CATEGORY = {
  'Latency': 'perf',
  'Throughput': 'perf',
  'Read Perf': 'perf',
  'Write Perf': 'perf',
  'Cost Efficiency': 'cost',
  'Reliability': 'rel',
  'Consistency': 'rel',
  'Ordering': 'rel',
  'Op. Simplicity': 'ops',
  'Scalability': 'scale',
  'Portability': 'strat',
  'Learning Curve': 'dev'
};

// ═══════════════ STATE ═══════════════
const state = {
  selectedNode: null,
  selectedConnection: null, // { sourceId, targetId }
  heatmapEnabled: false,
  toolboxTab: 'components',
  swapOpenNode: null,
  variantOpenNode: null,
  // Node drag state
  dragging: null,    // node id being dragged
  dragStart: null,   // { mx, my, nx, ny } mouse + node start positions
  dragMoved: false,  // true if mouse actually moved (to distinguish click vs drag)
  // Connection label drag state
  draggingConn: null,  // { sourceId, targetId, connIdx }
  connDragStart: null, // { mx, my, ox, oy } mouse + original offset
  // Collapsible section state
  collapsedSections: new Set(),
  lastDeltas: {},
  deltaTimeout: null,
  issuesOpen: false,
  flowParticles: [],
  flowAnimationId: null,
  hiddenMetrics: new Set(['Reliability', 'Portability', 'Learning Curve']),
  metricFilterOpen: false,
  inspSwapOpen: false,
  inspVariantOpen: false,
  dashboardExpanded: false
};
let connectionPathData = [];

// ═══════════════ HELPER FUNCTIONS ═══════════════

function getMetricColor(value) {
  if (value >= 70) return 'var(--green)';
  if (value >= 40) return 'var(--yellow)';
  return 'var(--red)';
}

function getHeatColor(status) {
  if (status === 'green') return 'var(--green)';
  if (status === 'yellow') return 'var(--yellow)';
  return 'var(--red)';
}

function getConnectionHealth(srcId, tgtId) {
  const src = components[srcId];
  const tgt = components[tgtId];
  // Worst of the two endpoints
  const priority = { 'red': 0, 'yellow': 1, 'green': 2 };
  return priority[src.heatStatus] <= priority[tgt.heatStatus] ? src.heatStatus : tgt.heatStatus;
}

const HEALTH_LABELS = {
  green: { label: 'Healthy', color: 'var(--green)', icon: 'gain',
    desc: 'Both endpoints are performing well. This connection is not a bottleneck — data flows efficiently between these components.' },
  yellow: { label: 'Warning', color: 'var(--yellow)', icon: 'Monitoring',
    desc: 'One or both endpoints have degraded metrics. This connection may become a bottleneck under load. Consider optimizing the weaker endpoint or adjusting its configuration variant.' },
  red: { label: 'Bottleneck', color: 'var(--red)', icon: 'cons',
    desc: 'One or both endpoints are critically underperforming. This connection is likely a system bottleneck. The weakest endpoint constrains the entire path — improving it will have the most impact.' }
};

function buildEndpointMetricDetail(nodeId, panelId) {
  const c = components[nodeId];
  const metrics = c.variants[c.currentVariant].metrics;
  const entries = Object.entries(metrics);
  const belowThreshold = entries.filter(([, v]) => v < 70);
  const causeText = belowThreshold.length === 0
    ? '<div style="font-size:10px;color:var(--green);margin-bottom:4px">All metrics above threshold</div>'
    : `<div class="conn-health-metrics-label">${belowThreshold.length} metric${belowThreshold.length > 1 ? 's' : ''} below threshold (70)</div>`;
  return `<div class="conn-health-metrics" id="${panelId}">
    ${causeText}
    ${entries.map(([name, val]) => {
      const color = getMetricColor(val);
      const isCause = val < 70;
      return `<div class="conn-health-metric-row">
        <span class="conn-health-metric-flag" style="color:${isCause ? 'var(--red)' : 'transparent'}">${isCause ? '!' : ''}</span>
        <span class="conn-health-metric-name" style="${isCause ? 'color:var(--text-primary);font-weight:500' : ''}">${name}</span>
        <div class="conn-health-metric-bar">
          <div class="conn-health-metric-fill" style="width:${val}%;background:${color}"></div>
        </div>
        <span class="conn-health-metric-val" style="color:${color}">${val}</span>
      </div>`;
    }).join('')}
  </div>`;
}

function toggleConnHealthDetail(panelId, event) {
  if (event) event.stopPropagation();
  const el = document.getElementById(panelId);
  if (el) el.classList.toggle('visible');
}

function renderConnectionHealth(srcId, tgtId) {
  const health = getConnectionHealth(srcId, tgtId);
  const h = HEALTH_LABELS[health];
  const src = components[srcId];
  const tgt = components[tgtId];
  const srcH = HEALTH_LABELS[src.heatStatus];
  const tgtH = HEALTH_LABELS[tgt.heatStatus];
  const infoIcon = `<svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><circle cx="8" cy="8" r="6"/><path d="M8 7v4M8 5v.5"/></svg>`;
  const content = `<div class="conn-health-indicator">
      <div class="conn-health-badge" style="background:${h.color}20;color:${h.color};border:1px solid ${h.color}40">
        <span class="conn-health-dot" style="background:${h.color}"></span> ${h.label}
      </div>
      <div class="conn-health-desc">${h.desc}</div>
      <div class="conn-health-endpoints">
        <div>
          <div class="conn-health-ep" style="cursor:pointer" title="Inspect ${src.name}">
            <span class="conn-health-dot" style="background:${srcH.color}"></span>
            <span onclick="selectNode('${srcId}')" style="text-decoration:underline;text-decoration-style:dotted;cursor:pointer">${src.name}</span>
            <span style="color:${srcH.color};font-weight:600;margin-left:auto">${srcH.label}</span>
            <button class="conn-health-info-btn" onclick="toggleConnHealthDetail('chd-${srcId}', event)" title="Show metric details">${infoIcon}</button>
          </div>
          ${buildEndpointMetricDetail(srcId, 'chd-' + srcId)}
        </div>
        <div>
          <div class="conn-health-ep" style="cursor:pointer" title="Inspect ${tgt.name}">
            <span class="conn-health-dot" style="background:${tgtH.color}"></span>
            <span onclick="selectNode('${tgtId}')" style="text-decoration:underline;text-decoration-style:dotted;cursor:pointer">${tgt.name}</span>
            <span style="color:${tgtH.color};font-weight:600;margin-left:auto">${tgtH.label}</span>
            <button class="conn-health-info-btn" onclick="toggleConnHealthDetail('chd-${tgtId}', event)" title="Show metric details">${infoIcon}</button>
          </div>
          ${buildEndpointMetricDetail(tgtId, 'chd-' + tgtId)}
        </div>
      </div>
      <div class="conn-health-rule">Health = worst of the two endpoints</div>
    </div>`;
  return collapsible('conn-health', 'Monitoring', 'var(--text-secondary)', 'Connection Health', content);
}

function icon(name, color) {
  const svg = ICONS[name] || '';
  if (color) return svg.replace(/stroke="currentColor"/g, `stroke="${color}"`);
  return svg;
}

// ═══════════════ COLLAPSIBLE HELPER ═══════════════

function toggleInspSwap(event) {
  if (event) event.stopPropagation();
  state.inspVariantOpen = false;
  state.inspSwapOpen = !state.inspSwapOpen;
  renderInspector();
  if (state.inspSwapOpen) positionInspDropdown('.insp-swap-btn', '.insp-header-dropdown.swap');
}

function toggleInspVariant(event) {
  if (event) event.stopPropagation();
  state.inspSwapOpen = false;
  state.inspVariantOpen = !state.inspVariantOpen;
  renderInspector();
  if (state.inspVariantOpen) positionInspDropdown('.insp-variant-btn', '.insp-header-dropdown.variant');
}

function positionInspDropdown(btnSelector, menuSelector) {
  const btn = document.querySelector(btnSelector);
  const menu = document.querySelector(menuSelector);
  if (!btn || !menu) return;
  const rect = btn.getBoundingClientRect();
  menu.style.top = (rect.bottom + 4) + 'px';
  // For swap dropdown, align left; for variant, align right
  if (menuSelector.includes('swap')) {
    menu.style.left = rect.left + 'px';
  } else {
    menu.style.right = (window.innerWidth - rect.right) + 'px';
  }
}

function inspSwapComponent(newId, event) {
  if (event) event.stopPropagation();
  state.inspSwapOpen = false;
  swapComponent(state.selectedNode, newId);
}

function inspChangeVariant(variantKey, event) {
  if (event) event.stopPropagation();
  state.inspVariantOpen = false;
  changeVariant(state.selectedNode, variantKey);
}

function toggleMetricFilter(event) {
  if (event) event.stopPropagation();
  state.metricFilterOpen = !state.metricFilterOpen;
  renderInspector();
  if (state.metricFilterOpen) {
    positionMetricFilterMenu();
  }
}

function positionMetricFilterMenu() {
  const btn = document.querySelector('.metric-filter-btn');
  const menu = document.querySelector('.metric-filter-menu');
  if (!btn || !menu) return;
  const rect = btn.getBoundingClientRect();
  menu.style.top = (rect.bottom + 4) + 'px';
  menu.style.right = (window.innerWidth - rect.right) + 'px';
}

function toggleMetricVisibility(metricName, event) {
  if (event) event.stopPropagation();
  if (state.hiddenMetrics.has(metricName)) {
    state.hiddenMetrics.delete(metricName);
  } else {
    state.hiddenMetrics.add(metricName);
  }
  renderInspector();
  if (state.metricFilterOpen) positionMetricFilterMenu();
}

function setAllMetrics(show, event) {
  if (event) event.stopPropagation();
  const c = components[state.selectedNode];
  const v = c.variants[c.currentVariant];
  if (show) {
    Object.keys(v.metrics).forEach(name => state.hiddenMetrics.delete(name));
  } else {
    Object.keys(v.metrics).forEach(name => state.hiddenMetrics.add(name));
  }
  renderInspector();
  if (state.metricFilterOpen) positionMetricFilterMenu();
}

function toggleMetricExplanation(panelId, event) {
  if (event) event.stopPropagation();
  const el = document.getElementById(panelId);
  if (!el) return;
  // Close other open metric explanations first
  document.querySelectorAll('.metric-explanation.visible').forEach(other => {
    if (other.id !== panelId) other.classList.remove('visible');
  });
  el.classList.toggle('visible');
}

function toggleSection(sectionId) {
  if (state.collapsedSections.has(sectionId)) {
    state.collapsedSections.delete(sectionId);
  } else {
    state.collapsedSections.add(sectionId);
  }
  const body = document.getElementById(sectionId);
  if (body) body.classList.toggle('collapsed');
  const title = document.querySelector(`[data-toggle="${sectionId}"]`);
  if (title) {
    const chev = title.querySelector('.section-chevron');
    if (chev) chev.classList.toggle('open');
  }
}

function collapsible(id, titleIcon, titleColor, titleText, content) {
  const isCollapsed = state.collapsedSections.has(id);
  return `<div class="insp-section">
    <div class="insp-section-title collapsible" data-toggle="${id}" onclick="toggleSection('${id}')">
      ${icon(titleIcon, titleColor)} ${titleText}
      <span class="section-chevron ${isCollapsed ? '' : 'open'}">${icon('chevron', 'var(--text-secondary)')}</span>
    </div>
    <div class="insp-section-body ${isCollapsed ? 'collapsed' : ''}" id="${id}">${content}</div>
  </div>`;
}

// ═══════════════ RENDER FUNCTIONS ═══════════════

function renderLegend() {
  const el = document.getElementById('canvasLegend');
  if (state.heatmapEnabled) {
    el.innerHTML = `
      <div class="legend-title">${icon('Monitoring', 'var(--text-secondary)')} Health Overlay</div>
      <div class="legend-item"><div class="legend-dot" style="border-color:var(--green)"></div> Healthy</div>
      <div class="legend-item"><div class="legend-dot" style="border-color:var(--yellow)"></div> Warning</div>
      <div class="legend-item"><div class="legend-dot" style="border-color:var(--red)"></div> Bottleneck</div>
      <div class="legend-divider"></div>
      <div class="legend-item"><div class="legend-swatch" style="background:var(--green)"></div> Line: healthy</div>
      <div class="legend-item"><div class="legend-swatch" style="background:var(--yellow);height:2px;border-top:1px dashed var(--yellow)"></div> Line: warning</div>
      <div class="legend-item"><div class="legend-swatch" style="background:var(--red);height:2px;border-top:1px dashed var(--red)"></div> Line: bottleneck</div>
    `;
  } else {
    // Show category legend for visible categories
    const usedCats = new Set(Object.values(components).map(c => c.category));
    el.innerHTML = `
      <div class="legend-title">${icon('Search', 'var(--text-secondary)')} Component Types</div>
      ${[...usedCats].map(cat => `<div class="legend-item clickable" onclick="showCategoryInfo('${cat}')" title="About ${cat}">${icon(cat, CATEGORIES[cat].color)} <span style="color:var(--text-secondary)">${cat}</span></div>`).join('')}
    `;
  }
}

function renderToolbox() {
  const el = document.getElementById('toolboxContent');
  if (state.toolboxTab === 'components') {
    // Build a set of component names currently on canvas
    const onCanvas = new Set(Object.values(components).map(c => c.name));

    el.innerHTML = Object.entries(COMPONENT_CATALOG).map(([catName, items]) => {
      const cat = CATEGORIES[catName];
      const info = CATEGORY_INFO[catName];
      const groupId = `catgrp-${catName.replace(/[^a-zA-Z]/g, '')}`;
      const isCollapsed = state.collapsedSections.has(groupId);
      const activeCount = items.filter(i => onCanvas.has(i.name)).length;

      return `<div class="cat-group">
        <div class="cat-group-header" onclick="toggleSection('${groupId}')" data-toggle="${groupId}">
          ${icon(catName, cat.color)}
          <span class="cat-group-name" style="color:${cat.color}">${catName}</span>
          ${activeCount ? `<span class="cat-item-active">${activeCount} in use</span>` : ''}
          <span class="cat-group-count">${items.length}</span>
          <span class="section-chevron ${isCollapsed ? '' : 'open'}">${icon('chevron', 'var(--text-secondary)')}</span>
        </div>
        <div class="cat-group-body ${isCollapsed ? 'collapsed' : ''}" id="${groupId}">
          ${info ? `<div class="cat-group-desc">${info.role}</div>` : ''}
          ${items.map(item => {
            const isActive = onCanvas.has(item.name);
            const fromTags = item.connectsFrom.map(t => `<span class="cat-item-tip-tag">${t}</span>`).join('');
            const toTags = item.connectsTo.map(t => `<span class="cat-item-tip-tag">${t}</span>`).join('');
            // Find the canvas node id if this component is on canvas
            const canvasId = Object.entries(components).find(([, c]) => c.name === item.name)?.[0];
            return `<div class="cat-item${isActive ? ' active-item' : ''}" ${canvasId ? `ondblclick="selectNode('${canvasId}')"` : ''}>
              <span class="cat-item-dot" style="background:${cat.color}${isActive ? '' : '60'}"></span>
              <span class="cat-item-name">${item.name}</span>
              ${isActive ? '<span class="cat-item-active">ON CANVAS</span>' : ''}
              <span class="cat-item-sub">${item.sub}</span>
              <div class="cat-item-tip">
                <strong>${item.name}</strong> <span style="color:var(--text-secondary)">· ${item.sub}</span>
                ${item.connectsFrom.length ? `<div class="cat-item-tip-label">Receives from</div><div class="cat-item-tip-list">${fromTags}</div>` : ''}
                ${item.connectsTo.length ? `<div class="cat-item-tip-label">Connects to</div><div class="cat-item-tip-list">${toTags}</div>` : ''}
              </div>
            </div>`;
          }).join('')}
        </div>
      </div>`;
    }).join('');
  } else if (state.toolboxTab === 'stacks') {
    el.innerHTML = `<div class="component-card" style="border-left-color:var(--accent)">
      <div class="card-header">
        <div class="card-icon">${icon('Messaging', 'var(--accent)')}</div>
        <div><div class="card-name">Real-Time Messaging Stack</div><div class="card-category">${icon('Messaging', 'var(--accent)')} 5 components</div></div></div>
      <div class="card-section"><div class="card-section-label card-is">${icon('is', 'var(--text-secondary)')} IS</div>Pre-wired stack for real-time message delivery with persistence and caching</div>
      <div class="card-section"><div class="card-section-label card-gain">${icon('gain', 'var(--green)')} GAIN</div>Complete messaging pipeline, proven pattern</div>
      <div class="card-section"><div class="card-section-label card-cost">${icon('cost', 'var(--yellow)')} COST</div>Full Kafka + Redis operational burden</div>
    </div>
    <div class="component-card" style="border-left-color:var(--cat-auth)">
      <div class="card-header">
        <div class="card-icon">${icon('Auth/Security', 'var(--cat-auth)')}</div>
        <div><div class="card-name">Auth Stack</div><div class="card-category">${icon('Auth/Security', 'var(--cat-auth)')} 3 components</div></div></div>
      <div class="card-section"><div class="card-section-label card-is">${icon('is', 'var(--text-secondary)')} IS</div>Authentication and authorization with JWT, rate limiting, and session store</div>
    </div>`;
  } else {
    el.innerHTML = `<div class="component-card" style="border-left-color:var(--accent)">
      <div class="card-header">
        <div class="card-icon">${icon('Delivery/Network', 'var(--accent)')}</div>
        <div><div class="card-name">Twitter Timeline</div><div class="card-category">${icon('Monitoring', 'var(--accent)')} Tier 2 · 6 components</div></div></div>
      <div class="card-section"><div class="card-section-label card-is">${icon('is', 'var(--text-secondary)')} IS</div>Real-time messaging with persistent storage, caching layer, and event streaming</div>
    </div>
    <div class="component-card" style="border-left-color:var(--cat-realtime)">
      <div class="card-header">
        <div class="card-icon">${icon('Real-Time', 'var(--cat-realtime)')}</div>
        <div><div class="card-name">Social Feed Pipeline</div><div class="card-category">${icon('Monitoring', 'var(--cat-realtime)')} Tier 2 · 5 components</div></div></div>
      <div class="card-section"><div class="card-section-label card-is">${icon('is', 'var(--text-secondary)')} IS</div>Multi-datacenter messaging with MTProto, distributed file storage, and bot platform</div>
    </div>`;
  }
}

const VARIANT_ICON = '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.5"><circle cx="6" cy="6" r="2"/><path d="M6 1v2M6 9v2M1 6h2M9 6h2"/></svg>';

function renderNodes() {
  const container = document.getElementById('nodesContainer');
  container.innerHTML = Object.entries(components).map(([id, c]) => {
    const cat = CATEGORIES[c.category];
    const v = c.variants[c.currentVariant];
    const allMetrics = Object.entries(v.metrics);
    const visibleMetrics = allMetrics.filter(([k]) => !state.hiddenMetrics.has(k));
    const isSelected = state.selectedNode === id;
    let heatClass = '';
    if (state.heatmapEnabled) heatClass = `heatmap-${c.heatStatus}`;
    const alts = ALTERNATIVES[id] || [];
    const swapOpen = state.swapOpenNode === id;
    const variantOpen = state.variantOpenNode === id;
    const variantKeys = Object.keys(c.variants);
    const hasDropdown = swapOpen || variantOpen;
    return `<div class="node ${isSelected ? 'selected' : ''} ${heatClass}" id="node-${id}"
      data-shape="${cat.shape}" data-node-id="${id}"
      style="left:${c.position.x}px;top:${c.position.y}px;border-top:3px solid ${cat.color}${hasDropdown ? ';z-index:15' : ''}"
      onmousedown="startDrag(event, '${id}')">
      <div class="node-tooltip">
        <div class="tooltip-header">${icon(c.category, cat.color)} <strong>${c.name}</strong> · <span style="color:var(--text-secondary)">${c.category}</span></div>
        <div class="tooltip-metrics">
          ${visibleMetrics.slice(0,4).map(([k,val]) => `<div class="tooltip-metric">${k}: <span>${val}</span></div>`).join('')}
        </div>
      </div>
      <div class="node-body">
        <div class="node-header">
          <div class="node-icon clickable" onclick="event.stopPropagation(); ${alts.length > 1 ? `toggleSwapDropdown('${id}')` : `showCategoryInfo('${c.category}')`}" title="${alts.length > 1 ? 'Swap component' : 'About ' + c.category}">${icon(c.category, cat.color)}</div>
          <div class="node-name">${c.name}</div>
        </div>
        ${swapOpen ? `<div class="node-dropdown left" onclick="event.stopPropagation()">
          ${alts.map(a => `<div class="swap-option ${a.id === id ? 'current' : ''}" onclick="swapComponent('${id}', '${a.id}')">
            ${icon(c.category, cat.color)} ${a.name} <span class="swap-option-sub">${a.sub}</span>
          </div>`).join('')}
        </div>` : ''}
        ${variantKeys.length > 1 ? `<div class="node-variant-btn" onclick="event.stopPropagation(); toggleVariantDropdown('${id}')" title="Change configuration variant">${VARIANT_ICON}</div>` : ''}
        ${variantOpen ? `<div class="node-dropdown right" onclick="event.stopPropagation()">
          ${variantKeys.map(vk => {
            const vl = c.variants[vk];
            return `<div class="swap-option ${vk === c.currentVariant ? 'current' : ''}" onclick="changeVariantFromNode('${id}', '${vk}')">
              ${VARIANT_ICON} ${vl.label} ${vk === c.currentVariant ? '<span class="swap-option-sub">Current</span>' : ''}
            </div>`;
          }).join('')}
        </div>` : ''}
        <div class="node-variant">${v.label}</div>
        <div class="node-mini-metrics">
          ${visibleMetrics.map(([k,val]) => `<div class="node-mini-bar"><div class="node-mini-fill" style="width:${val}%;background:${getMetricColor(val)}"></div></div>`).join('')}
        </div>
      </div>
    </div>`;
  }).join('');
}

function renderConnections() {
  connectionPathData = [];
  const svg = document.getElementById('canvasSvg');
  let defs = `<defs>
    <marker id="arrowDefault" markerWidth="8" markerHeight="6" refX="8" refY="3" orient="auto"><path d="M0,0 L8,3 L0,6" fill="var(--border)"/></marker>
    <marker id="arrowGreen" markerWidth="8" markerHeight="6" refX="8" refY="3" orient="auto"><path d="M0,0 L8,3 L0,6" fill="var(--green)"/></marker>
    <marker id="arrowYellow" markerWidth="8" markerHeight="6" refX="8" refY="3" orient="auto"><path d="M0,0 L8,3 L0,6" fill="var(--yellow)"/></marker>
    <marker id="arrowRed" markerWidth="8" markerHeight="6" refX="8" refY="3" orient="auto"><path d="M0,0 L8,3 L0,6" fill="var(--red)"/></marker>
    <marker id="arrowAccent" markerWidth="8" markerHeight="6" refX="8" refY="3" orient="auto"><path d="M0,0 L8,3 L0,6" fill="var(--accent)"/></marker>
  </defs>`;
  let paths = '';
  let labels = '';
  Object.entries(components).forEach(([id, c]) => {
    c.connections.forEach((conn, ci) => {
      const targetId = conn.target;
      const src = c.position;
      const tgt = components[targetId].position;
      const sx = src.x + 76, sy = src.y + 50;
      const tx = tgt.x + 76, ty = tgt.y + 10;
      const baseMx = (sx + tx) / 2, baseMy = (sy + ty) / 2;
      // Offset defines where the LABEL sits (on the curve at t=0.5)
      if (!conn.offset) conn.offset = { x: 0, y: 0 };
      // Label position = midpoint + offset (this is where the curve passes at t=0.5)
      const lx = baseMx + conn.offset.x;
      const ly = baseMy + conn.offset.y;
      // Derive control point so curve passes through label at t=0.5
      // P(0.5) = 0.25*P0 + 0.5*Pc + 0.25*P1  →  Pc = 2*P(0.5) - 0.5*(P0+P1)
      const cpx = 2 * lx - 0.5 * (sx + tx);
      const cpy = 2 * ly - 0.5 * (sy + ty);
      const pathD = `M${sx},${sy} Q${cpx},${cpy} ${tx},${ty}`;
      const health = getConnectionHealth(id, targetId);
      connectionPathData.push({ sx, sy, cpx, cpy, tx, ty, health });
      let heatClass = '';
      let markerEnd = 'url(#arrowDefault)';
      if (state.heatmapEnabled) {
        heatClass = `heat-${health}`;
        markerEnd = `url(#arrow${health.charAt(0).toUpperCase() + health.slice(1)})`;
      }
      const isSelected = state.selectedConnection &&
        state.selectedConnection.sourceId === id && state.selectedConnection.targetId === targetId;
      if (isSelected) markerEnd = 'url(#arrowAccent)';
      paths += `<path id="conn-${id}-${targetId}" class="conn-path ${heatClass} ${isSelected ? 'conn-selected' : ''}" d="${pathD}" marker-end="${markerEnd}"/>`;
      // Label sits exactly on the curve at t=0.5
      const labelText = conn.label || '';
      const connType = conn.connType || 'http';
      const ctDef = CONN_TYPE_DEFS[connType];
      const iconSpace = 14; // 10px icon + 4px gap
      const labelW = labelText.length * 6 + 16 + iconSpace;
      const iconX = lx - labelW/2 + 4;
      const iconY = ly - 5;
      const textX = lx + iconSpace/2;
      labels += `<g class="conn-label-group ${isSelected ? 'selected' : ''}"
        onmousedown="event.stopPropagation(); startConnDrag(event, '${id}', '${targetId}', ${ci})"
        onclick="event.stopPropagation();">
        <rect class="conn-label-bg ${isSelected ? 'selected' : ''}" x="${lx - labelW/2}" y="${ly - 9}" width="${labelW}" height="18" />
        <g transform="translate(${iconX},${iconY}) scale(1)"><path d="${ctDef.path}" fill="none" stroke="${ctDef.color}" stroke-width="1.3"/></g>
        <text class="conn-label-text" x="${textX}" y="${ly}">${labelText}</text>
      </g>`;
    });
  });
  svg.innerHTML = defs + paths + labels;
}

function renderInspector() {
  const el = document.getElementById('inspectorContent');

  // Connection detail view
  if (state.selectedConnection) {
    const { sourceId, targetId } = state.selectedConnection;
    const conn = getConnectionData(sourceId, targetId);
    const srcComp = components[sourceId];
    const tgtComp = components[targetId];
    if (!conn || !srcComp || !tgtComp) { state.selectedConnection = null; return renderInspector(); }
    const srcCat = CATEGORIES[srcComp.category];
    const tgtCat = CATEGORIES[tgtComp.category];
    el.innerHTML = `
      <div class="conn-header">
        <div class="conn-endpoint" onclick="selectNode('${sourceId}')" title="Inspect ${srcComp.name}">
          <div class="conn-ep-icon" style="border-color:${srcCat.color}">${icon(srcComp.category, srcCat.color)}</div>
          <div class="conn-ep-name">${srcComp.name}</div>
        </div>
        <div class="conn-header-arrow">${icon('arrow_right', 'var(--text-secondary)')}</div>
        <div class="conn-endpoint" onclick="selectNode('${targetId}')" title="Inspect ${tgtComp.name}">
          <div class="conn-ep-icon" style="border-color:${tgtCat.color}">${icon(tgtComp.category, tgtCat.color)}</div>
          <div class="conn-ep-name">${tgtComp.name}</div>
        </div>
      </div>
      <div class="conn-meta">
        <span class="conn-protocol-badge">${conn.label}</span>
        ${conn.role ? `<span class="conn-role-tag">${conn.role}</span>` : ''}
      </div>
      ${conn.direction ? `<div class="conn-direction-text">${conn.direction}</div>` : ''}
      <div class="conn-props-strip">
        <div class="conn-prop-chip">
          ${icon('protocol', 'var(--text-secondary)')}
          <span class="conn-prop-chip-label">Protocol</span>
          <span class="conn-prop-chip-val">${conn.protocol}</span>
        </div>
        <div class="conn-prop-chip">
          ${icon('pattern', 'var(--text-secondary)')}
          <span class="conn-prop-chip-label">Pattern</span>
          <span class="conn-prop-chip-val">${conn.pattern}</span>
        </div>
        <div class="conn-prop-chip">
          ${icon('speed', 'var(--text-secondary)')}
          <span class="conn-prop-chip-label">Latency</span>
          <span class="conn-prop-chip-val">${conn.latency}</span>
        </div>
        <div class="conn-prop-chip ${conn.colocatable ? 'positive' : 'negative'}">
          ${icon('coloc', conn.colocatable ? 'var(--green)' : 'var(--red)')}
          <span class="conn-prop-chip-label">Co-locatable</span>
          <span class="conn-prop-chip-val">${conn.colocatable ? 'Yes' : 'No'}</span>
        </div>
      </div>
      ${conn.summary ? collapsible('conn-summary', 'is', 'var(--text-secondary)', 'What This Connection Does',
        `<div class="conn-summary">${conn.summary}</div>`) : ''}
      ${renderConnectionHealth(sourceId, targetId)}
      ${conn.code ? collapsible('conn-code', 'code', 'var(--text-secondary)', 'Connection Code',
        `<div class="conn-code-pattern">${conn.code}</div>`) : ''}
      <div class="conn-footer">
        <div class="conn-footer-link" onclick="selectNode('${sourceId}')">
          ${icon(srcComp.category, srcCat.color)} ${srcComp.name}
        </div>
        <div class="conn-footer-link" onclick="selectNode('${targetId}')">
          ${icon(tgtComp.category, tgtCat.color)} ${tgtComp.name}
        </div>
      </div>
    `;
    return;
  }

  if (!state.selectedNode) {
    el.innerHTML = `<div class="inspector-empty">
      <svg viewBox="0 0 32 32" fill="none" stroke="currentColor" stroke-width="1"><circle cx="16" cy="16" r="12"/><path d="M16 10v6M16 20v1"/></svg>
      Click a component or connection on the canvas to inspect it.
    </div>`;
    return;
  }
  const c = components[state.selectedNode];
  const cat = CATEGORIES[c.category];
  const v = c.variants[c.currentVariant];
  const alts = ALTERNATIVES[state.selectedNode] || [];
  const variantKeys = Object.keys(c.variants);
  const currentMetrics = v.metrics;
  const rec = getVariantRecommendation(state.selectedNode);

  // Build swap dropdown items with metric diffs
  const swapDropdownHTML = alts.length > 1 ? `<div class="insp-header-dropdown swap ${state.inspSwapOpen ? 'visible' : ''}">
    ${alts.map(a => {
      const isCurrent = a.id === state.selectedNode;
      const altComp = components[a.id];
      const altMetrics = altComp ? altComp.variants[altComp.currentVariant].metrics : {};
      const metricDiffs = !isCurrent ? Object.entries(currentMetrics).map(([mk, mv]) => {
        const altVal = altMetrics[mk];
        if (altVal === undefined || state.hiddenMetrics.has(mk)) return '';
        const diff = altVal - mv;
        if (diff === 0) return '';
        const mi = METRIC_ICON_MAP[mk] ? icon(METRIC_ICON_MAP[mk], diff > 0 ? 'var(--green)' : 'var(--red)') : '';
        return `<span class="insp-dd-metric ${diff > 0 ? 'positive' : 'negative'}">${mi}${diff > 0 ? '+' : ''}${diff}</span>`;
      }).filter(Boolean).join('') : '';
      return `<div class="insp-dd-item ${isCurrent ? 'current' : ''}" onclick="inspSwapComponent('${a.id}', event)">
        <div class="insp-dd-item-header">
          ${icon(c.category, cat.color)} ${a.name}
          <span class="insp-dd-item-sub">${a.sub}</span>
          ${isCurrent ? '<span class="insp-dd-item-current">Current</span>' : ''}
        </div>
        ${metricDiffs ? `<div class="insp-dd-metrics">${metricDiffs}</div>` : ''}
      </div>`;
    }).join('')}
  </div>` : '';

  // Build variant dropdown items with metric change previews
  const variantDropdownHTML = variantKeys.length > 1 ? `<div class="insp-header-dropdown variant ${state.inspVariantOpen ? 'visible' : ''}">
    ${variantKeys.map(vk => {
      const vv = c.variants[vk];
      const isCurrent = vk === c.currentVariant;
      const metricDiffs = !isCurrent ? Object.entries(vv.metrics).map(([mk, mv]) => {
        const diff = mv - currentMetrics[mk];
        if (diff === 0 || state.hiddenMetrics.has(mk)) return '';
        const mi = METRIC_ICON_MAP[mk] ? icon(METRIC_ICON_MAP[mk], diff > 0 ? 'var(--green)' : 'var(--red)') : '';
        return `<span class="insp-dd-metric ${diff > 0 ? 'positive' : 'negative'}">${mi}${diff > 0 ? '+' : ''}${diff}</span>`;
      }).filter(Boolean).join('') : '';
      return `<div class="insp-dd-item ${isCurrent ? 'current' : ''}" onclick="inspChangeVariant('${vk}', event)">
        <div class="insp-dd-item-header">
          ${VARIANT_ICON} ${vv.label}
          ${isCurrent ? '<span class="insp-dd-item-current">Current</span>' : ''}
        </div>
        ${metricDiffs ? `<div class="insp-dd-metrics">${metricDiffs}</div>` : ''}
      </div>`;
    }).join('')}
    ${rec ? `<div class="insp-dd-rec">${icon('gain', 'var(--accent)')} Try <strong>${rec.label}</strong> for <span class="delta-positive" style="margin-left:2px">+${rec.improvement} ${rec.metric}</span></div>` : ''}
  </div>` : '';
  const allMetricEntries = Object.entries(v.metrics);
  const visibleCount = allMetricEntries.filter(([name]) => !state.hiddenMetrics.has(name)).length;
  const checkSvg = '<svg viewBox="0 0 10 10" fill="none" stroke="white" stroke-width="2"><path d="M2 5l2 2 4-4"/></svg>';
  const filterMenuItems = allMetricEntries.map(([name, val]) => {
    const isVisible = !state.hiddenMetrics.has(name);
    const mi = METRIC_ICON_MAP[name] ? icon(METRIC_ICON_MAP[name], 'var(--text-secondary)') : '';
    return `<div class="metric-filter-item ${isVisible ? 'checked' : ''}" onclick="toggleMetricVisibility('${name}', event)">
      <div class="metric-filter-check">${isVisible ? checkSvg : ''}</div>
      <span class="metric-filter-name">${mi} ${name}</span>
      <span class="metric-filter-val" style="color:${getMetricColor(val)}">${val}</span>
    </div>`;
  }).join('');
  const filterMenu = `<div class="metric-filter-menu ${state.metricFilterOpen ? 'visible' : ''}">
    <div class="metric-filter-actions">
      <button class="metric-filter-action" onclick="setAllMetrics(true, event)">All</button>
      <button class="metric-filter-action" onclick="setAllMetrics(false, event)">None</button>
    </div>
    ${filterMenuItems}
  </div>`;
  const filterBtnLabel = visibleCount < allMetricEntries.length ? `${visibleCount}/${allMetricEntries.length}` : '';
  const filterBtn = `<div class="metric-filter-wrap">
    <button class="metric-filter-btn ${state.metricFilterOpen ? 'active' : ''}" onclick="toggleMetricFilter(event)" title="Choose which metrics to show">
      ${icon('filter', 'currentColor')} ${filterBtnLabel}
    </button>
    ${filterMenu}
  </div>`;

  const metricBars = allMetricEntries.filter(([name]) => !state.hiddenMetrics.has(name)).map(([name, val], idx) => {
    const metricIcon = METRIC_ICON_MAP[name] ? icon(METRIC_ICON_MAP[name], 'var(--text-secondary)') : '';
    const delta = state.lastDeltas[name];
    const deltaHTML = delta ? ` <span class="metric-delta ${delta > 0 ? 'positive' : delta < 0 ? 'negative' : 'neutral'}">${delta > 0 ? '+' : ''}${delta}</span>` : '';
    const explData = METRIC_EXPLANATIONS[state.selectedNode] && METRIC_EXPLANATIONS[state.selectedNode][c.currentVariant] && METRIC_EXPLANATIONS[state.selectedNode][c.currentVariant][name];
    const explId = `mexpl-${idx}`;
    const infoBtn = explData ? `<button class="metric-info-btn" onclick="toggleMetricExplanation('${explId}', event)" title="Why this score?">${icon('info', 'currentColor')}</button>` : '';
    const explPanel = explData ? `<div class="metric-explanation" id="${explId}"><div class="metric-expl-reason">${explData.reason}</div><ul class="metric-expl-factors">${explData.factors.map(f => `<li>${f}</li>`).join('')}</ul></div>` : '';
    return `<div class="metric-row-wrap">
      <div class="metric-row">
        <div class="metric-label"><span class="metric-name">${metricIcon} ${name}</span><span class="metric-value" style="color:${getMetricColor(val)}">${val}${deltaHTML}</span>${infoBtn}</div>
        <div class="metric-bar-track"><div class="metric-bar-fill" style="width:${val}%;background:${getMetricColor(val)}"></div><div class="metric-threshold" style="left:70%" title="Healthy threshold"></div></div>
      </div>
      ${explPanel}
    </div>`;
  }).join('');
  const metricsEmpty = visibleCount === 0 ? '<div style="font-size:11px;color:var(--text-secondary);padding:8px 0;text-align:center;">No metrics selected. Click the filter to add metrics.</div>' : '';

  const codePattern = CODE_PATTERNS[state.selectedNode] && CODE_PATTERNS[state.selectedNode][c.currentVariant];

  // Auto-open metrics for components with issues
  if (c.heatStatus !== 'green') {
    state.collapsedSections.delete('insp-metrics');
  }

  el.innerHTML = `
    <div class="insp-header">
      <div class="insp-header-btn insp-swap-btn ${state.inspSwapOpen ? 'active' : ''}" ${alts.length > 1 ? 'onclick="toggleInspSwap(event)"' : 'style="cursor:default;opacity:0.6"'} title="${alts.length > 1 ? 'Swap component' : c.category}">${icon(c.category, cat.color)}</div>
      <div class="insp-header-center">
        <div class="insp-name">${c.name}</div>
        <div class="insp-variant-label">${v.label}</div>
      </div>
      ${variantKeys.length > 1 ? `<div class="insp-header-btn insp-variant-btn ${state.inspVariantOpen ? 'active' : ''}" onclick="toggleInspVariant(event)" title="Change configuration variant">${VARIANT_ICON}</div>` : ''}
    </div>
    <div class="insp-category"><div class="insp-cat-dot" style="background:${cat.color}"></div>${c.category}</div>
    ${swapDropdownHTML}
    ${variantDropdownHTML}
    <div class="insp-section">
      <div class="insp-section-title collapsible" data-toggle="insp-metrics" onclick="toggleSection('insp-metrics')">
        <span class="metric-section-title-row">
          ${icon('metrics', 'var(--text-secondary)')} Metrics
          <span onclick="event.stopPropagation()">${filterBtn}</span>
        </span>
        <span class="section-chevron ${state.collapsedSections.has('insp-metrics') ? '' : 'open'}">${icon('chevron', 'var(--text-secondary)')}</span>
      </div>
      <div class="insp-section-body ${state.collapsedSections.has('insp-metrics') ? 'collapsed' : ''}" id="insp-metrics">${metricsEmpty}${metricBars}</div>
    </div>
    ${collapsible('insp-tradeoffs', 'cons', 'var(--text-secondary)', 'Pros & Cons',
      `<div class="pros-cons">${v.pros.map(p => `<div class="pro">${p}</div>`).join('')}${v.cons.map(cc => `<div class="con">${cc}</div>`).join('')}</div>`)}
    ${c.dataContext ? collapsible('insp-data', 'data_ctx', 'var(--accent)', 'Your Data Context',
      c.dataContext.map(item => {
        const behavior = item.behaviors[c.currentVariant];
        if (!behavior) return '';
        return `<div class="data-item fit-${behavior.fit}">
          <div class="data-item-header">
            ${icon(item.icon, 'var(--text-secondary)')}
            ${item.name}
            <span class="fit-badge ${behavior.fit}">${behavior.fit === 'tradeoff' ? 'trade-off' : behavior.fit}</span>
          </div>
          <div class="data-item-note">${behavior.note}</div>
        </div>`;
      }).join('')) : ''}
    ${codePattern ? collapsible('insp-code', 'code', 'var(--text-secondary)', 'Implementation Pattern',
      `<div class="code-pattern">${codePattern}</div>`) : ''}
  `;
}

function renderDashboard() {
  // Compact bottom bar
  const el = document.getElementById('dashboardBars');
  const { scores, breakdown } = calculateDashboardScores();
  el.innerHTML = dashboardCategories.map(cat => {
    const val = scores[cat.key];
    return `<div class="dash-bar-group">
      <div class="dash-bar-track clickable" onclick="highlightForDashboard('${cat.key}')"><div class="dash-bar-fill" style="width:${val}%;background:${getMetricColor(val)}">
        <span class="dash-bar-value">${val}</span>
      </div></div>
      <div class="dash-bar-label">${icon(cat.icon, 'var(--text-secondary)')} ${cat.name}</div>
    </div>`;
  }).join('');

  // Overlay grid (always update so it's ready when toggled)
  const overlayGrid = document.getElementById('dashOverlayGrid');
  overlayGrid.innerHTML = dashboardCategories.map(cat => {
    const val = scores[cat.key];
    const factors = breakdown[cat.key] || [];
    const info = DASHBOARD_INFO[cat.key];
    const catFullName = info ? info.name : cat.name;
    return `<div class="dash-card">
      <div class="dash-card-header">
        ${icon(cat.icon, getMetricColor(val))} ${catFullName}
        <span class="dash-card-score" style="color:${getMetricColor(val)}">${val}</span>
      </div>
      <div class="dash-card-bar"><div class="dash-card-fill" style="width:${val}%;background:${getMetricColor(val)}"></div></div>
      ${info ? `<div class="dash-card-desc">${info.desc}</div>` : ''}
      <div class="dash-card-factors">
        ${factors.map(f => {
          const mi = METRIC_ICON_MAP[f.metric] ? icon(METRIC_ICON_MAP[f.metric], getMetricColor(f.value)) : '';
          return `<div class="dash-card-factor">
            <span class="dash-card-factor-tip">${f.comp} — ${f.metric}: ${f.value}</span>
            <span class="dash-card-factor-comp">${f.comp}</span>
            <span class="dash-card-factor-icon">${mi}</span>
            <span class="dash-card-factor-bar"><span class="dash-card-factor-fill" style="width:${f.value}%;background:${getMetricColor(f.value)}"></span></span>
            <span class="dash-card-factor-val" style="color:${getMetricColor(f.value)}">${f.value}</span>
          </div>`;
        }).join('')}
      </div>
    </div>`;
  }).join('');

  // Sync overlay visibility
  document.getElementById('dashOverlay').classList.toggle('visible', state.dashboardExpanded);
  document.getElementById('dashboard').classList.toggle('expanded', state.dashboardExpanded);
}

function toggleDashboardExpand() {
  state.dashboardExpanded = !state.dashboardExpanded;
  document.getElementById('dashOverlay').classList.toggle('visible', state.dashboardExpanded);
  document.getElementById('dashboard').classList.toggle('expanded', state.dashboardExpanded);
  if (state.dashboardExpanded) renderDashboard(); // refresh overlay content
}

function calculateDashboardScores() {
  // Build breakdown: for each category, collect { comp, metric, value } entries
  const breakdown = {};
  dashboardCategories.forEach(cat => { breakdown[cat.key] = []; });

  Object.entries(components).forEach(([id, c]) => {
    const v = c.variants[c.currentVariant];
    Object.entries(v.metrics).forEach(([metricName, value]) => {
      const catKey = METRIC_TO_CATEGORY[metricName];
      if (catKey && breakdown[catKey]) {
        breakdown[catKey].push({ comp: c.name, metric: metricName, value });
      }
    });
  });

  // Score per category = average of all contributing metric values
  const scores = {};
  dashboardCategories.forEach(cat => {
    const factors = breakdown[cat.key];
    if (factors.length > 0) {
      scores[cat.key] = Math.round(factors.reduce((sum, f) => sum + f.value, 0) / factors.length);
    } else {
      scores[cat.key] = 50; // default if no data
    }
  });

  return { scores, breakdown };
}

// ═══════════════ INTERACTIONS ═══════════════

function selectNode(id) {
  if (state.selectedNode !== id) state.lastDeltas = {}; // clear deltas when switching components
  state.inspSwapOpen = false;
  state.inspVariantOpen = false;
  state.selectedNode = id;
  state.selectedConnection = null; // deselect connection when selecting node
  renderNodes();
  renderConnections();
  renderInspector();
  updatePrompt();
}

// ═══════════════ DRAG & DROP ═══════════════

function startDrag(e, nodeId) {
  // Ignore if clicking on interactive children (icon swap, variant btn, dropdowns, select)
  if (e.target.closest('.node-variant-btn') || e.target.closest('.node-dropdown') || e.target.closest('.swap-dropdown') || e.target.closest('.node-icon.clickable') || e.target.closest('select')) return;
  e.preventDefault();
  const c = components[nodeId];
  state.dragging = nodeId;
  state.dragMoved = false;
  state.dragStart = { mx: e.clientX, my: e.clientY, nx: c.position.x, ny: c.position.y };
}

function onDrag(e) {
  if (!state.dragging) return;
  const dx = e.clientX - state.dragStart.mx;
  const dy = e.clientY - state.dragStart.my;
  // Only count as drag if moved more than 4px (to allow click)
  if (Math.abs(dx) > 4 || Math.abs(dy) > 4) state.dragMoved = true;
  if (!state.dragMoved) return;
  const c = components[state.dragging];
  c.position.x = state.dragStart.nx + dx;
  c.position.y = state.dragStart.ny + dy;
  // Move the DOM element directly for performance (no full re-render)
  const nodeEl = document.getElementById(`node-${state.dragging}`);
  if (nodeEl) {
    nodeEl.style.left = c.position.x + 'px';
    nodeEl.style.top = c.position.y + 'px';
    nodeEl.classList.add('dragging');
  }
  // Update connection lines
  renderConnections();
}

function endDrag(e) {
  if (!state.dragging) return;
  const nodeId = state.dragging;
  const nodeEl = document.getElementById(`node-${nodeId}`);
  if (nodeEl) nodeEl.classList.remove('dragging');
  state.dragging = null;
  if (!state.dragMoved) {
    // It was a click, not a drag — select the node
    selectNode(nodeId);
  }
  state.dragStart = null;
  state.dragMoved = false;
}

// ═══════════════ CONNECTION LABEL DRAG ═══════════════

function startConnDrag(e, sourceId, targetId, connIdx) {
  e.preventDefault();
  const conn = components[sourceId].connections[connIdx];
  if (!conn.offset) conn.offset = { x: 0, y: 0 };
  state.draggingConn = { sourceId, targetId, connIdx };
  state.connDragStart = { mx: e.clientX, my: e.clientY, ox: conn.offset.x, oy: conn.offset.y };
  state.dragMoved = false;
}

function onConnDrag(e) {
  if (!state.draggingConn) return;
  const dx = e.clientX - state.connDragStart.mx;
  const dy = e.clientY - state.connDragStart.my;
  if (Math.abs(dx) > 3 || Math.abs(dy) > 3) state.dragMoved = true;
  if (!state.dragMoved) return;
  const { sourceId, connIdx } = state.draggingConn;
  const conn = components[sourceId].connections[connIdx];
  conn.offset.x = state.connDragStart.ox + dx;
  conn.offset.y = state.connDragStart.oy + dy;
  renderConnections();
}

function endConnDrag(e) {
  if (!state.draggingConn) return;
  const wasDrag = state.dragMoved;
  const { sourceId, targetId } = state.draggingConn;
  state.draggingConn = null;
  state.connDragStart = null;
  if (!wasDrag) {
    // It was a click, not a drag — select the connection
    selectConnection(sourceId, targetId);
  }
  state.dragMoved = false;
}

// Combined mouse handlers for both node and connection dragging
document.addEventListener('mousemove', function(e) { onDrag(e); onConnDrag(e); });
document.addEventListener('mouseup', function(e) { endDrag(e); endConnDrag(e); });

function changeVariant(nodeId, variantKey) {
  const c = components[nodeId];
  // Store previous metrics for delta display
  const prevMetrics = { ...c.variants[c.currentVariant].metrics };
  c.currentVariant = variantKey;

  // Calculate deltas for display
  const newMetrics = c.variants[variantKey].metrics;
  state.lastDeltas = {};
  Object.entries(newMetrics).forEach(([key, val]) => {
    if (prevMetrics[key] !== undefined) state.lastDeltas[key] = val - prevMetrics[key];
  });
  // Deltas persist until the next variant change (cleared at top of this function)

  // Update heatmap status based on new metrics
  const v = c.variants[variantKey];
  const avg = Object.values(v.metrics).reduce((a,b) => a+b, 0) / Object.values(v.metrics).length;
  c.heatStatus = avg >= 70 ? 'green' : avg >= 50 ? 'yellow' : 'red';

  // Immediate update on source
  renderInspector();
  renderNodes();
  renderConnections();

  // Sequential ripple through connections
  triggerRipple(nodeId);

  // Dashboard updates after ripple
  setTimeout(() => renderDashboard(), 300 + c.connections.length * 150);
  restartFlowIfActive();
  renderIssuesButton();
  updatePrompt();
}

function triggerRipple(sourceId) {
  const c = components[sourceId];
  const sourceNode = document.getElementById(`node-${sourceId}`);
  if (sourceNode) { sourceNode.classList.add('rippling'); setTimeout(() => sourceNode.classList.remove('rippling'), 400); }

  c.connections.forEach((conn, i) => {
    const targetId = conn.target;
    setTimeout(() => {
      // Flash the connection line
      const line = document.getElementById(`conn-${sourceId}-${targetId}`);
      if (line) { line.classList.add('ripple'); setTimeout(() => line.classList.remove('ripple'), 300); }

      // Ripple the target node
      const targetNode = document.getElementById(`node-${targetId}`);
      if (targetNode) {
        targetNode.classList.add('rippling');
        setTimeout(() => targetNode.classList.remove('rippling'), 400);
      }

      renderNodes();
      renderConnections();
      if (i === c.connections.length - 1) restartFlowIfActive();
    }, (i + 1) * 150);
  });
}

function toggleHeatmap() {
  state.heatmapEnabled = !state.heatmapEnabled;
  document.getElementById('heatmapToggle').classList.toggle('active', state.heatmapEnabled);
  renderNodes();
  renderConnections();
  renderLegend();
  if (state.heatmapEnabled) {
    startFlowAnimation();
  } else {
    stopFlowAnimation();
  }
  updatePrompt();
}

function togglePanel(panelId) {
  document.getElementById(panelId).classList.toggle('collapsed');
}

function switchTab(tabEl, tabName) {
  document.querySelectorAll('.toolbox-tab').forEach(t => t.classList.remove('active'));
  tabEl.classList.add('active');
  state.toolboxTab = tabName;
  renderToolbox();
}

// ═══════════════ CONNECTION SELECTION ═══════════════

function selectConnection(sourceId, targetId) {
  // Toggle selection
  if (state.selectedConnection &&
      state.selectedConnection.sourceId === sourceId &&
      state.selectedConnection.targetId === targetId) {
    state.selectedConnection = null;
  } else {
    state.selectedConnection = { sourceId, targetId };
    state.selectedNode = null; // deselect node when selecting connection
  }
  renderNodes();
  renderConnections();
  renderInspector();
  updatePrompt();
}

function getConnectionData(sourceId, targetId) {
  const c = components[sourceId];
  if (!c) return null;
  return c.connections.find(conn => conn.target === targetId) || null;
}

// ═══════════════ COMPONENT SWAP ═══════════════

function toggleSwapDropdown(nodeId) {
  state.variantOpenNode = null;
  state.swapOpenNode = state.swapOpenNode === nodeId ? null : nodeId;
  renderNodes();
  renderConnections();
}

function toggleVariantDropdown(nodeId) {
  state.swapOpenNode = null;
  state.variantOpenNode = state.variantOpenNode === nodeId ? null : nodeId;
  renderNodes();
  renderConnections();
}

function changeVariantFromNode(nodeId, variantKey) {
  state.variantOpenNode = null;
  changeVariant(nodeId, variantKey);
}

function swapComponent(currentId, newId) {
  if (currentId === newId) {
    state.swapOpenNode = null;
    renderNodes();
    renderConnections();
    return;
  }
  // In a real app this would replace the component entirely.
  // For this playground, show feedback that it would swap.
  const alt = (ALTERNATIVES[currentId] || []).find(a => a.id === newId);
  const node = document.getElementById(`node-${currentId}`);
  if (node) {
    node.style.transition = 'transform 0.2s, opacity 0.2s';
    node.style.transform = 'scale(0.9)';
    node.style.opacity = '0.5';
    setTimeout(() => {
      node.style.transform = 'scale(1)';
      node.style.opacity = '1';
    }, 200);
  }
  state.swapOpenNode = null;
  // Update the prompt to reflect the swap intention
  if (alt) {
    const c = components[currentId];
    c._swapTarget = alt;
  }
  renderNodes();
  renderConnections();
  renderInspector();
  updatePrompt();
}

// Close swap/variant dropdown on click outside
document.addEventListener('click', function(e) {
  if (state.swapOpenNode && !e.target.closest('.node-icon.clickable') && !e.target.closest('.node-dropdown') && !e.target.closest('.swap-dropdown')) {
    state.swapOpenNode = null;
    renderNodes();
    renderConnections();
  }
  if (state.variantOpenNode && !e.target.closest('.node-variant-btn') && !e.target.closest('.node-dropdown')) {
    state.variantOpenNode = null;
    renderNodes();
    renderConnections();
  }
  if (state.issuesOpen && !e.target.closest('#issuesBtn') && !e.target.closest('#issuesDropdown')) {
    state.issuesOpen = false;
    document.getElementById('issuesDropdown').classList.remove('visible');
  }
  if (state.metricFilterOpen && !e.target.closest('.metric-filter-wrap') && !e.target.closest('.metric-filter-menu')) {
    state.metricFilterOpen = false;
    const menu = document.querySelector('.metric-filter-menu');
    if (menu) menu.classList.remove('visible');
  }
  if (state.inspSwapOpen && !e.target.closest('.insp-swap-btn') && !e.target.closest('.insp-header-dropdown.swap')) {
    state.inspSwapOpen = false;
    renderInspector();
  }
  if (state.inspVariantOpen && !e.target.closest('.insp-variant-btn') && !e.target.closest('.insp-header-dropdown.variant')) {
    state.inspVariantOpen = false;
    renderInspector();
  }
});

// ═══════════════ PROMPT OUTPUT ═══════════════

function updatePrompt() {
  const el = document.getElementById('promptText');
  const parts = [];
  parts.push('Build the Archie architecture simulator interface with these specifications:');
  parts.push('');
  parts.push('LAYOUT: VS Code three-zone pattern — Toolbox sidebar (left, 270px), Canvas (center, dark bg #0f1117), Inspector panel (right, 310px). Dashboard bar at bottom (110px). Top bar with logo, architecture name, tier badge, and icon+label action buttons.');
  parts.push('');
  parts.push('THEME: Dark mode primary. Panel bg: #1a1d27, Surface: #242736, Border: #2e3348, Text: #e2e4eb / #8b8fa3, Accent: #6366f1 (indigo). Font: Inter, 13px base. 4px spacing unit.');
  parts.push('');
  parts.push('ICONOGRAPHY: Every category, action, metric, and label has an SVG icon. Icons are the primary visual communication — users identify component types by icon before text. 10 category icons: CPU (compute), Database cylinder (data storage), Lightning bolt (caching), Chat bubble (messaging), Globe (delivery/network), Signal waves (real-time), Shield (auth), Chart (monitoring), Magnifying glass (search), Gear (devops). Icons appear in nodes, toolbox cards, inspector, dashboard labels, tabs, and buttons.');
  parts.push('');
  parts.push('NODE SHAPES: Each component category has a distinct node shape: Compute = sharp rectangle (4px radius), Data Storage = bottom-rounded cylinder shape (4px top, 14px bottom radius), Caching = pill (16px radius), Messaging = alternating corners (12px/4px), Delivery = stadium (20px radius). Nodes show: category color top stripe, category icon + name, variant label, mini metric bars.');
  parts.push('');
  parts.push('COLOR SYSTEM: Two separate color layers — category colors (10 distinct hues) identify component TYPE via accent stripes and icon fills. Heatmap colors (green/yellow/red) show HEALTH status on borders and connection lines when heatmap is enabled. These never overlap — category = identity, heatmap = performance.');
  parts.push('');

  if (state.heatmapEnabled) {
    parts.push('HEATMAP: Enabled — node borders glow with health colors (green/yellow/red). Connection LINES also colored by health (worst of two endpoints). Dashed lines for warning/bottleneck connections. Legend visible in top-right corner of canvas.');
    parts.push('');
  }

  if (state.selectedNode) {
    const c = components[state.selectedNode];
    const v = c.variants[c.currentVariant];
    parts.push(`CURRENT SELECTION: ${c.name} (${c.category}) with "${v.label}" config variant.`);
    parts.push(`Metrics: ${Object.entries(v.metrics).map(([k,val]) => `${k}: ${val}/100`).join(', ')}`);
    parts.push('');
  }

  parts.push('CORE INTERACTION: Config variant dropdown in inspector. On change → metric bars animate (0.5s cubic-bezier), sequential ripple propagates through connections (~150ms per hop), heatmap colors shift on nodes AND lines, dashboard updates after ripple completes.');
  parts.push('');
  parts.push('TOOLBOX: Three tabs with icons (grid=Components | stack=Stacks | blueprint=Blueprints). Component cards in IS/GAIN/COST format with category icon + color left border. Section labels have micro-icons (circle=IS, up-arrow=GAIN, down-arrow=COST).');
  parts.push('');
  parts.push('DASHBOARD: 7 horizontal bars with category icons (rocket=Perf, dollar=Cost, shield=Reliab, gear=Ops, mountain=Scale, flag=Strat, code=Dev). Color-coded: green >70, yellow 40-70, red <40.');
  parts.push('');
  parts.push('DATA CONTEXT: Each component has user-defined data items (e.g., Redis: "User Sessions", "Rate Limits", "Message Cache"). When switching config variants, a "Your Data Context" section in the inspector shows how each data item behaves under that variant with fit indicators (great/good/trade-off/poor/risky) and specific notes. This makes abstract metrics concrete: "Your sessions are read-heavy → Cache-Aside is a great fit" vs "Your rate limit counters are write-heavy → Cache-Aside is a poor fit." Users can edit their data items to personalize the trade-off analysis.');
  parts.push('');
  parts.push('COMPONENT SWAP: Each node shows a swap button (arrows icon) on hover in the top-right corner. Clicking opens a dropdown with alternative components in the same category (e.g., Redis → Memcached, KeyDB, Dragonfly). The inspector also shows a "Swap to" dropdown below the component name. This enables quick comparison of alternative tools without rebuilding the architecture.');
  parts.push('');
  parts.push('IMPLEMENTATION PATTERNS: Below the config variant dropdown in the inspector, a code snippet panel shows the actual implementation pattern for the current variant. Syntax-highlighted (keywords purple, functions blue, strings green, comments gray). This makes the difference between variants tangible — users see HOW the code changes, not just abstract metric scores.');
  parts.push('');
  parts.push('CONNECTIONS AS FIRST-CLASS OBJECTS: Connections between components are not just lines — they have properties. Each connection specifies: protocol (HTTP, RESP, Kafka TCP, Database Wire, etc.), communication pattern (request-response, pub-sub, poll-consume, fire-and-forget), typical latency, whether components can be co-located on the same machine, and implementation code showing HOW the connection works. Click any connection label on the canvas to inspect its properties. Connections show directional arrows. The Twitter Timeline architecture has multiple data flows: API→TweetStore writes, API→Timeline Cache reads, MessageQueue→FanoutService event streaming.');

  if (state.selectedConnection) {
    const conn = getConnectionData(state.selectedConnection.sourceId, state.selectedConnection.targetId);
    if (conn) {
      const src = components[state.selectedConnection.sourceId];
      const tgt = components[state.selectedConnection.targetId];
      parts.push('');
      parts.push(`SELECTED CONNECTION: ${src.name} → ${tgt.name} via ${conn.protocol}. Pattern: ${conn.pattern}. Latency: ${conn.latency}. Co-locatable: ${conn.colocatable ? 'Yes' : 'No'}.`);
    }
  }

  el.textContent = parts.join('\n');
}

function copyPrompt() {
  const text = document.getElementById('promptText').textContent;
  navigator.clipboard.writeText(text).then(() => {
    const btn = document.querySelector('.prompt-copy-btn');
    const original = btn.innerHTML;
    btn.innerHTML = '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 6l3 3 5-5"/></svg> Copied!';
    setTimeout(() => btn.innerHTML = original, 1500);
  });
}

// ═══════════════ INFO POPUPS ═══════════════

function showInfoPopup(headerHTML, bodyHTML) {
  const overlay = document.getElementById('infoPopupOverlay');
  document.getElementById('infoPopupHeader').innerHTML = headerHTML + `<button class="info-popup-close" onclick="hideInfoPopup()">${icon('close', 'var(--text-secondary)')}</button>`;
  document.getElementById('infoPopupBody').innerHTML = bodyHTML;
  overlay.classList.add('visible');
}

function hideInfoPopup() {
  document.getElementById('infoPopupOverlay').classList.remove('visible');
}

function showCategoryInfo(categoryName) {
  const info = CATEGORY_INFO[categoryName];
  if (!info) return;
  const cat = CATEGORIES[categoryName];
  const headerHTML = `${icon(categoryName, cat.color)} <span style="color:${cat.color}">${categoryName}</span>`;
  const bodyHTML = `
    <p><strong>${info.desc}</strong></p>
    <div class="info-popup-section">
      <div class="info-popup-section-title">Role in Architecture</div>
      <p>${info.role}</p>
    </div>
    <div class="info-popup-section">
      <div class="info-popup-section-title">Common Examples</div>
      <p>${info.examples}</p>
    </div>
    <div class="info-popup-section">
      <div class="info-popup-section-title">How to Choose</div>
      <p>${info.key}</p>
    </div>
  `;
  showInfoPopup(headerHTML, bodyHTML);
}

function showDashboardInfo(categoryKey) {
  const info = DASHBOARD_INFO[categoryKey];
  if (!info) return;
  const dashCat = dashboardCategories.find(c => c.key === categoryKey);
  const headerHTML = `${dashCat ? icon(dashCat.icon, 'var(--accent)') : ''} <span style="color:var(--accent)">${info.name}</span>`;
  const bodyHTML = `
    <p><strong>${info.desc}</strong></p>
    <div class="info-popup-section">
      <div class="info-popup-section-title">Key Metrics</div>
      <p>${info.metrics}</p>
    </div>
    <div class="info-popup-section">
      <div class="info-popup-section-title">Why It Matters</div>
      <p>${info.impact}</p>
    </div>
    <div class="info-popup-section">
      <div class="info-popup-section-title">How to Improve</div>
      <p>${info.improve}</p>
    </div>
  `;
  showInfoPopup(headerHTML, bodyHTML);
}

// Close popup on Escape key
document.addEventListener('keydown', function(e) {
  if (e.key === 'Escape') {
    hideInfoPopup();
    if (state.issuesOpen) { state.issuesOpen = false; document.getElementById('issuesDropdown').classList.remove('visible'); }
    if (state.swapOpenNode || state.variantOpenNode) { state.swapOpenNode = null; state.variantOpenNode = null; renderNodes(); renderConnections(); }
  }
});

// ═══════════════ ISSUES SUMMARY ═══════════════

function getIssues() {
  const issues = [];
  Object.entries(components).forEach(([id, c]) => {
    if (c.heatStatus !== 'green') {
      const v = c.variants[c.currentVariant];
      const avg = Math.round(Object.values(v.metrics).reduce((a,b) => a+b, 0) / Object.values(v.metrics).length);
      const worst = Object.entries(v.metrics).sort((a,b) => a[1] - b[1])[0];
      issues.push({ id, name: c.name, category: c.category, status: c.heatStatus, avg, worstMetric: worst[0], worstValue: worst[1] });
    }
  });
  const priority = { 'red': 0, 'yellow': 1 };
  issues.sort((a, b) => (priority[a.status] ?? 2) - (priority[b.status] ?? 2) || a.avg - b.avg);
  return issues;
}

function renderIssuesButton() {
  const issues = getIssues();
  const badge = document.getElementById('issuesBadge');
  if (issues.length === 0) {
    badge.classList.add('hidden');
  } else {
    badge.classList.remove('hidden');
    badge.textContent = issues.length;
    badge.className = 'issues-badge' + (issues.some(i => i.status === 'red') ? '' : ' warning');
  }
}

function toggleIssues() {
  state.issuesOpen = !state.issuesOpen;
  const dropdown = document.getElementById('issuesDropdown');
  const btn = document.getElementById('issuesBtn');
  if (state.issuesOpen) {
    const rect = btn.getBoundingClientRect();
    dropdown.style.top = (rect.bottom + 4) + 'px';
    dropdown.style.left = Math.max(8, rect.left - 80) + 'px';
    const issues = getIssues();
    if (issues.length === 0) {
      dropdown.innerHTML = `<div class="issues-dropdown-title">${icon('gain', 'var(--green)')} Architecture Health</div>
        <div class="issues-none">All components healthy — no issues detected</div>`;
    } else {
      dropdown.innerHTML = `<div class="issues-dropdown-title">${icon('cons', 'var(--red)')} ${issues.length} Issue${issues.length > 1 ? 's' : ''} Detected</div>
        ${issues.map(i => {
          const cat = CATEGORIES[i.category];
          const h = HEALTH_LABELS[i.status];
          return `<div class="issues-item" onclick="selectNode('${i.id}'); toggleIssues();">
            <span class="issues-item-dot" style="background:${h.color}"></span>
            ${icon(i.category, cat.color)}
            <span class="issues-item-name">${i.name}</span>
            <span class="issues-item-detail">${h.label} · worst: ${i.worstMetric} ${i.worstValue}</span>
          </div>`;
        }).join('')}`;
    }
    dropdown.classList.add('visible');
  } else {
    dropdown.classList.remove('visible');
  }
}

// ═══════════════ VARIANT RECOMMENDATION ═══════════════

function getVariantRecommendation(nodeId) {
  const c = components[nodeId];
  const currentMetrics = c.variants[c.currentVariant].metrics;
  const worst = Object.entries(currentMetrics).sort((a,b) => a[1] - b[1])[0];
  if (worst[1] >= 70) return null;
  let bestAlt = null;
  let bestImprovement = 0;
  Object.entries(c.variants).forEach(([vk, vv]) => {
    if (vk === c.currentVariant) return;
    const altValue = vv.metrics[worst[0]];
    if (altValue !== undefined && altValue > worst[1]) {
      const improvement = altValue - worst[1];
      if (improvement > bestImprovement) {
        bestImprovement = improvement;
        bestAlt = { key: vk, label: vv.label, metric: worst[0], from: worst[1], to: altValue, improvement };
      }
    }
  });
  if (!bestAlt) return null;
  const altMetrics = c.variants[bestAlt.key].metrics;
  let worstRegression = null;
  Object.entries(currentMetrics).forEach(([k, v]) => {
    if (k === worst[0]) return;
    const altV = altMetrics[k];
    if (altV !== undefined && altV < v) {
      const loss = v - altV;
      if (!worstRegression || loss > worstRegression.loss) worstRegression = { metric: k, loss };
    }
  });
  bestAlt.tradeoff = worstRegression;
  return bestAlt;
}

// ═══════════════ TIER INFO ═══════════════

function showTierInfo() {
  const headerHTML = `${icon('strat', 'var(--accent)')} <span style="color:var(--accent)">Architecture Tier System</span>`;
  const issues = getIssues();
  const redCount = issues.filter(i => i.status === 'red').length;
  const yellowCount = issues.filter(i => i.status === 'yellow').length;
  const bodyHTML = `
    <p><strong>Tiers measure how complete and production-ready your architecture is.</strong></p>
    <div class="info-popup-section">
      <div class="info-popup-section-title">Current: Tier 2 / 3</div>
      <p>Your architecture has core components with defined connections and configuration variants. Metrics are tracked and trade-offs are visible.</p>
    </div>
    <div class="info-popup-section">
      <div class="info-popup-section-title">Tier Criteria</div>
      <ul class="info-popup-list">
        <li><strong style="color:var(--green)">Tier 1:</strong> Components placed with basic connections defined</li>
        <li><strong style="color:var(--accent)">Tier 2 (current):</strong> Config variants selected, metrics profiled, trade-offs mapped</li>
        <li><strong style="color:var(--yellow)">Tier 3:</strong> All bottlenecks addressed, heatmap mostly green, data context personalized</li>
      </ul>
    </div>
    <div class="info-popup-section">
      <div class="info-popup-section-title">Gap to Tier 3</div>
      <ul class="info-popup-list">
        ${redCount > 0 ? `<li style="color:var(--red)">Resolve ${redCount} bottleneck${redCount > 1 ? 's' : ''} (red components)</li>` : `<li style="color:var(--green)">No bottlenecks — great!</li>`}
        ${yellowCount > 0 ? `<li style="color:var(--yellow)">Address ${yellowCount} warning${yellowCount > 1 ? 's' : ''} (yellow components)</li>` : `<li style="color:var(--green)">No warnings — great!</li>`}
        <li>Customize data context items for your specific use case</li>
        <li>Verify connection health across all paths</li>
      </ul>
    </div>
  `;
  showInfoPopup(headerHTML, bodyHTML);
}

// ═══════════════ DASHBOARD LINKING ═══════════════

function highlightForDashboard(catKey) {
  const issues = getIssues();
  if (issues.length > 0) {
    issues.forEach(issue => {
      const nodeEl = document.getElementById('node-' + issue.id);
      if (nodeEl) {
        nodeEl.classList.add('flash-highlight');
        setTimeout(() => nodeEl.classList.remove('flash-highlight'), 800);
      }
    });
  }
  showDashboardInfo(catKey);
}

// ═══════════════ FLOW PARTICLE ANIMATION ═══════════════
const FLOW_SPEEDS = { green: 0.014, yellow: 0.006, red: 0.0025 };
const FLOW_COLORS = { green: '#22c55e', yellow: '#eab308', red: '#ef4444' };

function startFlowAnimation() {
  stopFlowAnimation();
  if (connectionPathData.length === 0) return;
  state.flowParticles = [];
  connectionPathData.forEach((path, pi) => {
    const count = path.health === 'green' ? 3 : 2;
    for (let i = 0; i < count; i++) {
      state.flowParticles.push({
        pathIdx: pi,
        t: i / count + Math.random() * 0.1,
        speed: FLOW_SPEEDS[path.health] * (0.9 + Math.random() * 0.2)
      });
    }
  });
  const svg = document.getElementById('flowSvg');
  svg.innerHTML = '<defs><filter id="flowGlow"><feGaussianBlur stdDeviation="2" result="blur"/>' +
    '<feMerge><feMergeNode in="blur"/><feMergeNode in="SourceGraphic"/></feMerge></filter></defs>' +
    state.flowParticles.map((p, i) => {
      const color = FLOW_COLORS[connectionPathData[p.pathIdx].health];
      return `<circle id="fp${i}" cx="0" cy="0" r="3" fill="${color}" opacity="0.9" filter="url(#flowGlow)"/>`;
    }).join('');
  function tick() {
    if (!state.heatmapEnabled) return;
    for (let i = 0; i < state.flowParticles.length; i++) {
      const p = state.flowParticles[i];
      p.t += p.speed;
      if (p.t > 1) p.t -= 1;
      const pd = connectionPathData[p.pathIdx];
      if (!pd) continue;
      const mt = 1 - p.t;
      const x = mt * mt * pd.sx + 2 * mt * p.t * pd.cpx + p.t * p.t * pd.tx;
      const y = mt * mt * pd.sy + 2 * mt * p.t * pd.cpy + p.t * p.t * pd.ty;
      const el = document.getElementById(`fp${i}`);
      if (el) {
        el.setAttribute('cx', x);
        el.setAttribute('cy', y);
        el.setAttribute('r', 2.5 + Math.sin(p.t * Math.PI * 4) * 0.8);
      }
    }
    state.flowAnimationId = requestAnimationFrame(tick);
  }
  state.flowAnimationId = requestAnimationFrame(tick);
}

function stopFlowAnimation() {
  if (state.flowAnimationId) cancelAnimationFrame(state.flowAnimationId);
  state.flowAnimationId = null;
  state.flowParticles = [];
  const svg = document.getElementById('flowSvg');
  if (svg) svg.innerHTML = '';
}

function restartFlowIfActive() {
  if (state.heatmapEnabled) startFlowAnimation();
}

// ═══════════════ INIT ═══════════════
function init() {
  renderLegend();
  renderToolbox();
  renderNodes();
  renderConnections();
  renderDashboard();
  renderIssuesButton();
  updatePrompt();
}

init();
</script>
</body>
</html>
