<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Archie UX Design Explorer</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
<style>
/* ═══════════════ RESET & BASE ═══════════════ */
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
:root {
  --canvas-bg: #0f1117;
  --panel-bg: #1a1d27;
  --surface: #242736;
  --border: #2e3348;
  --text-primary: #e2e4eb;
  --text-secondary: #8b8fa3;
  --accent: #6366f1;
  --accent-hover: #818cf8;
  --green: #22c55e;
  --yellow: #eab308;
  --red: #ef4444;
  --cat-compute: #3b82f6;
  --cat-data: #22c55e;
  --cat-cache: #f97316;
  --cat-messaging: #a855f7;
  --cat-delivery: #06b6d4;
  --cat-realtime: #ec4899;
  --cat-auth: #ef4444;
  --cat-monitoring: #eab308;
  --cat-search: #14b8a6;
  --cat-devops: #8b5cf6;
  --radius: 6px;
  --space: 4px;
  --toolbox-w: 270px;
  --inspector-w: 310px;
  --topbar-h: 44px;
}
html, body { height: 100%; overflow: hidden; }
body {
  font-family: 'Inter', system-ui, -apple-system, sans-serif;
  background: var(--canvas-bg);
  color: var(--text-primary);
  font-size: 13px;
  line-height: 1.4;
}

/* ═══════════════ TOP BAR ═══════════════ */
.top-bar {
  height: var(--topbar-h);
  background: var(--panel-bg);
  border-bottom: 1px solid var(--border);
  display: flex;
  align-items: center;
  padding: 0 12px;
  gap: 12px;
  z-index: 100;
}
.logo {
  font-weight: 700;
  font-size: 15px;
  color: var(--accent);
  letter-spacing: -0.5px;
  display: flex;
  align-items: center;
  gap: 6px;
}
.logo svg { width: 18px; height: 18px; }
.arch-name {
  font-weight: 500;
  color: var(--text-secondary);
  flex: 1;
}
.tier-badge {
  background: var(--accent);
  color: white;
  font-size: 11px;
  font-weight: 600;
  padding: 3px 10px;
  border-radius: 12px;
  cursor: default;
  display: flex;
  align-items: center;
  gap: 4px;
}
.tier-badge svg { width: 12px; height: 12px; }
.tier-badge .tier-hint {
  font-weight: 400;
  opacity: 0.7;
  font-size: 10px;
}
.top-actions { display: flex; gap: 6px; }
.top-btn {
  background: var(--surface);
  border: 1px solid var(--border);
  color: var(--text-secondary);
  padding: 5px 10px;
  border-radius: var(--radius);
  font-size: 11px;
  font-family: inherit;
  cursor: pointer;
  transition: all 0.15s;
  display: flex;
  align-items: center;
  gap: 4px;
}
.top-btn svg { width: 14px; height: 14px; }
.top-btn:hover { color: var(--text-primary); border-color: var(--text-secondary); }
.top-btn.active { background: var(--accent); color: white; border-color: var(--accent); }

/* ═══════════════ MAIN LAYOUT ═══════════════ */
.main-layout {
  display: flex;
  height: calc(100vh - var(--topbar-h));
}

/* ═══════════════ TOOLBOX ═══════════════ */
.toolbox {
  width: var(--toolbox-w);
  min-width: var(--toolbox-w);
  background: var(--panel-bg);
  border-right: 1px solid var(--border);
  display: flex;
  flex-direction: column;
  transition: width 0.2s, min-width 0.2s, opacity 0.2s;
  overflow: hidden;
}
.toolbox.collapsed { width: 0; min-width: 0; opacity: 0; pointer-events: none; }
.toolbox-title {
  padding: 10px 12px;
  border-bottom: 1px solid var(--border);
  font-weight: 600;
  font-size: 12px;
  color: var(--text-secondary);
  text-transform: uppercase;
  letter-spacing: 0.5px;
  display: flex;
  align-items: center;
  gap: 6px;
}
.toolbox-title svg { width: 14px; height: 14px; }
.toolbox-tabs {
  display: flex;
  border-bottom: 1px solid var(--border);
}
.toolbox-tab {
  flex: 1;
  padding: 8px 4px;
  text-align: center;
  font-size: 11px;
  font-weight: 500;
  color: var(--text-secondary);
  cursor: pointer;
  border-bottom: 2px solid transparent;
  transition: all 0.15s;
  background: none;
  border-top: none;
  border-left: none;
  border-right: none;
  font-family: inherit;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 4px;
}
.toolbox-tab svg { width: 14px; height: 14px; }
.toolbox-tab:hover { color: var(--text-primary); }
.toolbox-tab.active { color: var(--accent); border-bottom-color: var(--accent); }
.toolbox-content {
  flex: 1;
  overflow-y: auto;
  padding: 8px;
}
.toolbox-content::-webkit-scrollbar { width: 4px; }
.toolbox-content::-webkit-scrollbar-track { background: transparent; }
.toolbox-content::-webkit-scrollbar-thumb { background: var(--border); border-radius: 2px; }
.component-card {
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 10px;
  margin-bottom: 8px;
  cursor: grab;
  transition: all 0.15s;
  border-left: 3px solid var(--cat-color);
}
.component-card:hover {
  border-color: var(--text-secondary);
  transform: translateY(-1px);
}
.card-header {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 6px;
}
.card-icon {
  width: 20px;
  height: 20px;
  flex-shrink: 0;
  display: flex;
  align-items: center;
  justify-content: center;
}
.card-icon svg { width: 18px; height: 18px; }
.card-name { font-weight: 600; font-size: 12px; }
.card-category { font-size: 10px; color: var(--text-secondary); display: flex; align-items: center; gap: 3px; }
.card-category svg { width: 10px; height: 10px; }
.card-section {
  font-size: 10px;
  margin-top: 4px;
  line-height: 1.5;
}
.card-section-label {
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  font-size: 9px;
  margin-bottom: 1px;
  display: flex;
  align-items: center;
  gap: 3px;
}
.card-section-label svg { width: 10px; height: 10px; }
.card-is { color: var(--text-secondary); }
.card-gain { color: var(--green); }
.card-cost { color: var(--yellow); }
/* ═══════════════ CATALOG CATEGORY GROUPS ═══════════════ */
.cat-group {
  margin-bottom: 4px;
}
.cat-group-header {
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 6px 8px;
  cursor: pointer;
  border-radius: var(--radius);
  transition: background 0.1s;
  user-select: none;
}
.cat-group-header:hover { background: var(--surface); }
.cat-group-header svg { width: 14px; height: 14px; flex-shrink: 0; }
.cat-group-name {
  font-weight: 600;
  font-size: 11px;
  flex: 1;
}
.cat-group-count {
  font-size: 9px;
  color: var(--text-secondary);
  background: var(--surface);
  padding: 1px 6px;
  border-radius: 8px;
}
.cat-group-header .section-chevron svg { width: 10px; height: 10px; }
.cat-group-body {
  padding: 0 0 4px 8px;
}
.cat-group-body.collapsed { display: none; }
.cat-group-desc {
  font-size: 10px;
  color: var(--text-secondary);
  line-height: 1.4;
  padding: 2px 8px 6px 20px;
  font-style: italic;
}
.cat-item {
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 5px 8px;
  border-radius: 4px;
  font-size: 11px;
  cursor: grab;
  transition: background 0.1s;
  position: relative;
}
.cat-item:hover { background: var(--surface); }
.cat-item-dot {
  width: 6px;
  height: 6px;
  border-radius: 50%;
  flex-shrink: 0;
}
.cat-item-name { font-weight: 500; }
.cat-item-sub { font-size: 9px; color: var(--text-secondary); margin-left: auto; }
.cat-item-active {
  font-size: 8px;
  color: var(--accent);
  font-weight: 600;
  margin-left: 4px;
}
/* Catalog item tooltip */
.cat-item-tip {
  display: none;
  position: absolute;
  left: calc(100% + 8px);
  top: 50%;
  transform: translateY(-50%);
  background: var(--panel-bg);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 8px 10px;
  font-size: 10px;
  min-width: 180px;
  z-index: 30;
  box-shadow: 0 4px 16px rgba(0,0,0,0.5);
  pointer-events: none;
  white-space: normal;
  line-height: 1.4;
}
.cat-item:hover .cat-item-tip { display: block; }
.cat-item-tip-label {
  font-size: 9px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  color: var(--text-secondary);
  margin-top: 4px;
}
.cat-item-tip-label:first-child { margin-top: 0; }
.cat-item-tip-list {
  display: flex;
  flex-wrap: wrap;
  gap: 3px;
  margin-top: 2px;
}
.cat-item-tip-tag {
  font-size: 9px;
  padding: 1px 5px;
  border-radius: 3px;
  background: var(--surface);
  border: 1px solid var(--border);
}

/* ═══════════════ CANVAS ═══════════════ */
.canvas {
  flex: 1;
  position: relative;
  background: var(--canvas-bg);
  overflow: hidden;
}
.canvas-svg {
  position: absolute;
  top: 0; left: 0;
  width: 100%; height: 100%;
  pointer-events: none;
  z-index: 1;
}
.canvas-svg .conn-label-group { pointer-events: all; cursor: grab; }
.canvas-svg .conn-label-group:active { cursor: grabbing; }
.canvas-svg .conn-path {
  stroke: var(--border);
  stroke-width: 2;
  fill: none;
  transition: stroke 0.4s, stroke-width 0.3s;
}
.canvas-svg .conn-path.heat-green { stroke: var(--green); stroke-width: 2.5; }
.canvas-svg .conn-path.heat-yellow { stroke: var(--yellow); stroke-width: 2.5; stroke-dasharray: 8 4; }
.canvas-svg .conn-path.heat-red { stroke: var(--red); stroke-width: 3; stroke-dasharray: 6 3; }
.canvas-svg .conn-path.ripple { stroke: var(--accent); stroke-width: 3; }
.canvas-svg .conn-path.conn-selected { stroke: var(--accent); stroke-width: 2.5; }

/* Canvas Legend */
.canvas-legend {
  position: absolute;
  top: 12px;
  right: 12px;
  background: var(--panel-bg);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 8px 10px;
  font-size: 10px;
  z-index: 5;
  opacity: 0.9;
  transition: opacity 0.2s;
}
.canvas-legend:hover { opacity: 1; }
.legend-title {
  font-weight: 600;
  font-size: 9px;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  color: var(--text-secondary);
  margin-bottom: 6px;
  display: flex;
  align-items: center;
  gap: 4px;
}
.legend-title svg { width: 12px; height: 12px; }
.legend-item {
  display: flex;
  align-items: center;
  gap: 6px;
  margin-bottom: 3px;
  color: var(--text-secondary);
}
.legend-item svg { width: 12px; height: 12px; }
.legend-swatch {
  width: 12px;
  height: 3px;
  border-radius: 2px;
  flex-shrink: 0;
}
.legend-dot {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  border: 2px solid;
  flex-shrink: 0;
}
.legend-divider {
  height: 1px;
  background: var(--border);
  margin: 5px 0;
}

/* Canvas Nodes */
.node {
  position: absolute;
  width: 152px;
  background: var(--surface);
  border: 2px solid var(--border);
  padding: 0;
  cursor: pointer;
  z-index: 2;
  transition: all 0.2s;
  user-select: none;
}
/* Shape variations per category */
.node[data-shape="rectangle"] { border-radius: 4px; }
.node[data-shape="cylinder"] { border-radius: 4px 4px 14px 14px; }
.node[data-shape="pill"] { border-radius: 16px; }
.node[data-shape="hexish"] { border-radius: 12px 4px 12px 4px; }
.node[data-shape="stadium"] { border-radius: 20px; }

.node:hover { border-color: var(--text-secondary); z-index: 3; }
.node.selected { border-color: var(--accent); box-shadow: 0 0 0 2px rgba(99,102,241,0.3); z-index: 4; }
.node.dragging { opacity: 0.85; z-index: 10; cursor: grabbing; box-shadow: 0 8px 32px rgba(0,0,0,0.5); transition: none; }

.node-body {
  padding: 8px 10px 10px;
  position: relative;
}
/* Variant button on node (right side) */
.node-variant-btn {
  position: absolute;
  top: 4px;
  right: 4px;
  width: 20px;
  height: 20px;
  background: var(--panel-bg);
  border: 1px solid var(--border);
  border-radius: 4px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  opacity: 0;
  transition: opacity 0.15s, background 0.15s;
  z-index: 5;
}
.node-variant-btn svg { width: 12px; height: 12px; }
.node:hover .node-variant-btn { opacity: 0.7; }
.node-variant-btn:hover { opacity: 1 !important; background: var(--accent); border-color: var(--accent); }
/* Node dropdown overlays (shared) */
.node-dropdown {
  position: absolute;
  margin-top: 4px;
  background: var(--panel-bg);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 4px;
  min-width: 160px;
  z-index: 20;
  box-shadow: 0 8px 24px rgba(0,0,0,0.4);
}
.node-dropdown.left { top: 100%; left: 0; }
.node-dropdown.right { top: 100%; right: 0; }
/* Legacy alias */
.swap-dropdown { position: absolute; top: 100%; right: 0; margin-top: 4px; background: var(--panel-bg); border: 1px solid var(--border); border-radius: var(--radius); padding: 4px; min-width: 160px; z-index: 20; box-shadow: 0 8px 24px rgba(0,0,0,0.4); }
.swap-option {
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 5px 8px;
  border-radius: 3px;
  font-size: 11px;
  cursor: pointer;
  transition: background 0.1s;
  color: var(--text-primary);
}
.swap-option:hover { background: var(--surface); }
.swap-option.current { color: var(--accent); font-weight: 600; }
.swap-option svg { width: 12px; height: 12px; }
.swap-option-sub { font-size: 9px; color: var(--text-secondary); margin-left: auto; }
.node-header {
  display: flex;
  align-items: center;
  gap: 6px;
  margin-bottom: 4px;
}
.node-icon {
  width: 20px;
  height: 20px;
  flex-shrink: 0;
  display: flex;
  align-items: center;
  justify-content: center;
}
.node-icon svg { width: 18px; height: 18px; }
.node-name { font-weight: 600; font-size: 12px; line-height: 1.2; }
.node-variant { font-size: 10px; color: var(--text-secondary); margin-left: 26px; }
.node-mini-metrics {
  display: flex;
  gap: 3px;
  margin-top: 6px;
}
.node-mini-bar {
  flex: 1;
  height: 3px;
  background: var(--border);
  border-radius: 2px;
  overflow: hidden;
}
.node-mini-fill {
  height: 100%;
  border-radius: 2px;
  transition: width 0.4s ease, background-color 0.4s ease;
}

/* Heatmap borders */
.node.heatmap-green { border-color: var(--green); box-shadow: 0 0 10px rgba(34,197,94,0.3); }
.node.heatmap-yellow { border-color: var(--yellow); box-shadow: 0 0 10px rgba(234,179,8,0.3); }
.node.heatmap-red { border-color: var(--red); box-shadow: 0 0 10px rgba(239,68,68,0.3); }
.node.selected.heatmap-green { box-shadow: 0 0 0 2px rgba(34,197,94,0.3), 0 0 10px rgba(34,197,94,0.2); }
.node.selected.heatmap-yellow { box-shadow: 0 0 0 2px rgba(234,179,8,0.3), 0 0 10px rgba(234,179,8,0.2); }
.node.selected.heatmap-red { box-shadow: 0 0 0 2px rgba(239,68,68,0.3), 0 0 10px rgba(239,68,68,0.2); }

/* Tooltip */
.node-tooltip {
  display: none;
  position: absolute;
  bottom: calc(100% + 8px);
  left: 50%;
  transform: translateX(-50%);
  background: var(--panel-bg);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 8px 10px;
  font-size: 11px;
  white-space: nowrap;
  z-index: 10;
  pointer-events: none;
  box-shadow: 0 4px 12px rgba(0,0,0,0.4);
}
.node:hover .node-tooltip { display: block; }
.tooltip-header { display: flex; align-items: center; gap: 5px; margin-bottom: 3px; }
.tooltip-header svg { width: 14px; height: 14px; }
.tooltip-metrics { display: flex; gap: 10px; margin-top: 4px; }
.tooltip-metric { color: var(--text-secondary); }
.tooltip-metric span { color: var(--text-primary); font-weight: 500; }

/* Canvas empty state hint */
.canvas-hint {
  position: absolute;
  bottom: 72px;
  left: 50%;
  transform: translateX(-50%);
  color: var(--text-secondary);
  font-size: 11px;
  opacity: 0.5;
  pointer-events: none;
  display: flex;
  align-items: center;
  gap: 6px;
}
.canvas-hint svg { width: 14px; height: 14px; }

/* ═══════════════ INSPECTOR ═══════════════ */
.inspector {
  width: var(--inspector-w);
  min-width: var(--inspector-w);
  background: var(--panel-bg);
  border-left: 1px solid var(--border);
  display: flex;
  flex-direction: column;
  transition: width 0.2s, min-width 0.2s, opacity 0.2s;
  overflow: hidden;
}
.inspector.collapsed { width: 0; min-width: 0; opacity: 0; pointer-events: none; }
.inspector-header {
  padding: 10px 12px;
  border-bottom: 1px solid var(--border);
  font-weight: 600;
  font-size: 12px;
  color: var(--text-secondary);
  text-transform: uppercase;
  letter-spacing: 0.5px;
  display: flex;
  align-items: center;
  gap: 6px;
}
.inspector-header svg { width: 14px; height: 14px; }
.inspector-content {
  flex: 1;
  overflow-y: auto;
  padding: 12px;
}
.inspector-content::-webkit-scrollbar { width: 4px; }
.inspector-content::-webkit-scrollbar-track { background: transparent; }
.inspector-content::-webkit-scrollbar-thumb { background: var(--border); border-radius: 2px; }
.inspector-empty {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 100%;
  color: var(--text-secondary);
  font-size: 12px;
  text-align: center;
  padding: 20px;
  gap: 8px;
}
.inspector-empty svg { width: 32px; height: 32px; opacity: 0.3; }
.insp-header {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 4px;
}
.insp-header-btn {
  width: 28px;
  height: 28px;
  display: flex;
  align-items: center;
  justify-content: center;
  border: 1px solid var(--border);
  border-radius: var(--radius);
  background: var(--surface);
  cursor: pointer;
  transition: all 0.15s;
  flex-shrink: 0;
}
.insp-header-btn:hover { border-color: var(--text-secondary); }
.insp-header-btn.active { border-color: var(--accent); background: rgba(99, 102, 241, 0.1); }
.insp-header-btn svg { width: 16px; height: 16px; }
.insp-header-center {
  flex: 1;
  min-width: 0;
}
.insp-name { font-size: 16px; font-weight: 700; }
.insp-variant-label { font-size: 11px; color: var(--text-secondary); }
.insp-category { font-size: 11px; color: var(--text-secondary); margin-bottom: 12px; display: flex; align-items: center; gap: 6px; }
.insp-cat-dot { width: 8px; height: 8px; border-radius: 50%; }
/* Inspector header dropdowns */
.insp-header-dropdown {
  display: none;
  position: fixed;
  background: var(--panel-bg);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 6px 0;
  min-width: 240px;
  max-width: 280px;
  z-index: 1000;
  box-shadow: 0 4px 16px rgba(0,0,0,0.4);
  animation: metricExpand 0.15s ease-out;
}
.insp-header-dropdown.visible { display: block; }
.insp-dd-item {
  padding: 8px 12px;
  cursor: pointer;
  transition: background 0.1s;
  border-left: 3px solid transparent;
}
.insp-dd-item:hover { background: var(--surface); }
.insp-dd-item.current {
  border-left-color: var(--accent);
  background: rgba(99, 102, 241, 0.05);
}
.insp-dd-item-header {
  display: flex;
  align-items: center;
  gap: 6px;
  font-size: 12px;
  font-weight: 500;
}
.insp-dd-item-header svg { width: 14px; height: 14px; }
.insp-dd-item-sub {
  font-size: 10px;
  color: var(--text-secondary);
  font-weight: 400;
}
.insp-dd-item-current {
  font-size: 9px;
  color: var(--accent);
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.3px;
}
.insp-dd-metrics {
  display: flex;
  gap: 4px;
  margin-top: 5px;
  flex-wrap: wrap;
}
.insp-dd-metric {
  font-size: 9px;
  padding: 1px 5px;
  border-radius: 3px;
  background: var(--surface);
  border: 1px solid var(--border);
  display: inline-flex;
  align-items: center;
  gap: 2px;
}
.insp-dd-metric svg { width: 10px; height: 10px; flex-shrink: 0; }
.insp-dd-metric.positive { color: var(--green); border-color: rgba(34,197,94,0.3); }
.insp-dd-metric.negative { color: var(--red); border-color: rgba(239,68,68,0.3); }
.insp-dd-metric.neutral { color: var(--text-secondary); }
.insp-dd-rec {
  padding: 6px 12px;
  margin-top: 2px;
  border-top: 1px solid var(--border);
  font-size: 10px;
  color: var(--text-secondary);
  display: flex;
  align-items: center;
  gap: 4px;
}
.insp-dd-rec svg { width: 10px; height: 10px; }
.insp-section { margin-bottom: 14px; }
.insp-section-title {
  font-size: 10px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  color: var(--text-secondary);
  margin-bottom: 6px;
  display: flex;
  align-items: center;
  gap: 5px;
}
.insp-section-title svg { width: 12px; height: 12px; }
.insp-select {
  width: 100%;
  background: var(--surface);
  border: 1px solid var(--border);
  color: var(--text-primary);
  padding: 6px 8px;
  border-radius: var(--radius);
  font-family: inherit;
  font-size: 12px;
  cursor: pointer;
  outline: none;
}
.insp-select:focus { border-color: var(--accent); }

/* Metric bars in inspector */
.metric-row { margin-bottom: 0; }
.metric-label {
  display: flex;
  justify-content: space-between;
  font-size: 11px;
  margin-bottom: 3px;
}
.metric-name { color: var(--text-secondary); display: flex; align-items: center; gap: 4px; }
.metric-name svg { width: 11px; height: 11px; }
.metric-value { font-weight: 600; }
.metric-bar-track {
  height: 6px;
  background: var(--surface);
  border-radius: 3px;
  overflow: hidden;
  position: relative;
}
.metric-bar-fill {
  height: 100%;
  border-radius: 3px;
  transition: width 0.5s cubic-bezier(0.4, 0, 0.2, 1), background-color 0.5s;
}

/* Metric filter dropdown */
.metric-filter-wrap {
  position: relative;
  display: inline-block;
}
.metric-filter-btn {
  background: none;
  border: 1px solid transparent;
  color: var(--text-secondary);
  cursor: pointer;
  padding: 2px 5px;
  border-radius: var(--radius);
  display: flex;
  align-items: center;
  gap: 3px;
  font-size: 10px;
  font-family: inherit;
  transition: all 0.15s;
  margin-left: auto;
}
.metric-filter-btn:hover { color: var(--accent); border-color: var(--border); }
.metric-filter-btn.active { color: var(--accent); background: rgba(99, 102, 241, 0.1); border-color: var(--accent); }
.metric-filter-btn svg { width: 10px; height: 10px; }
.metric-filter-menu {
  display: none;
  position: fixed;
  background: var(--panel-bg);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 6px 0;
  min-width: 200px;
  z-index: 1000;
  box-shadow: 0 4px 16px rgba(0,0,0,0.4);
  animation: metricExpand 0.15s ease-out;
}
.metric-filter-menu.visible { display: block; }
.metric-filter-actions {
  display: flex;
  gap: 4px;
  padding: 0 8px 6px;
  border-bottom: 1px solid var(--border);
  margin-bottom: 4px;
}
.metric-filter-action {
  background: none;
  border: none;
  color: var(--accent);
  font-size: 10px;
  font-family: inherit;
  cursor: pointer;
  padding: 2px 6px;
  border-radius: 3px;
  transition: background 0.15s;
}
.metric-filter-action:hover { background: rgba(99, 102, 241, 0.15); }
.metric-filter-item {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 4px 10px;
  cursor: pointer;
  font-size: 11px;
  color: var(--text-secondary);
  transition: background 0.1s;
}
.metric-filter-item:hover { background: var(--surface); }
.metric-filter-check {
  width: 14px;
  height: 14px;
  border: 1.5px solid var(--border);
  border-radius: 3px;
  display: flex;
  align-items: center;
  justify-content: center;
  flex-shrink: 0;
  transition: all 0.15s;
}
.metric-filter-item.checked .metric-filter-check {
  background: var(--accent);
  border-color: var(--accent);
}
.metric-filter-check svg { width: 10px; height: 10px; }
.metric-filter-name { display: flex; align-items: center; gap: 4px; flex: 1; }
.metric-filter-name svg { width: 11px; height: 11px; }
.metric-filter-val {
  font-size: 10px;
  font-weight: 600;
  margin-left: auto;
}
.metric-section-title-row {
  display: flex;
  align-items: center;
  width: 100%;
}

/* Metric explanation dropdown */
.metric-row-wrap { margin-bottom: 8px; }
.metric-info-btn {
  background: none;
  border: none;
  color: var(--text-secondary);
  cursor: pointer;
  padding: 0;
  width: 14px;
  height: 14px;
  display: flex;
  align-items: center;
  justify-content: center;
  opacity: 0.5;
  transition: opacity 0.15s, color 0.15s;
  flex-shrink: 0;
}
.metric-info-btn:hover { opacity: 1; color: var(--accent); }
.metric-info-btn svg { width: 11px; height: 11px; }
.metric-explanation {
  display: none;
  margin-top: 6px;
  padding: 8px 10px;
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  font-size: 11px;
  line-height: 1.5;
  animation: metricExpand 0.2s ease-out;
}
.metric-explanation.visible { display: block; }
@keyframes metricExpand {
  from { opacity: 0; transform: translateY(-4px); }
  to { opacity: 1; transform: translateY(0); }
}
.metric-expl-reason {
  color: var(--text-primary);
  margin-bottom: 6px;
}
.metric-expl-factors {
  list-style: none;
  padding: 0;
  margin: 0;
  display: flex;
  flex-direction: column;
  gap: 3px;
}
.metric-expl-factors li {
  color: var(--text-secondary);
  font-size: 10px;
  padding-left: 12px;
  position: relative;
}
.metric-expl-factors li::before {
  content: '›';
  position: absolute;
  left: 2px;
  color: var(--accent);
  font-weight: 600;
}

/* Pros/Cons */
.pros-cons { display: flex; flex-direction: column; gap: 4px; }
.pro, .con { font-size: 11px; display: flex; gap: 4px; align-items: flex-start; }
.pro::before { content: '+'; color: var(--green); font-weight: 700; flex-shrink: 0; }
.con::before { content: '−'; color: var(--red); font-weight: 700; flex-shrink: 0; }

/* Data Context */
.data-context-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
}
.data-context-edit {
  font-size: 9px;
  color: var(--accent);
  cursor: pointer;
  opacity: 0.7;
  display: flex;
  align-items: center;
  gap: 3px;
}
.data-context-edit:hover { opacity: 1; }
.data-context-edit svg { width: 10px; height: 10px; }
.data-item {
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: 4px;
  padding: 6px 8px;
  margin-bottom: 6px;
  transition: border-color 0.3s;
}
.data-item.fit-great { border-left: 3px solid var(--green); }
.data-item.fit-good { border-left: 3px solid var(--green); opacity: 0.85; }
.data-item.fit-tradeoff { border-left: 3px solid var(--yellow); }
.data-item.fit-poor { border-left: 3px solid var(--red); }
.data-item.fit-risky { border-left: 3px solid var(--red); }
.data-item-header {
  display: flex;
  align-items: center;
  gap: 5px;
  margin-bottom: 2px;
  font-size: 11px;
  font-weight: 500;
}
.data-item-header svg { width: 11px; height: 11px; }
.fit-badge {
  font-size: 9px;
  font-weight: 600;
  padding: 1px 5px;
  border-radius: 3px;
  margin-left: auto;
  text-transform: uppercase;
  letter-spacing: 0.3px;
}
.fit-badge.great { background: rgba(34,197,94,0.15); color: var(--green); }
.fit-badge.good { background: rgba(34,197,94,0.1); color: var(--green); }
.fit-badge.tradeoff { background: rgba(234,179,8,0.15); color: var(--yellow); }
.fit-badge.poor { background: rgba(239,68,68,0.15); color: var(--red); }
.fit-badge.risky { background: rgba(239,68,68,0.15); color: var(--red); }
.data-item-note {
  font-size: 10px;
  color: var(--text-secondary);
  line-height: 1.4;
  margin-left: 16px;
}

/* Code Pattern */
.code-pattern {
  background: var(--canvas-bg);
  border: 1px solid var(--border);
  border-radius: 4px;
  padding: 8px 10px;
  font-family: 'SF Mono', 'Fira Code', 'Cascadia Code', monospace;
  font-size: 10px;
  line-height: 1.5;
  color: var(--text-secondary);
  overflow-x: auto;
  white-space: pre;
  tab-size: 2;
}
.code-pattern .kw { color: #c084fc; }
.code-pattern .fn { color: #60a5fa; }
.code-pattern .str { color: #4ade80; }
.code-pattern .cm { color: #6b7280; font-style: italic; }
.code-pattern .num { color: #fbbf24; }

/* Connection Labels */
.conn-label-group { cursor: pointer; }
.conn-label-group:hover .conn-label-bg { fill: var(--surface); }
.conn-label-bg {
  fill: var(--panel-bg);
  stroke: var(--border);
  stroke-width: 1;
  rx: 4;
  transition: fill 0.15s;
}
.conn-label-bg.selected { stroke: var(--accent); stroke-width: 1.5; }
.conn-label-text {
  fill: var(--text-secondary);
  font-size: 9px;
  font-family: 'Inter', system-ui, sans-serif;
  font-weight: 500;
  text-anchor: middle;
  dominant-baseline: central;
  pointer-events: none;
}
.conn-label-icon {
  fill: none;
  stroke: var(--text-secondary);
  stroke-width: 1;
}
.conn-label-group.selected .conn-label-text { fill: var(--accent); }

/* Connection detail in inspector */
/* Connection inspector — header with clickable endpoints */
.conn-header {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 10px;
}
.conn-endpoint {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 4px;
  cursor: pointer;
  flex: 1;
  min-width: 0;
  padding: 6px 4px;
  border-radius: var(--radius);
  transition: background 0.15s;
}
.conn-endpoint:hover { background: var(--surface); }
.conn-ep-icon {
  width: 32px;
  height: 32px;
  display: flex;
  align-items: center;
  justify-content: center;
  border: 2px solid var(--border);
  border-radius: 50%;
  background: var(--surface);
}
.conn-ep-icon svg { width: 16px; height: 16px; }
.conn-ep-name {
  font-size: 11px;
  font-weight: 600;
  text-align: center;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  max-width: 100%;
}
.conn-header-arrow { flex-shrink: 0; color: var(--text-secondary); }
.conn-header-arrow svg { width: 14px; height: 14px; }
/* Connection metadata badges */
.conn-meta {
  display: flex;
  align-items: center;
  gap: 6px;
  margin-bottom: 8px;
}
.conn-protocol-badge {
  display: inline-flex;
  align-items: center;
  gap: 3px;
  background: rgba(99, 102, 241, 0.1);
  border: 1px solid rgba(99, 102, 241, 0.3);
  border-radius: 3px;
  padding: 2px 8px;
  font-size: 10px;
  font-weight: 600;
  color: var(--accent);
}
.conn-role-tag {
  font-size: 10px;
  font-weight: 500;
  color: var(--text-secondary);
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: 3px;
  padding: 2px 8px;
}
/* Connection direction text */
.conn-direction-text {
  font-size: 11px;
  color: var(--text-secondary);
  line-height: 1.5;
  margin-bottom: 10px;
  font-style: italic;
  padding-left: 2px;
}
/* Connection property chips */
.conn-props-strip {
  display: flex;
  flex-direction: column;
  gap: 4px;
  margin-bottom: 10px;
}
.conn-prop-chip {
  display: flex;
  align-items: center;
  gap: 6px;
  font-size: 11px;
  padding: 5px 8px;
  background: var(--surface);
  border-radius: 4px;
  border-left: 3px solid var(--border);
}
.conn-prop-chip svg { width: 11px; height: 11px; flex-shrink: 0; }
.conn-prop-chip-label {
  color: var(--text-secondary);
  font-weight: 500;
  min-width: 60px;
  flex-shrink: 0;
}
.conn-prop-chip-val { color: var(--text-primary); }
.conn-prop-chip.positive { border-left-color: var(--green); }
.conn-prop-chip.positive .conn-prop-chip-val { color: var(--green); }
.conn-prop-chip.negative { border-left-color: var(--red); }
.conn-prop-chip.negative .conn-prop-chip-val { color: var(--red); }
/* Code pattern block */
.conn-code-pattern {
  background: var(--canvas-bg);
  border: 1px solid var(--border);
  border-radius: 4px;
  padding: 8px 10px;
  font-family: 'SF Mono', 'Fira Code', 'Cascadia Code', monospace;
  font-size: 10px;
  line-height: 1.5;
  color: var(--text-secondary);
  overflow-x: auto;
  white-space: pre;
  tab-size: 2;
  margin-top: 8px;
}
.conn-code-pattern .kw { color: #c084fc; }
.conn-code-pattern .fn { color: #60a5fa; }
.conn-code-pattern .str { color: #4ade80; }
.conn-code-pattern .cm { color: #6b7280; font-style: italic; }
.conn-code-pattern .num { color: #fbbf24; }
/* Connection footer — quick links to endpoints */
.conn-footer {
  display: flex;
  gap: 6px;
  margin-top: 12px;
  padding-top: 10px;
  border-top: 1px solid var(--border);
}
.conn-footer-link {
  flex: 1;
  display: flex;
  align-items: center;
  gap: 4px;
  font-size: 10px;
  color: var(--text-secondary);
  cursor: pointer;
  padding: 5px 8px;
  border: 1px solid var(--border);
  border-radius: var(--radius);
  transition: all 0.15s;
  justify-content: center;
}
.conn-footer-link:hover { border-color: var(--accent); color: var(--text-primary); }
.conn-footer-link svg { width: 11px; height: 11px; }
.conn-summary {
  font-size: 11px;
  color: var(--text-secondary);
  line-height: 1.6;
  padding: 6px 0;
}


/* ═══════════════ DASHBOARD ═══════════════ */
.dashboard {
  position: absolute;
  bottom: 0;
  left: 0;
  right: 0;
  background: var(--panel-bg);
  border-top: 1px solid var(--border);
  padding: 6px 12px;
  display: flex;
  flex-direction: column;
  z-index: 10;
}
.dashboard-title {
  font-size: 10px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  color: var(--text-secondary);
  margin-bottom: 4px;
  display: flex;
  align-items: center;
  gap: 5px;
}
.dashboard-title svg { width: 13px; height: 13px; }
.dashboard-bars {
  display: flex;
  gap: 6px;
  align-items: center;
}
.dash-bar-group {
  flex: 1;
  display: flex;
  flex-direction: column;
  gap: 2px;
}
.dash-bar-label {
  font-size: 9px;
  color: var(--text-secondary);
  text-align: center;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 3px;
}
.dash-bar-label svg { width: 10px; height: 10px; }
.dash-bar-track {
  height: 16px;
  background: var(--surface);
  border-radius: 3px;
  overflow: hidden;
  position: relative;
}
.dash-bar-fill {
  height: 100%;
  border-radius: 3px;
  transition: width 0.6s cubic-bezier(0.4, 0, 0.2, 1), background-color 0.6s;
  position: relative;
}
.dash-bar-value {
  position: absolute;
  right: 4px;
  top: 50%;
  transform: translateY(-50%);
  font-size: 9px;
  font-weight: 600;
  color: rgba(255,255,255,0.8);
}

/* Dashboard expand toggle */
.dash-expand-btn {
  background: none;
  border: 1px solid var(--border);
  border-radius: 3px;
  cursor: pointer;
  padding: 1px 4px;
  margin-left: auto;
  display: flex;
  align-items: center;
  color: var(--text-secondary);
  transition: all 0.15s;
}
.dash-expand-btn:hover { border-color: var(--text-secondary); color: var(--text-primary); }
.dash-expand-chevron { width: 10px; height: 10px; transition: transform 0.2s; }
.dashboard.expanded .dash-expand-chevron { transform: rotate(180deg); }

/* ═══════════════ DASHBOARD OVERLAY ═══════════════ */
.dash-overlay {
  display: none;
  position: absolute;
  top: 0; left: 0; right: 0; bottom: 0;
  background: rgba(15, 17, 23, 0.97);
  z-index: 20;
  flex-direction: column;
  overflow-y: auto;
  padding: 20px 24px;
}
.dash-overlay.visible { display: flex; }
.dash-overlay::-webkit-scrollbar { width: 4px; }
.dash-overlay::-webkit-scrollbar-track { background: transparent; }
.dash-overlay::-webkit-scrollbar-thumb { background: var(--border); border-radius: 2px; }
.dash-overlay-header {
  font-size: 12px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  color: var(--text-secondary);
  margin-bottom: 16px;
  display: flex;
  align-items: center;
  gap: 6px;
}
.dash-overlay-header svg { width: 14px; height: 14px; }
.dash-overlay-close {
  margin-left: auto;
  background: none;
  border: 1px solid var(--border);
  border-radius: 3px;
  color: var(--text-secondary);
  font-size: 16px;
  cursor: pointer;
  width: 24px;
  height: 24px;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.15s;
}
.dash-overlay-close:hover { border-color: var(--text-primary); color: var(--text-primary); }
.dash-overlay-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
  gap: 16px;
  flex: 1;
}
/* Each category card in the overlay */
.dash-card {
  background: var(--panel-bg);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 12px;
  display: flex;
  flex-direction: column;
  gap: 8px;
}
.dash-card-header {
  display: flex;
  align-items: center;
  gap: 6px;
  font-size: 12px;
  font-weight: 600;
}
.dash-card-header svg { width: 14px; height: 14px; }
.dash-card-score {
  font-size: 20px;
  font-weight: 700;
  margin-left: auto;
}
.dash-card-bar {
  height: 8px;
  background: var(--surface);
  border-radius: 4px;
  overflow: hidden;
}
.dash-card-fill {
  height: 100%;
  border-radius: 4px;
  transition: width 0.6s cubic-bezier(0.4, 0, 0.2, 1);
}
.dash-card-desc {
  font-size: 10px;
  color: var(--text-secondary);
  line-height: 1.4;
}
.dash-card-factors {
  display: flex;
  flex-direction: column;
  gap: 4px;
  margin-top: 4px;
}
.dash-card-factor {
  display: flex;
  align-items: center;
  gap: 6px;
  font-size: 10px;
  color: var(--text-secondary);
  position: relative;
}
.dash-card-factor-comp {
  width: 72px;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  flex-shrink: 0;
}
.dash-card-factor-icon {
  width: 14px;
  flex-shrink: 0;
  display: flex;
  align-items: center;
}
.dash-card-factor-icon svg { width: 11px; height: 11px; }
.dash-card-factor-bar {
  flex: 1;
  height: 6px;
  background: var(--surface);
  border-radius: 3px;
  overflow: hidden;
  min-width: 30px;
  display: block;
}
.dash-card-factor-fill {
  display: block;
  height: 100%;
  border-radius: 3px;
  transition: width 0.4s;
}
.dash-card-factor-val {
  width: 22px;
  text-align: right;
  font-weight: 600;
  font-size: 10px;
  flex-shrink: 0;
}
/* Factor tooltip */
.dash-card-factor-tip {
  display: none;
  position: absolute;
  bottom: calc(100% + 4px);
  left: 0;
  background: var(--panel-bg);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 6px 10px;
  font-size: 10px;
  color: var(--text-primary);
  white-space: nowrap;
  z-index: 5;
  box-shadow: 0 2px 8px rgba(0,0,0,0.3);
  pointer-events: none;
}
.dash-card-factor:hover .dash-card-factor-tip { display: block; }

/* ═══════════════ PROMPT OUTPUT ═══════════════ */
.prompt-section {
  position: fixed;
  bottom: 0;
  left: 0;
  right: 0;
  z-index: 200;
  transform: translateY(calc(100% - 32px));
  transition: transform 0.3s;
}
.prompt-section.open { transform: translateY(0); }
.prompt-toggle {
  background: var(--accent);
  color: white;
  border: none;
  padding: 6px 16px;
  font-size: 11px;
  font-weight: 600;
  font-family: inherit;
  cursor: pointer;
  border-radius: var(--radius) var(--radius) 0 0;
  margin-left: 16px;
  display: flex;
  align-items: center;
  gap: 5px;
}
.prompt-toggle svg { width: 14px; height: 14px; }
.prompt-body {
  background: var(--panel-bg);
  border-top: 1px solid var(--accent);
  padding: 12px 16px;
  max-height: 180px;
  display: flex;
  gap: 12px;
}
.prompt-text {
  flex: 1;
  font-size: 12px;
  color: var(--text-secondary);
  line-height: 1.6;
  overflow-y: auto;
  font-family: 'Inter', system-ui, sans-serif;
}
.prompt-copy-btn {
  background: var(--accent);
  color: white;
  border: none;
  padding: 6px 14px;
  border-radius: var(--radius);
  font-size: 11px;
  font-weight: 600;
  font-family: inherit;
  cursor: pointer;
  align-self: flex-start;
  white-space: nowrap;
  transition: background 0.15s;
  display: flex;
  align-items: center;
  gap: 4px;
}
.prompt-copy-btn svg { width: 12px; height: 12px; }
.prompt-copy-btn:hover { background: var(--accent-hover); }

/* ═══════════════ RIPPLE ANIMATION ═══════════════ */
@keyframes ripplePulse {
  0% { box-shadow: 0 0 0 0 rgba(99,102,241,0.4); }
  70% { box-shadow: 0 0 0 10px rgba(99,102,241,0); }
  100% { box-shadow: 0 0 0 0 rgba(99,102,241,0); }
}
.node.rippling { animation: ripplePulse 0.4s ease-out; }

/* ═══════════════ INFO POPUP ═══════════════ */
.info-popup-overlay {
  display: none;
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  background: rgba(0,0,0,0.5);
  z-index: 300;
  align-items: center;
  justify-content: center;
}
.info-popup-overlay.visible { display: flex; }
.info-popup {
  background: var(--panel-bg);
  border: 1px solid var(--border);
  border-radius: 8px;
  padding: 20px;
  max-width: 420px;
  width: 90%;
  box-shadow: 0 16px 48px rgba(0,0,0,0.5);
}
.info-popup-header {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 12px;
  font-size: 15px;
  font-weight: 700;
}
.info-popup-header svg { width: 22px; height: 22px; }
.info-popup-close {
  margin-left: auto;
  background: none;
  border: none;
  color: var(--text-secondary);
  cursor: pointer;
  font-size: 18px;
  padding: 2px 6px;
  border-radius: 4px;
  display: flex;
  align-items: center;
  transition: color 0.15s, background 0.15s;
}
.info-popup-close:hover { color: var(--text-primary); background: var(--surface); }
.info-popup-close svg { width: 14px; height: 14px; }
.info-popup-body {
  font-size: 12px;
  line-height: 1.6;
  color: var(--text-secondary);
}
.info-popup-body strong { color: var(--text-primary); font-weight: 600; }
.info-popup-body p { margin: 0 0 8px; }
.info-popup-section {
  margin-bottom: 10px;
}
.info-popup-section-title {
  font-size: 10px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  color: var(--text-secondary);
  margin-bottom: 4px;
}
.info-popup-list {
  margin: 0;
  padding-left: 16px;
}
.info-popup-list li { margin-bottom: 3px; }

/* Dashboard info icon */
.dash-info-btn {
  background: none;
  border: none;
  color: var(--text-secondary);
  cursor: pointer;
  padding: 0;
  display: inline-flex;
  align-items: center;
  opacity: 0.4;
  transition: opacity 0.15s, color 0.15s;
}
.dash-info-btn:hover { opacity: 1; color: var(--accent); }
.dash-info-btn svg { width: 9px; height: 9px; }

/* Clickable category icon on nodes */
.node-icon.clickable { cursor: pointer; transition: transform 0.15s; z-index: 6; position: relative; }
.node-icon.clickable:hover { transform: scale(1.2); }
.legend-item.clickable { cursor: pointer; transition: color 0.15s; }
.legend-item.clickable:hover { color: var(--text-primary) !important; }

/* Connection Health Indicator */
.conn-health-indicator { margin-top: 4px; }
.conn-health-badge {
  display: inline-flex;
  align-items: center;
  gap: 6px;
  padding: 4px 10px;
  border-radius: 4px;
  font-size: 11px;
  font-weight: 600;
  margin-bottom: 6px;
}
.conn-health-dot {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  flex-shrink: 0;
}
.conn-health-desc {
  font-size: 11px;
  color: var(--text-secondary);
  line-height: 1.5;
  margin-bottom: 8px;
}
.conn-health-endpoints {
  display: flex;
  flex-direction: column;
  gap: 4px;
  margin-bottom: 6px;
}
.conn-health-ep {
  display: flex;
  align-items: center;
  gap: 6px;
  font-size: 11px;
  color: var(--text-primary);
  background: var(--surface);
  padding: 4px 8px;
  border-radius: 4px;
}
.conn-health-rule {
  font-size: 9px;
  color: var(--text-secondary);
  font-style: italic;
  opacity: 0.7;
}
/* ═══════════════ CONNECTION HEALTH DETAIL ═══════════════ */
.conn-health-info-btn {
  width: 18px; height: 18px;
  border: none; background: none; cursor: pointer;
  color: var(--text-secondary); padding: 0; margin-left: 4px;
  border-radius: 50%; display: flex; align-items: center; justify-content: center;
  flex-shrink: 0; transition: color 0.15s, background 0.15s;
}
.conn-health-info-btn:hover { color: var(--accent); background: var(--accent)15; }
.conn-health-info-btn svg { width: 14px; height: 14px; }
.conn-health-metrics {
  display: none; padding: 6px 8px; margin-top: 4px;
  background: var(--canvas-bg); border-radius: 4px;
  border: 1px solid var(--border);
}
.conn-health-metrics.visible { display: block; }
.conn-health-metric-row {
  display: flex; align-items: center; gap: 6px;
  font-size: 10px; padding: 2px 0;
}
.conn-health-metric-name {
  width: 90px; color: var(--text-secondary); flex-shrink: 0;
}
.conn-health-metric-bar {
  flex: 1; height: 4px; background: var(--surface);
  border-radius: 2px; overflow: hidden; position: relative;
}
.conn-health-metric-fill {
  height: 100%; border-radius: 2px; transition: width 0.3s ease;
}
.conn-health-metric-val {
  width: 28px; text-align: right; font-weight: 600; font-size: 10px; flex-shrink: 0;
}
.conn-health-metric-flag {
  font-size: 9px; font-weight: 600; width: 12px; text-align: center; flex-shrink: 0;
}
.conn-health-metrics-label {
  font-size: 9px; color: var(--text-secondary); margin-bottom: 4px;
  text-transform: uppercase; letter-spacing: 0.5px; font-weight: 600;
}

/* ═══════════════ COLLAPSIBLE SECTIONS ═══════════════ */
.insp-section-title.collapsible {
  cursor: pointer;
  user-select: none;
  transition: color 0.15s;
}
.insp-section-title.collapsible:hover { color: var(--text-primary); }
.section-chevron {
  margin-left: auto;
  display: inline-flex;
  transition: transform 0.2s ease;
}
.section-chevron svg { width: 10px; height: 10px; }
.section-chevron.open { transform: rotate(90deg); }
.insp-section-body.collapsed { display: none; }
/* Collapsible toolbox cards */
.card-header.collapsible {
  cursor: pointer;
  user-select: none;
  transition: opacity 0.15s;
}
.card-header.collapsible:hover { opacity: 1; }
.card-header.collapsible .section-chevron { margin-left: auto; }
.card-details.collapsed { display: none; }

/* ═══════════════ METRIC DELTAS ═══════════════ */
.metric-delta {
  font-size: 10px;
  font-weight: 600;
  margin-left: 4px;
  display: inline-block;
  animation: deltaFadeIn 0.3s ease;
}
@keyframes deltaFadeIn {
  from { opacity: 0; transform: translateY(-4px); }
  to { opacity: 1; transform: translateY(0); }
}
.metric-delta.positive { color: var(--green); }
.metric-delta.negative { color: var(--red); }
.metric-delta.neutral { color: var(--text-secondary); }

/* ═══════════════ ISSUES SUMMARY ═══════════════ */
.issues-badge {
  position: absolute;
  top: -4px;
  right: -4px;
  background: var(--red);
  color: white;
  font-size: 9px;
  font-weight: 700;
  width: 16px;
  height: 16px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  pointer-events: none;
  line-height: 1;
}
.issues-badge.warning { background: var(--yellow); color: #000; }
.issues-badge.hidden { display: none; }
.issues-dropdown {
  position: fixed;
  background: var(--panel-bg);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 4px;
  min-width: 300px;
  z-index: 150;
  box-shadow: 0 8px 24px rgba(0,0,0,0.4);
  display: none;
}
.issues-dropdown.visible { display: block; }
.issues-dropdown-title {
  font-size: 10px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  color: var(--text-secondary);
  padding: 6px 8px 4px;
  display: flex;
  align-items: center;
  gap: 4px;
}
.issues-dropdown-title svg { width: 12px; height: 12px; }
.issues-item {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 6px 8px;
  border-radius: 4px;
  cursor: pointer;
  transition: background 0.1s;
  font-size: 11px;
}
.issues-item:hover { background: var(--surface); }
.issues-item svg { width: 14px; height: 14px; }
.issues-item-dot {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  flex-shrink: 0;
}
.issues-item-name { font-weight: 500; flex: 1; }
.issues-item-detail { color: var(--text-secondary); font-size: 10px; }
.issues-none {
  padding: 12px 8px;
  text-align: center;
  color: var(--text-secondary);
  font-size: 11px;
}

/* ═══════════════ VARIANT HINT ═══════════════ */
.variant-hint {
  background: var(--surface);
  border: 1px solid var(--border);
  border-left: 3px solid var(--accent);
  border-radius: var(--radius);
  padding: 6px 8px;
  margin-top: 6px;
  font-size: 10px;
  color: var(--text-secondary);
  line-height: 1.4;
  display: flex;
  align-items: flex-start;
  gap: 4px;
}
.variant-hint svg { width: 12px; height: 12px; flex-shrink: 0; margin-top: 1px; }
.variant-hint strong { color: var(--accent); font-weight: 600; }
.variant-hint .delta-positive { color: var(--green); font-weight: 600; }
.variant-hint .delta-negative { color: var(--red); font-weight: 600; }

/* ═══════════════ METRIC THRESHOLD ═══════════════ */
.metric-threshold {
  position: absolute;
  top: -1px;
  bottom: -1px;
  width: 1px;
  background: var(--text-secondary);
  opacity: 0.25;
  z-index: 1;
}

/* ═══════════════ DASHBOARD CLICKABLE ═══════════════ */
.dash-bar-track.clickable { cursor: pointer; transition: opacity 0.15s; }
.dash-bar-track.clickable:hover { opacity: 0.85; }
.node.flash-highlight { animation: nodeFlash 0.8s ease; }
@keyframes nodeFlash {
  0%, 100% { box-shadow: 0 0 0 0 rgba(99,102,241,0); }
  50% { box-shadow: 0 0 20px 4px rgba(99,102,241,0.5); }
}
</style>
</head>
<body>

<!-- ═══════════════ TOP BAR ═══════════════ -->
<div class="top-bar">
  <div class="logo">
    <svg viewBox="0 0 18 18" fill="none" stroke="currentColor" stroke-width="1.5"><rect x="2" y="2" width="14" height="14" rx="3"/><circle cx="6" cy="7" r="1.5" fill="currentColor" stroke="none"/><circle cx="12" cy="7" r="1.5" fill="currentColor" stroke="none"/><path d="M6 7h6M9 7v5"/></svg>
    Archie
  </div>
  <div class="arch-name">WhatsApp-Style Messaging Architecture</div>
  <div class="tier-badge" onclick="showTierInfo()" style="cursor:pointer" title="Click for tier details">
    <svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M8 1l2.5 4.5L16 6.5l-4 3.5 1 5.5L8 13l-5 2.5 1-5.5-4-3.5 5.5-1z"/></svg>
    Tier 2 <span class="tier-hint">/ 3</span>
  </div>
  <div class="top-actions">
    <button class="top-btn" id="heatmapToggle" onclick="toggleHeatmap()">
      <svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><circle cx="8" cy="8" r="6"/><circle cx="8" cy="8" r="3" opacity="0.5"/><circle cx="8" cy="8" r="1" fill="currentColor" stroke="none"/></svg>
      Heatmap
    </button>
    <button class="top-btn" id="issuesBtn" onclick="toggleIssues()" style="position:relative">
      <svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M8 2L1 14h14z"/><path d="M8 6v4M8 12v.5"/></svg>
      Issues
      <span class="issues-badge hidden" id="issuesBadge">0</span>
    </button>
    <button class="top-btn" onclick="togglePanel('toolbox')">
      <svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><rect x="2" y="2" width="5" height="12" rx="1"/><rect x="9" y="2" width="5" height="5" rx="1"/><rect x="9" y="9" width="5" height="5" rx="1"/></svg>
      Toolbox
    </button>
    <button class="top-btn" onclick="togglePanel('inspector')">
      <svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><rect x="2" y="2" width="12" height="12" rx="1"/><line x1="8" y1="2" x2="8" y2="14"/><line x1="8" y1="6" x2="14" y2="6"/><line x1="8" y1="10" x2="14" y2="10"/></svg>
      Inspector
    </button>
    <button class="top-btn">
      <svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M3 14V9l5-7 5 7v5"/><path d="M6 14v-3h4v3"/></svg>
      Import
    </button>
    <button class="top-btn">
      <svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M4 2h8l2 3v9H2V5z"/><path d="M5 2v3h6V2"/><circle cx="8" cy="10" r="2"/></svg>
      Export
    </button>
  </div>
</div>

<!-- ═══════════════ MAIN LAYOUT ═══════════════ -->
<div class="main-layout">
  <!-- TOOLBOX -->
  <aside class="toolbox" id="toolbox">
    <div class="toolbox-title">
      <svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><rect x="2" y="2" width="5" height="12" rx="1"/><rect x="9" y="2" width="5" height="5" rx="1"/><rect x="9" y="9" width="5" height="5" rx="1"/></svg>
      Toolbox
    </div>
    <div class="toolbox-tabs">
      <button class="toolbox-tab active" onclick="switchTab(this,'components')">
        <svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><rect x="2" y="2" width="5" height="5" rx="1"/><rect x="9" y="2" width="5" height="5" rx="1"/><rect x="2" y="9" width="5" height="5" rx="1"/><rect x="9" y="9" width="5" height="5" rx="1"/></svg>
        Components
      </button>
      <button class="toolbox-tab" onclick="switchTab(this,'stacks')">
        <svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><rect x="3" y="2" width="10" height="3" rx="1"/><rect x="3" y="7" width="10" height="3" rx="1"/><rect x="3" y="12" width="10" height="3" rx="1"/></svg>
        Stacks
      </button>
      <button class="toolbox-tab" onclick="switchTab(this,'blueprints')">
        <svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 2h12v12H2z"/><path d="M5 5h6M5 8h6M5 11h3"/><circle cx="12" cy="11" r="1" fill="currentColor" stroke="none"/></svg>
        Blueprints
      </button>
    </div>
    <div class="toolbox-content" id="toolboxContent"></div>
  </aside>

  <!-- CANVAS -->
  <main class="canvas" id="canvas">
    <svg class="canvas-svg" id="flowSvg" style="z-index:0"></svg>
    <svg class="canvas-svg" id="canvasSvg"></svg>
    <div id="nodesContainer"></div>
    <!-- Legend -->
    <div class="canvas-legend" id="canvasLegend"></div>
    <div class="canvas-hint">
      <svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><circle cx="8" cy="8" r="6"/><path d="M8 5v3M8 10v1"/></svg>
      Click a component to inspect &middot; Toggle heatmap to see health overlay
    </div>
    <!-- DASHBOARD — inside canvas, at bottom -->
    <div class="dashboard" id="dashboard">
      <div class="dashboard-title">
        <svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><rect x="1" y="8" width="3" height="6" rx="0.5"/><rect x="5.5" y="5" width="3" height="9" rx="0.5"/><rect x="10" y="2" width="3" height="12" rx="0.5"/></svg>
        Architecture Health
        <button class="dash-expand-btn" onclick="toggleDashboardExpand()" title="Show contributing factors">
          <svg class="dash-expand-chevron" viewBox="0 0 10 10" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2.5 4L5 6.5L7.5 4"/></svg>
        </button>
      </div>
      <div class="dashboard-bars" id="dashboardBars"></div>
    </div>
    <!-- DASHBOARD EXPANDED OVERLAY -->
    <div class="dash-overlay" id="dashOverlay">
      <div class="dash-overlay-header">
        <svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><rect x="1" y="8" width="3" height="6" rx="0.5"/><rect x="5.5" y="5" width="3" height="9" rx="0.5"/><rect x="10" y="2" width="3" height="12" rx="0.5"/></svg>
        Architecture Health — 7 Metric Categories
        <button class="dash-overlay-close" onclick="toggleDashboardExpand()" title="Close details">&times;</button>
      </div>
      <div class="dash-overlay-grid" id="dashOverlayGrid"></div>
    </div>
  </main>

  <!-- INSPECTOR -->
  <aside class="inspector" id="inspector">
    <div class="inspector-header">
      <svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><rect x="2" y="2" width="12" height="12" rx="1"/><line x1="8" y1="2" x2="8" y2="14"/><line x1="8" y1="6" x2="14" y2="6"/><line x1="8" y1="10" x2="14" y2="10"/></svg>
      Inspector
    </div>
    <div class="inspector-content" id="inspectorContent">
      <div class="inspector-empty">
        <svg viewBox="0 0 32 32" fill="none" stroke="currentColor" stroke-width="1"><circle cx="16" cy="16" r="12"/><path d="M16 10v6M16 20v1"/></svg>
        Click a component on the canvas to see its details, metrics, and configuration variants.
      </div>
    </div>
  </aside>
</div>

<!-- ═══════════════ PROMPT OUTPUT ═══════════════ -->
<div class="prompt-section" id="promptSection">
  <button class="prompt-toggle" onclick="document.getElementById('promptSection').classList.toggle('open')">
    <svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><rect x="2" y="2" width="12" height="12" rx="2"/><path d="M5 6h6M5 8h6M5 10h4"/></svg>
    Prompt Output
  </button>
  <div class="prompt-body">
    <div class="prompt-text" id="promptText"></div>
    <button class="prompt-copy-btn" onclick="copyPrompt()">
      <svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><rect x="5" y="5" width="9" height="9" rx="1"/><path d="M5 11H3a1 1 0 01-1-1V3a1 1 0 011-1h7a1 1 0 011 1v2"/></svg>
      Copy Prompt
    </button>
  </div>
</div>

<!-- ═══════════════ INFO POPUP ═══════════════ -->
<div class="info-popup-overlay" id="infoPopupOverlay" onclick="if(event.target===this)hideInfoPopup()">
  <div class="info-popup">
    <div class="info-popup-header" id="infoPopupHeader"></div>
    <div class="info-popup-body" id="infoPopupBody"></div>
  </div>
</div>

<!-- Issues Dropdown (fixed position, placed by JS) -->
<div class="issues-dropdown" id="issuesDropdown"></div>

<script>
// ═══════════════ SVG ICONS ═══════════════
const ICONS = {
  // Category icons
  'Compute': '<svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><rect x="4" y="4" width="8" height="8" rx="1"/><line x1="6" y1="2" x2="6" y2="4"/><line x1="10" y1="2" x2="10" y2="4"/><line x1="6" y1="12" x2="6" y2="14"/><line x1="10" y1="12" x2="10" y2="14"/><line x1="2" y1="6" x2="4" y2="6"/><line x1="2" y1="10" x2="4" y2="10"/><line x1="12" y1="6" x2="14" y2="6"/><line x1="12" y1="10" x2="14" y2="10"/></svg>',
  'Data Storage': '<svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><ellipse cx="8" cy="4" rx="5" ry="2"/><path d="M3 4v8c0 1.1 2.24 2 5 2s5-.9 5-2V4"/><path d="M3 8c0 1.1 2.24 2 5 2s5-.9 5-2" opacity="0.5"/></svg>',
  'Caching': '<svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M9 1L4 9h4l-1 6 5-8H8l1-6z" stroke-linejoin="round"/></svg>',
  'Messaging': '<svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 3h12v8H6l-4 3V3z" stroke-linejoin="round"/></svg>',
  'Delivery/Network': '<svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><circle cx="8" cy="8" r="6"/><ellipse cx="8" cy="8" rx="3" ry="6"/><line x1="2" y1="8" x2="14" y2="8"/></svg>',
  'Real-Time': '<svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 8h2l2-4 2 8 2-5 2 3h2"/></svg>',
  'Auth/Security': '<svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M8 1L2 4v4c0 4 2.5 6 6 7 3.5-1 6-3 6-7V4L8 1z"/></svg>',
  'Monitoring': '<svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><rect x="2" y="2" width="12" height="12" rx="1"/><path d="M4 10l3-4 2 2 3-4"/></svg>',
  'Search': '<svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><circle cx="7" cy="7" r="4"/><line x1="10" y1="10" x2="14" y2="14"/></svg>',
  'DevOps': '<svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><circle cx="8" cy="8" r="2"/><path d="M8 2v2M8 12v2M2 8h2M12 8h2M3.8 3.8l1.4 1.4M10.8 10.8l1.4 1.4M3.8 12.2l1.4-1.4M10.8 5.2l1.4-1.4"/></svg>',
  // UI icons
  'is': '<svg viewBox="0 0 10 10" fill="none" stroke="currentColor" stroke-width="1.5"><circle cx="5" cy="5" r="3.5"/></svg>',
  'gain': '<svg viewBox="0 0 10 10" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M5 2v6M2 5l3-3 3 3"/></svg>',
  'cost': '<svg viewBox="0 0 10 10" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M5 8V2M2 5l3 3 3-3"/></svg>',
  'config': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.5"><circle cx="6" cy="6" r="2"/><path d="M6 1v2M6 9v2M1 6h2M9 6h2"/></svg>',
  'metrics': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.5"><rect x="1" y="6" width="2" height="5" rx="0.5"/><rect x="5" y="3" width="2" height="8" rx="0.5"/><rect x="9" y="1" width="2" height="10" rx="0.5"/></svg>',
  'pros': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.5"><circle cx="6" cy="6" r="4.5"/><path d="M4 6h4M6 4v4"/></svg>',
  'cons': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.5"><circle cx="6" cy="6" r="4.5"/><path d="M4 6h4"/></svg>',
  // Dashboard category icons
  'perf': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M2 10l3-5 2 2 3-5"/><path d="M9 2h2v2"/></svg>',
  'cost_dash': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><circle cx="6" cy="6" r="4"/><path d="M6 3v6M4.5 4.5h3M4.5 7.5h3"/></svg>',
  'rel': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M6 1L1.5 4v3.5c0 2.5 1.8 4 4.5 4.5 2.7-.5 4.5-2 4.5-4.5V4L6 1z"/></svg>',
  'ops': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><circle cx="6" cy="6" r="2"/><path d="M6 1v1.5M6 9.5V11M1 6h1.5M9.5 6H11M2.8 2.8l1 1M8.2 8.2l1 1M2.8 9.2l1-1M8.2 3.8l1-1"/></svg>',
  'scale': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M2 10V6l4-4 4 4v4"/></svg>',
  'strat': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><circle cx="6" cy="4" r="2"/><path d="M6 6v4M3 8h6"/></svg>',
  'dev_dash': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M4 3L1 6l3 3M8 3l3 3-3 3"/></svg>',
  // Data context icons
  'data_ctx': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><rect x="1" y="1" width="10" height="10" rx="1"/><path d="M4 4h4M4 6h4M4 8h2"/></svg>',
  'edit': '<svg viewBox="0 0 10 10" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M1 9l6-6 1 1-6 6z"/><path d="M6 3l1-1 2 2-1 1"/></svg>',
  'session': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><circle cx="6" cy="4" r="2.5"/><path d="M2 10c0-2.2 1.8-4 4-4s4 1.8 4 4"/></svg>',
  'counter': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M2 10V5l2-3 2 4 2-2 2 3v3"/></svg>',
  'cache_item': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><rect x="2" y="2" width="8" height="8" rx="1"/><path d="M5 4v4M4 7l1 1 1-1"/></svg>',
  'table': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><rect x="1" y="1" width="10" height="10" rx="1"/><line x1="1" y1="4" x2="11" y2="4"/><line x1="5" y1="4" x2="5" y2="11"/></svg>',
  'message': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M2 2h8v6H5l-3 2V2z"/></svg>',
  'endpoint': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M1 6h4M7 6h4"/><circle cx="6" cy="6" r="2"/></svg>',
  'route': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M2 2l8 8M2 5h3M7 9h3"/></svg>',
  'event': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M7 1L3 7h3l-1 4 4-6H6l1-4z"/></svg>',
  'receipt': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M2 6l3 3 5-5"/></svg>',
  'presence': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><circle cx="6" cy="6" r="3"/><circle cx="6" cy="6" r="1" fill="currentColor" stroke="none"/></svg>',
  'ssl': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><rect x="3" y="5" width="6" height="5" rx="1"/><path d="M4 5V4a2 2 0 014 0v1"/></svg>',
  'ratelimit': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><circle cx="6" cy="6" r="4.5"/><path d="M6 3v3l2 1"/></svg>',
  // Metric-specific icons
  'latency': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><circle cx="6" cy="6" r="4.5"/><path d="M6 3.5v3l2 1.5"/></svg>',
  'throughput': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M1 6h10M8 3l3 3-3 3"/></svg>',
  'cost_eff': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><circle cx="6" cy="6" r="4"/><path d="M6 3v6M4.5 4.5h3M4.5 7.5h3"/></svg>',
  'simplicity': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M3 4h6M3 6h6M3 8h4"/></svg>',
  'read_perf': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><circle cx="6" cy="5" r="3"/><path d="M1 5c2-3 8-3 10 0M1 5c2 3 8 3 10 0"/></svg>',
  'write_perf': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M2 10l7-7 1 1-7 7z"/><path d="M8 3l1-1 2 2-1 1"/></svg>',
  'scalability': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M2 10V6l4-4 4 4v4"/></svg>',
  'consistency': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M2 6h8M4 3h4M4 9h4"/></svg>',
  'ordering': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M3 3h6M3 6h4M3 9h2"/></svg>',
  'code': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M4 3L1 6l3 3"/><path d="M8 3l3 3-3 3"/><line x1="7" y1="2" x2="5" y2="10"/></svg>',
  // Connection property icons
  'protocol': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M2 6h8"/><circle cx="2" cy="6" r="1.5"/><circle cx="10" cy="6" r="1.5"/></svg>',
  'pattern': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M2 6h2l1-3 2 6 1-3h2"/></svg>',
  'speed': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><circle cx="6" cy="7" r="4"/><path d="M6 7l2-3"/><path d="M3 7h1M8 7h1"/></svg>',
  'coloc': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><rect x="1" y="3" width="10" height="6" rx="1"/><line x1="6" y1="3" x2="6" y2="9"/></svg>',
  'conn': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M1 6h3M8 6h3"/><rect x="4" y="3" width="4" height="6" rx="1"/></svg>',
  'arrow_right': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M2 6h8M7 3l3 3-3 3"/></svg>',
  'arrow_bidir': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M2 6h8M4 3L1 6l3 3M8 3l3 3-3 3"/></svg>',
  'info': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><circle cx="6" cy="6" r="5"/><path d="M6 5.5v3"/><circle cx="6" cy="3.5" r="0.5" fill="currentColor" stroke="none"/></svg>',
  'close': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M3 3l6 6M9 3l-6 6"/></svg>',
  'chevron': '<svg viewBox="0 0 10 10" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M3 2l4 3-4 3"/></svg>',
  // New metric icons
  'reliability': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M6 1L1.5 4v3.5c0 2.5 1.8 4 4.5 4.5 2.7-.5 4.5-2 4.5-4.5V4L6 1z"/></svg>',
  'portability': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M6 1v10M1 6h10"/><circle cx="6" cy="6" r="4.5"/><path d="M2.5 4h7M2.5 8h7"/></svg>',
  'learning': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M1 4.5l5-2.5 5 2.5-5 2.5z"/><path d="M2.5 5.5v3c0 1 1.5 1.5 3.5 1.5s3.5-.5 3.5-1.5v-3"/></svg>',
  'filter': '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M1.5 2h9L7.5 6v3.5L4.5 11V6z"/></svg>'
};

// Map metric names to icon keys
const METRIC_ICON_MAP = {
  'Latency': 'latency', 'Throughput': 'throughput', 'Cost Efficiency': 'cost_eff',
  'Op. Simplicity': 'simplicity', 'Read Perf': 'read_perf', 'Write Perf': 'write_perf',
  'Scalability': 'scalability', 'Consistency': 'consistency', 'Ordering': 'ordering',
  'Reliability': 'reliability', 'Portability': 'portability', 'Learning Curve': 'learning'
};

// Metric explanations — why each component+variant scores the way it does
const METRIC_EXPLANATIONS = {
  'api-gateway': {
    'nginx': {
      'Latency': { reason: 'Nginx processes requests in C with an event-driven architecture, adding minimal overhead per request.', factors: ['Event-driven, non-blocking I/O', 'No managed-service network hop', 'Compiled C code, near-hardware speed'] },
      'Throughput': { reason: 'Handles tens of thousands of concurrent connections with minimal memory per connection.', factors: ['Worker process model scales to CPU cores', 'Efficient connection handling (~2.5KB per conn)', 'No per-request billing or throttle limits'] },
      'Cost Efficiency': { reason: 'Open-source and self-hosted. Runs on commodity hardware with low resource usage.', factors: ['No license or per-request cost', 'Low CPU/memory footprint', 'Slight ops cost for self-management'] },
      'Op. Simplicity': { reason: 'Config-file driven with no GUI. Changes require reload and manual validation.', factors: ['Config syntax has a learning curve', 'No built-in dashboard or metrics UI', 'Manual cert management (unless using certbot)'] },
      'Reliability': { reason: 'Self-managed means you own failover, health checks, and restarts. No built-in HA without extra setup.', factors: ['No automatic failover — requires keepalived or similar', 'Worker process crash recovery is fast but manual to configure', 'No built-in health monitoring dashboard'] },
      'Portability': { reason: 'Fully open-source, runs on any Linux server. Config files are portable across environments.', factors: ['Open-source (BSD license), no vendor dependency', 'Runs on bare metal, VMs, containers, any cloud', 'Config syntax is Nginx-specific but well-documented'] },
      'Learning Curve': { reason: 'Config file syntax is unique and can be tricky. No GUI — all changes via text config and CLI.', factors: ['Nginx config syntax has its own conventions', 'Debugging config errors requires reading logs', 'Advanced features (Lua, stream) require deeper expertise'] }
    },
    'aws-apigw': {
      'Latency': { reason: 'Managed service adds network overhead: request goes through AWS edge, auth, and transformation layers.', factors: ['Cold-start latency on Lambda integrations', 'Multi-hop: edge → regional → backend', 'Payload transformation adds processing time'] },
      'Throughput': { reason: 'Default throttle limits (10K req/s) and payload caps restrict raw throughput.', factors: ['Default 10,000 requests/sec soft limit', '10MB payload maximum', 'Scales automatically but within AWS limits'] },
      'Cost Efficiency': { reason: 'Pay-per-request pricing becomes expensive at scale ($3.50/million requests + data transfer).', factors: ['$1.00–$3.50 per million requests', 'Data transfer charges add up', 'Free tier covers only first 12 months'] },
      'Op. Simplicity': { reason: 'Fully managed: no servers, auto-scaling, built-in monitoring. Zero infrastructure ops.', factors: ['Zero server management', 'Built-in CloudWatch metrics & logging', 'Native auth via Cognito/IAM/Lambda authorizers'] },
      'Reliability': { reason: 'AWS-managed with 99.95% SLA, multi-AZ deployment, and automatic failover.', factors: ['99.95% uptime SLA backed by AWS', 'Multi-AZ deployment by default', 'Automatic scaling handles traffic spikes'] },
      'Portability': { reason: 'Deep AWS integration: IAM auth, Lambda triggers, CloudWatch. Migration requires rewriting integrations.', factors: ['Proprietary API config format (not portable)', 'Lambda authorizers tie auth to AWS', 'CloudWatch/X-Ray monitoring only works in AWS'] },
      'Learning Curve': { reason: 'Console-driven setup with good documentation. Concepts map to standard API gateway patterns.', factors: ['AWS Console provides guided setup', 'Well-documented with tutorials and examples', 'IAM permissions model has its own learning curve'] }
    },
    'kong': {
      'Latency': { reason: 'Built on Nginx core but adds Lua plugin processing per request, introducing slight overhead.', factors: ['Nginx core provides fast baseline', 'Each plugin adds Lua execution time', 'Plugin chain depth affects total latency'] },
      'Throughput': { reason: 'Inherits Nginx performance but plugin overhead reduces peak throughput vs. raw Nginx.', factors: ['Nginx event loop handles connections efficiently', 'Plugin execution reduces per-request throughput', 'DB-backed mode adds admin API lookups'] },
      'Cost Efficiency': { reason: 'Open-source core is free, but enterprise features (RBAC, dev portal) require paid license.', factors: ['Open-source core is free to self-host', 'Enterprise license for advanced features', 'Operational cost for managing Kong + its database'] },
      'Op. Simplicity': { reason: 'Powerful but complex: requires its own database, admin API, and plugin configuration knowledge.', factors: ['Requires PostgreSQL or Cassandra for config', 'Plugin ecosystem has a learning curve', 'DB-less mode simplifies but limits dynamic routing'] },
      'Reliability': { reason: 'Built on Nginx core with HA clustering available, but requires manual configuration.', factors: ['Nginx core provides stable request handling', 'HA clustering requires enterprise or manual setup', 'Health checks available via plugin'] },
      'Portability': { reason: 'Open-source core is fully portable. Enterprise features create soft lock-in.', factors: ['Open-source core (Apache 2.0 license)', 'Enterprise features (RBAC, dev portal) are proprietary', 'Plugin configs are Kong-specific but open format'] },
      'Learning Curve': { reason: 'Plugin architecture and admin API require dedicated learning. DB setup adds initial complexity.', factors: ['Plugin system has its own configuration model', 'Admin API requires understanding Kong concepts', 'DB-backed mode requires PostgreSQL/Cassandra knowledge'] }
    }
  },
  'nodejs-api': {
    'express': {
      'Latency': { reason: 'Middleware chain processes sequentially. Minimal overhead per middleware, but no built-in optimization.', factors: ['Each middleware adds ~0.1ms processing', 'No built-in response serialization optimization', 'Simple routing with acceptable lookup speed'] },
      'Throughput': { reason: 'Single-threaded event loop without built-in schema validation or serialization optimization.', factors: ['No compiled schema validators', 'JSON.stringify on every response (not optimized)', 'Middleware overhead accumulates on hot paths'] },
      'Cost Efficiency': { reason: 'Extremely minimal footprint. Few dependencies, low memory usage, runs anywhere Node.js runs.', factors: ['Tiny package (~200KB installed)', 'Low memory baseline (~30MB idle)', 'No runtime license cost'] },
      'Op. Simplicity': { reason: 'Minimal, un-opinionated framework. Easy to start but requires manual structuring at scale.', factors: ['5 lines to a working server', 'Massive ecosystem of middleware', 'No enforced project structure'] },
      'Reliability': { reason: 'No built-in error boundaries or structured error handling. Uncaught exceptions crash the process.', factors: ['Uncaught exceptions kill the process', 'No built-in clustering or process management', 'Error handling is entirely manual (middleware-based)'] },
      'Portability': { reason: 'Standard Node.js with MIT license. Runs anywhere Node.js runs, no proprietary APIs.', factors: ['MIT license, fully open source', 'Standard Node.js HTTP — no proprietary extensions', 'Middleware patterns are widely understood'] },
      'Learning Curve': { reason: 'Minimal API surface. Most JavaScript developers can be productive within hours.', factors: ['Familiar JavaScript/Node.js patterns', 'Massive community: millions of tutorials and examples', 'Simple middleware chain model'] }
    },
    'fastify': {
      'Latency': { reason: 'Compiles JSON schemas into optimized serializers at startup, reducing per-request processing.', factors: ['fast-json-stringify compiles schemas ahead of time', 'Radix-tree router is faster than Express regex matching', 'Schema-based validation runs at native speed'] },
      'Throughput': { reason: 'Purpose-built for speed: 2-3x faster than Express in benchmarks due to schema compilation.', factors: ['Compiled serialization avoids JSON.stringify overhead', 'Efficient routing via find-my-way radix tree', 'Lower per-request overhead in plugin system'] },
      'Cost Efficiency': { reason: 'Similar footprint to Express with better throughput, meaning fewer instances needed for same load.', factors: ['Higher throughput per instance = fewer servers', 'Comparable memory usage to Express', 'Open-source, no license cost'] },
      'Op. Simplicity': { reason: 'Plugin system is powerful but different from Express middleware. Requires schema-first mindset.', factors: ['Encapsulated plugin system has a learning curve', 'Schema-first approach requires upfront design', 'Smaller community means fewer Stack Overflow answers'] },
      'Reliability': { reason: 'Schema validation catches malformed input early. Plugin encapsulation isolates failures better than Express.', factors: ['Schema validation rejects bad input before handler code', 'Plugin encapsulation prevents cross-contamination', 'Built-in error handling with onError hooks'] },
      'Portability': { reason: 'Open-source, runs on standard Node.js. Plugin API is Fastify-specific but code is portable.', factors: ['MIT license, fully open source', 'Standard Node.js — no proprietary runtime', 'Plugin patterns differ from Express but are portable'] },
      'Learning Curve': { reason: 'Plugin system and schema-first approach require shifting from Express mental model.', factors: ['Plugin encapsulation model is different from middleware', 'Schema-first design requires upfront JSON Schema knowledge', 'Smaller community means fewer ready-made examples'] }
    },
    'nestjs': {
      'Latency': { reason: 'Dependency injection, decorators, and interceptor pipeline add framework overhead per request.', factors: ['DI container resolution on each request', 'Interceptor/guard/pipe pipeline adds layers', 'TypeScript reflection metadata has runtime cost'] },
      'Throughput': { reason: 'Heaviest of the three frameworks due to abstraction layers and decorator processing.', factors: ['More memory per request from DI context', 'Decorator metadata processing overhead', 'Default uses Express under the hood (can switch to Fastify)'] },
      'Cost Efficiency': { reason: 'Higher memory and CPU usage per request, but structured code reduces long-term maintenance cost.', factors: ['~60-80MB baseline memory (vs 30MB Express)', 'More CPU per request from framework overhead', 'Structured code reduces refactoring costs over time'] },
      'Op. Simplicity': { reason: 'Enterprise patterns (DI, modules, decorators) add upfront complexity but enforce clean architecture.', factors: ['Steep learning curve for DI and decorators', 'Enforced module structure can feel over-engineered for small APIs', 'Excellent for large teams, heavy for solo developers'] },
      'Reliability': { reason: 'Structured error handling via exception filters, guards, and interceptors. Framework enforces patterns that prevent unhandled crashes.', factors: ['Exception filters catch and handle errors systematically', 'Guards prevent unauthorized access at the framework level', 'Interceptors can wrap error handling around all endpoints'] },
      'Portability': { reason: 'Open-source but opinionated: decorators and DI patterns are NestJS-specific. Migration requires rewriting structure.', factors: ['MIT license, open source', 'Decorator-based routing is NestJS-specific', 'DI container patterns don\'t directly map to other frameworks'] },
      'Learning Curve': { reason: 'Requires understanding DI, decorators, modules, guards, interceptors, and pipes. Steepest learning curve of the three.', factors: ['Dependency injection is unfamiliar to most JS developers', 'Decorator syntax requires TypeScript experience', 'Module system requires planning app architecture upfront'] }
    }
  },
  'postgresql': {
    'normalized': {
      'Read Perf': { reason: 'JOINs across multiple tables add query planning and execution time for complex reads.', factors: ['Multi-table JOINs increase query complexity', 'Index lookups across relations add I/O', 'Query planner must evaluate join strategies'] },
      'Write Perf': { reason: 'Single source of truth — each fact stored once, so writes are simple and consistent.', factors: ['No data duplication to maintain', 'Foreign key checks are fast with indexes', 'Single UPDATE per entity change'] },
      'Scalability': { reason: 'JOINs become expensive at scale; vertical scaling hits limits before horizontal can help.', factors: ['Cross-table JOINs don\'t parallelize well', 'Foreign key constraints limit partition strategies', 'Read replicas help but don\'t solve write scaling'] },
      'Op. Simplicity': { reason: 'Well-understood relational model, but migrations and schema changes require careful planning.', factors: ['Standard SQL, widely understood', 'Schema migrations need downtime planning', 'Foreign key relationships can create migration dependencies'] },
      'Reliability': { reason: 'Full ACID compliance with WAL, point-in-time recovery, and mature replication. Decades of battle-testing.', factors: ['ACID transactions prevent data corruption', 'WAL (Write-Ahead Log) ensures crash recovery', 'Streaming replication provides HA failover'] },
      'Portability': { reason: 'Open-source, standard SQL. Runs on any platform. Normalized schemas are the most portable data model.', factors: ['Open-source (PostgreSQL License), no vendor', 'Standard SQL is portable to other RDBMS', 'Normalized schemas follow universal relational theory'] },
      'Learning Curve': { reason: 'SQL is widely taught and understood. Normalized design follows standard database theory.', factors: ['SQL is the most widely-known query language', 'Relational modeling is taught in every CS curriculum', 'Extensive documentation and community resources'] }
    },
    'denormalized': {
      'Read Perf': { reason: 'Pre-joined data eliminates JOINs. Single-table lookups are fast and cache-friendly.', factors: ['No JOINs needed — all data in one row', 'Sequential scans on single table are fast', 'Excellent cache hit rates (one table = one cache)'] },
      'Write Perf': { reason: 'Updating one fact may require updating many rows, creating write amplification.', factors: ['Duplicated data means multi-row updates', 'Risk of update anomalies if writes miss copies', 'Bulk updates needed for denormalized fields'] },
      'Scalability': { reason: 'Single-table reads scale horizontally, but write amplification limits overall throughput.', factors: ['Read scaling via replicas is straightforward', 'Partitioning single tables is easier', 'Write amplification bottlenecks at scale'] },
      'Op. Simplicity': { reason: 'Simpler queries but harder data management: inconsistencies and update anomalies are common.', factors: ['Queries are simpler (no JOINs)', 'Data consistency requires application-level discipline', 'Schema design is harder to get right upfront'] },
      'Reliability': { reason: 'ACID still applies per-table, but duplicated data means application bugs can cause silent inconsistencies.', factors: ['ACID guarantees still hold per transaction', 'Duplicated data can drift if updates miss copies', 'No foreign keys to enforce cross-table integrity'] },
      'Portability': { reason: 'Still standard PostgreSQL/SQL. Denormalization patterns are database-agnostic concepts.', factors: ['Standard SQL, runs on any PostgreSQL-compatible host', 'Denormalization is a universal pattern, not vendor-specific', 'Schema design is portable across RDBMS'] },
      'Learning Curve': { reason: 'Requires understanding denormalization trade-offs, update anomalies, and when to duplicate data.', factors: ['Must understand when duplication is worthwhile', 'Update anomaly prevention requires careful application logic', 'Schema design decisions are harder to reverse'] }
    },
    'jsonb-hybrid': {
      'Read Perf': { reason: 'Structured columns use indexes efficiently; JSONB fields require GIN indexes which are slower.', factors: ['Relational columns use B-tree indexes (fast)', 'JSONB queries use GIN indexes (slower than B-tree)', 'Mixed queries need careful index planning'] },
      'Write Perf': { reason: 'JSONB updates rewrite the entire JSON document, even for small changes.', factors: ['JSONB updates are full-document rewrites', 'Relational columns update efficiently', 'GIN index maintenance adds write overhead'] },
      'Scalability': { reason: 'Better than normalized for reads, worse than denormalized. JSONB flexibility helps at cost of indexing.', factors: ['JSONB reduces need for schema migrations', 'GIN indexes use more storage than B-tree', 'Flexible schema adapts to evolving requirements'] },
      'Op. Simplicity': { reason: 'Flexible but harder to enforce data integrity. JSONB fields lack type safety and constraint checks.', factors: ['No foreign key constraints in JSONB', 'JSON schema validation must be done in application code', 'Debugging JSONB queries is harder than SQL'] },
      'Reliability': { reason: 'ACID for relational columns, but JSONB fields lack constraint enforcement — integrity depends on application code.', factors: ['ACID transactions cover the full row (including JSONB)', 'No CHECK constraints inside JSONB structure', 'GIN index corruption is rare but harder to diagnose'] },
      'Portability': { reason: 'JSONB is PostgreSQL-specific. Migrating JSONB queries to another RDBMS requires rewriting.', factors: ['JSONB operators (@>, ->, #>) are PostgreSQL-only', 'GIN indexes are PostgreSQL-specific', 'Relational columns remain portable via standard SQL'] },
      'Learning Curve': { reason: 'Requires understanding both relational modeling AND JSONB operators, indexes, and query patterns.', factors: ['JSONB query syntax is different from standard SQL', 'GIN index tuning requires PostgreSQL-specific knowledge', 'Deciding what goes in columns vs JSONB requires experience'] }
    }
  },
  'redis': {
    'cache-aside': {
      'Read Perf': { reason: 'Cache hits return data in <1ms. Cache misses fall through to the database (then cached).', factors: ['Sub-millisecond reads on cache hit', 'First request per key incurs DB read (miss penalty)', 'TTL-based expiry keeps working set in memory'] },
      'Consistency': { reason: 'Cache and database can diverge. Stale data persists until TTL expires or manual invalidation.', factors: ['No automatic cache invalidation on DB write', 'TTL creates a staleness window', 'Concurrent writes can race between cache and DB'] },
      'Cost Efficiency': { reason: 'Only caches what\'s actually read (demand-driven). No wasted memory on unread data.', factors: ['Cache only holds accessed data', 'TTL evicts cold data automatically', 'Memory usage grows with read working set, not total dataset'] },
      'Op. Simplicity': { reason: 'Simple pattern: check cache → miss → read DB → write cache. Easy to understand and implement.', factors: ['Straightforward read-through logic', 'Application controls all cache decisions', 'Cache failures degrade gracefully to DB reads'] },
      'Reliability': { reason: 'Cache failure is non-fatal — application falls back to database reads. Graceful degradation by design.', factors: ['Cache miss = DB read (not an error)', 'Redis outage doesn\'t cause data loss', 'TTL-based expiry prevents stale data from persisting forever'] },
      'Portability': { reason: 'Standard Redis commands, runs on any Redis-compatible service (ElastiCache, Upstash, self-hosted).', factors: ['Standard RESP protocol, widely supported', 'No proprietary extensions required', 'Pattern logic lives in application code, not Redis'] },
      'Learning Curve': { reason: 'Simplest caching pattern: check cache, miss, read DB, populate cache. Well-documented everywhere.', factors: ['Pattern is intuitive and widely taught', 'Redis GET/SET commands are trivially simple', 'Failure modes are easy to reason about'] }
    },
    'write-through': {
      'Read Perf': { reason: 'Cache is always warm — every write updates both cache and DB, so reads never miss.', factors: ['Zero cache misses for written data', 'All data available at Redis speed (<1ms)', 'No cold-start or warm-up period needed'] },
      'Consistency': { reason: 'Synchronous dual-write ensures cache and DB are always in sync.', factors: ['Every write updates cache + DB atomically', 'No staleness window (unlike cache-aside with TTL)', 'Slight risk if one write succeeds and the other fails'] },
      'Cost Efficiency': { reason: 'Caches ALL written data, including data that may never be read. Higher memory usage.', factors: ['Caches data that may never be read', 'Memory usage proportional to write volume, not reads', 'Synchronous dual-write doubles write latency cost'] },
      'Op. Simplicity': { reason: 'More complex than cache-aside: must manage dual-write logic and handle partial failure scenarios.', factors: ['Dual-write logic must handle failures gracefully', 'Need retry/compensation for partial writes', 'Monitoring must cover both Redis and DB write paths'] },
      'Reliability': { reason: 'Synchronous dual-write means both stores stay in sync, but partial failure (one write succeeds, other fails) needs handling.', factors: ['Both Redis and DB are updated synchronously', 'Partial failure scenario requires retry or compensation logic', 'Cache is always warm — no cold-start risk'] },
      'Portability': { reason: 'Standard Redis, but write-through logic is more tightly coupled to your specific cache + DB setup.', factors: ['Standard RESP protocol', 'Dual-write logic is custom application code', 'Slightly harder to swap cache providers due to consistency requirements'] },
      'Learning Curve': { reason: 'Requires understanding distributed writes, partial failure modes, and consistency guarantees.', factors: ['Dual-write pattern is more nuanced than cache-aside', 'Must understand partial failure scenarios', 'Transaction coordination between Redis and DB is non-trivial'] }
    },
    'write-behind': {
      'Read Perf': { reason: 'Writes go to Redis first (fast), then async to DB. Reads always hit warm cache.', factors: ['All data written to Redis first at memory speed', 'Cache is always warm for recent writes', 'Read performance matches write-through'] },
      'Consistency': { reason: 'Asynchronous DB writes mean data can be lost if Redis crashes before persistence.', factors: ['Async batching means DB lags behind Redis', 'Redis crash = data loss for unpersisted writes', 'No read-your-writes guarantee from the DB layer'] },
      'Cost Efficiency': { reason: 'Batches DB writes for efficiency, but requires Redis persistence config and failure handling.', factors: ['Batch DB writes reduce per-write cost', 'Requires Redis AOF or RDB for crash safety', 'Complex failure recovery adds operational overhead'] },
      'Op. Simplicity': { reason: 'Most complex pattern: async write queues, batch processing, failure recovery, and data loss risk.', factors: ['Must implement async write queue and batch logic', 'Failure recovery is non-trivial (what if batch fails?)', 'Monitoring must detect and alert on write lag'] },
      'Reliability': { reason: 'Async DB writes mean Redis crash loses unpersisted data. The riskiest caching pattern for durability.', factors: ['Redis crash = data loss for buffered writes', 'Async batch failures can silently drop data', 'Requires Redis persistence (AOF/RDB) as safety net'] },
      'Portability': { reason: 'Write-behind logic is entirely custom. Complex enough that switching cache providers means rewriting the async pipeline.', factors: ['Async write queue is custom application code', 'Batch logic is tightly coupled to your specific setup', 'Most complex to migrate between cache providers'] },
      'Learning Curve': { reason: 'Most complex pattern: requires understanding async writes, batch processing, failure recovery, and data loss scenarios.', factors: ['Async write pipeline requires careful error handling', 'Batch processing logic has many edge cases', 'Must understand Redis persistence options (AOF vs RDB)'] }
    }
  },
  'kafka': {
    'single-partition': {
      'Throughput': { reason: 'All messages go through one partition — one broker, one disk, one consumer. Hard ceiling.', factors: ['Single broker handles all writes for the topic', 'Disk I/O bottleneck on one node', 'Consumer cannot parallelize reads'] },
      'Ordering': { reason: 'All messages in one partition are strictly ordered by offset. Perfect ordering guarantee.', factors: ['Single append-only log maintains total order', 'Consumer reads sequentially by offset', 'No cross-partition ordering complexity'] },
      'Scalability': { reason: 'Cannot add consumers or brokers to increase throughput. Scaling requires repartitioning.', factors: ['One partition = one consumer max', 'Cannot horizontally scale without repartitioning', 'Repartitioning breaks existing offset tracking'] },
      'Op. Simplicity': { reason: 'Simple mental model: one log, one consumer, guaranteed order. Easy to reason about.', factors: ['No partition key design needed', 'Consumer offset tracking is straightforward', 'No rebalancing disruption'] },
      'Reliability': { reason: 'Single partition on one broker is a SPOF. If that broker goes down, the entire topic is unavailable.', factors: ['Single broker failure = topic offline', 'Replication factor helps but leader is single point', 'No consumer failover (only one consumer possible)'] },
      'Portability': { reason: 'Open-source Apache Kafka. Runs self-hosted or on managed services (Confluent, AWS MSK, Redpanda).', factors: ['Apache 2.0 license, fully open source', 'Kafka protocol supported by multiple providers', 'Managed alternatives (Confluent, MSK) add proprietary features'] },
      'Learning Curve': { reason: 'Single partition is the simplest Kafka setup: one topic, one consumer, sequential reads.', factors: ['No partition key design complexity', 'Consumer group behavior is straightforward', 'Offset management is simple with one partition'] }
    },
    'multi-partition': {
      'Throughput': { reason: 'Messages distributed across partitions, processed in parallel by consumer group members.', factors: ['Parallel writes across multiple brokers', 'Consumer group members each handle a partition', 'Linear throughput scaling with partition count'] },
      'Ordering': { reason: 'Ordering guaranteed only within a partition. Cross-partition ordering requires application logic.', factors: ['Per-partition ordering only (not global)', 'Partition key determines message placement', 'Cross-partition ordering needs external coordination'] },
      'Scalability': { reason: 'Add partitions and consumers to scale horizontally. Near-linear scaling.', factors: ['Add partitions to distribute load', 'Consumer group auto-assigns partitions', 'Broker cluster can spread partitions across nodes'] },
      'Op. Simplicity': { reason: 'Partition key design is critical and hard to change. Rebalancing causes processing pauses.', factors: ['Partition key choice affects data distribution', 'Consumer rebalancing causes temporary pauses', 'Monitoring per-partition lag adds complexity'] },
      'Reliability': { reason: 'Partitions replicated across brokers. Leader failure triggers automatic failover to replicas.', factors: ['Replication factor ensures data survives broker failure', 'Automatic leader election on broker failure', 'Consumer group rebalancing provides processing resilience'] },
      'Portability': { reason: 'Open-source Kafka, but multi-partition configs are complex enough that managed services add value (and lock-in).', factors: ['Core Kafka is open source', 'Complex configs favor managed services (Confluent, MSK)', 'Schema Registry and Connectors may use proprietary features'] },
      'Learning Curve': { reason: 'Requires deep understanding of partitioning, consumer groups, rebalancing, and offset management.', factors: ['Partition key design requires understanding data access patterns', 'Consumer group rebalancing behavior is complex', 'Offset management and exactly-once semantics are advanced topics'] }
    },
    'compacted-topics': {
      'Throughput': { reason: 'Normal write throughput, but compaction process competes for disk I/O in the background.', factors: ['Writes are normal speed (append-only)', 'Background compaction uses disk I/O and CPU', 'Compaction can temporarily reduce broker throughput'] },
      'Ordering': { reason: 'Per-key ordering maintained, but compaction removes intermediate values (only latest survives).', factors: ['Latest value per key is retained', 'Intermediate states are deleted during compaction', 'Tombstone records needed for key deletion'] },
      'Scalability': { reason: 'Compaction keeps topic size bounded, which helps scaling, but adds operational overhead.', factors: ['Bounded topic size prevents unbounded growth', 'Compaction reduces consumer catch-up time', 'Multiple partitions still supported for parallelism'] },
      'Op. Simplicity': { reason: 'Must design around key semantics, tombstones, and compaction lag. More mental overhead.', factors: ['Key design determines what gets compacted', 'Tombstone management required for deletions', 'Compaction lag means stale values may persist temporarily'] },
      'Reliability': { reason: 'Compaction ensures latest state survives, but misconfigured retention/compaction can silently delete data.', factors: ['Compaction preserves latest value per key (good for state)', 'Misconfigured min.cleanable.dirty.ratio can drop data', 'Tombstone retention must be carefully configured'] },
      'Portability': { reason: 'Open-source Kafka. Compaction is a standard Kafka feature, not provider-specific.', factors: ['Log compaction is a core Kafka feature', 'Available on all Kafka providers and self-hosted', 'Configuration syntax is standard across providers'] },
      'Learning Curve': { reason: 'Hardest Kafka pattern: requires understanding compaction semantics, tombstones, and key-based retention.', factors: ['Compaction behavior is non-intuitive for newcomers', 'Tombstone records and retention windows require careful planning', 'Debugging compaction issues requires deep Kafka knowledge'] }
    }
  }
};

// Component catalog — full list of available components grouped by category
const COMPONENT_CATALOG = {
  'Delivery/Network': [
    { name: 'Nginx', sub: 'Reverse proxy', connectsFrom: ['Clients', 'CDN'], connectsTo: ['Compute'] },
    { name: 'AWS API Gateway', sub: 'Managed gateway', connectsFrom: ['Clients'], connectsTo: ['Compute', 'Auth/Security'] },
    { name: 'Kong', sub: 'Plugin ecosystem', connectsFrom: ['Clients'], connectsTo: ['Compute', 'Auth/Security'] },
    { name: 'Traefik', sub: 'Cloud-native', connectsFrom: ['Clients', 'DevOps'], connectsTo: ['Compute'] },
    { name: 'HAProxy', sub: 'TCP/HTTP LB', connectsFrom: ['Clients'], connectsTo: ['Compute'] },
    { name: 'Envoy', sub: 'Service mesh', connectsFrom: ['Compute'], connectsTo: ['Compute'] },
    { name: 'CloudFront', sub: 'CDN + edge', connectsFrom: ['Clients'], connectsTo: ['Delivery/Network', 'Compute'] }
  ],
  'Compute': [
    { name: 'Node.js', sub: 'Event-driven I/O', connectsFrom: ['Delivery/Network'], connectsTo: ['Data Storage', 'Caching', 'Messaging', 'Search'] },
    { name: 'Go', sub: 'Concurrency', connectsFrom: ['Delivery/Network'], connectsTo: ['Data Storage', 'Caching', 'Messaging'] },
    { name: 'Python FastAPI', sub: 'ML-friendly', connectsFrom: ['Delivery/Network'], connectsTo: ['Data Storage', 'Caching', 'Messaging'] },
    { name: 'Rust Actix', sub: 'Max performance', connectsFrom: ['Delivery/Network'], connectsTo: ['Data Storage', 'Caching', 'Messaging'] },
    { name: 'Java Spring', sub: 'Enterprise', connectsFrom: ['Delivery/Network'], connectsTo: ['Data Storage', 'Caching', 'Messaging'] },
    { name: '.NET / C#', sub: 'Microsoft stack', connectsFrom: ['Delivery/Network'], connectsTo: ['Data Storage', 'Caching', 'Messaging'] }
  ],
  'Data Storage': [
    { name: 'PostgreSQL', sub: 'Relational ACID', connectsFrom: ['Compute'], connectsTo: ['Search', 'Monitoring'] },
    { name: 'MongoDB', sub: 'Document DB', connectsFrom: ['Compute'], connectsTo: ['Search'] },
    { name: 'MySQL', sub: 'Web standard', connectsFrom: ['Compute'], connectsTo: ['Search'] },
    { name: 'CockroachDB', sub: 'Distributed SQL', connectsFrom: ['Compute'], connectsTo: [] },
    { name: 'DynamoDB', sub: 'Serverless NoSQL', connectsFrom: ['Compute'], connectsTo: [] },
    { name: 'Cassandra', sub: 'Wide-column', connectsFrom: ['Compute'], connectsTo: [] }
  ],
  'Caching': [
    { name: 'Redis', sub: 'Data structures', connectsFrom: ['Compute'], connectsTo: ['Real-Time'] },
    { name: 'Memcached', sub: 'Simple cache', connectsFrom: ['Compute'], connectsTo: [] },
    { name: 'KeyDB', sub: 'Multi-thread Redis', connectsFrom: ['Compute'], connectsTo: [] },
    { name: 'Dragonfly', sub: 'Modern cache', connectsFrom: ['Compute'], connectsTo: [] },
    { name: 'Varnish', sub: 'HTTP cache', connectsFrom: ['Delivery/Network'], connectsTo: ['Compute'] }
  ],
  'Messaging': [
    { name: 'Kafka', sub: 'Event streaming', connectsFrom: ['Compute'], connectsTo: ['Compute', 'Data Storage', 'Real-Time'] },
    { name: 'RabbitMQ', sub: 'Classic MQ', connectsFrom: ['Compute'], connectsTo: ['Compute'] },
    { name: 'AWS SQS', sub: 'Managed queue', connectsFrom: ['Compute'], connectsTo: ['Compute'] },
    { name: 'Apache Pulsar', sub: 'Multi-tenant', connectsFrom: ['Compute'], connectsTo: ['Compute', 'Data Storage'] },
    { name: 'NATS', sub: 'Lightweight', connectsFrom: ['Compute'], connectsTo: ['Compute'] }
  ],
  'Real-Time': [
    { name: 'Socket.io', sub: 'WebSocket + fallback', connectsFrom: ['Compute', 'Caching'], connectsTo: ['Clients'] },
    { name: 'Pusher', sub: 'Managed realtime', connectsFrom: ['Compute'], connectsTo: ['Clients'] },
    { name: 'Ably', sub: 'Global pub/sub', connectsFrom: ['Compute'], connectsTo: ['Clients'] },
    { name: 'Centrifugo', sub: 'Self-hosted', connectsFrom: ['Compute', 'Messaging'], connectsTo: ['Clients'] },
    { name: 'SSE Endpoint', sub: 'Server-sent events', connectsFrom: ['Compute'], connectsTo: ['Clients'] }
  ],
  'Auth/Security': [
    { name: 'Auth0', sub: 'Managed auth', connectsFrom: ['Delivery/Network', 'Compute'], connectsTo: ['Data Storage'] },
    { name: 'Keycloak', sub: 'Self-hosted IAM', connectsFrom: ['Delivery/Network'], connectsTo: ['Data Storage'] },
    { name: 'AWS Cognito', sub: 'AWS auth', connectsFrom: ['Delivery/Network'], connectsTo: [] },
    { name: 'Custom JWT', sub: 'In-house', connectsFrom: ['Compute'], connectsTo: ['Caching', 'Data Storage'] },
    { name: 'OAuth2 Proxy', sub: 'Gateway auth', connectsFrom: ['Delivery/Network'], connectsTo: ['Compute'] }
  ],
  'Monitoring': [
    { name: 'Datadog', sub: 'Full observability', connectsFrom: ['All components'], connectsTo: ['Alerting'] },
    { name: 'Grafana + Prometheus', sub: 'OSS metrics', connectsFrom: ['Compute', 'Data Storage'], connectsTo: ['Alerting'] },
    { name: 'ELK Stack', sub: 'Log analytics', connectsFrom: ['All components'], connectsTo: [] },
    { name: 'Jaeger', sub: 'Distributed tracing', connectsFrom: ['Compute'], connectsTo: [] },
    { name: 'Sentry', sub: 'Error tracking', connectsFrom: ['Compute'], connectsTo: ['Alerting'] }
  ],
  'Search': [
    { name: 'Elasticsearch', sub: 'Full-text + analytics', connectsFrom: ['Data Storage', 'Compute'], connectsTo: ['Compute'] },
    { name: 'Algolia', sub: 'Managed search', connectsFrom: ['Compute'], connectsTo: [] },
    { name: 'Meilisearch', sub: 'Fast + simple', connectsFrom: ['Compute'], connectsTo: [] },
    { name: 'Typesense', sub: 'Typo-tolerant', connectsFrom: ['Compute'], connectsTo: [] }
  ],
  'DevOps': [
    { name: 'Docker', sub: 'Containers', connectsFrom: [], connectsTo: ['All components'] },
    { name: 'Kubernetes', sub: 'Orchestration', connectsFrom: ['DevOps'], connectsTo: ['All components'] },
    { name: 'Terraform', sub: 'IaC', connectsFrom: [], connectsTo: ['All components'] },
    { name: 'GitHub Actions', sub: 'CI/CD', connectsFrom: [], connectsTo: ['DevOps'] },
    { name: 'ArgoCD', sub: 'GitOps', connectsFrom: ['DevOps'], connectsTo: ['Compute'] }
  ]
};

// Swap icon SVG
const SWAP_ICON = '<svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M4 6l-2 2 2 2"/><path d="M2 8h10"/><path d="M12 10l2-2-2-2"/><path d="M14 8H4"/></svg>';

// Alternative components per category (for swap feature)
const ALTERNATIVES = {
  'api-gateway':  [
    { id: 'api-gateway', name: 'API Gateway', sub: 'Current' },
    { id: 'traefik', name: 'Traefik', sub: 'Cloud-native' },
    { id: 'envoy', name: 'Envoy Proxy', sub: 'Service mesh' },
    { id: 'haproxy', name: 'HAProxy', sub: 'TCP/HTTP LB' }
  ],
  'nodejs-api': [
    { id: 'nodejs-api', name: 'Node.js API', sub: 'Current' },
    { id: 'go-api', name: 'Go API', sub: 'Concurrency' },
    { id: 'python-api', name: 'Python FastAPI', sub: 'ML-friendly' },
    { id: 'rust-api', name: 'Rust Actix', sub: 'Max perf' }
  ],
  'postgresql': [
    { id: 'postgresql', name: 'PostgreSQL', sub: 'Current' },
    { id: 'mongodb', name: 'MongoDB', sub: 'Document DB' },
    { id: 'mysql', name: 'MySQL', sub: 'Web standard' },
    { id: 'cockroachdb', name: 'CockroachDB', sub: 'Distributed SQL' }
  ],
  'redis': [
    { id: 'redis', name: 'Redis', sub: 'Current' },
    { id: 'memcached', name: 'Memcached', sub: 'Simple cache' },
    { id: 'keydb', name: 'KeyDB', sub: 'Multi-thread Redis' },
    { id: 'dragonfly', name: 'Dragonfly', sub: 'Modern cache' }
  ],
  'kafka': [
    { id: 'kafka', name: 'Kafka', sub: 'Current' },
    { id: 'rabbitmq', name: 'RabbitMQ', sub: 'Classic MQ' },
    { id: 'aws-sqs', name: 'AWS SQS', sub: 'Managed queue' },
    { id: 'pulsar', name: 'Apache Pulsar', sub: 'Multi-tenant' }
  ]
};

// Connection type icons (SVG path data for canvas labels, viewBox 0 0 10 10)
const CONN_TYPE_DEFS = {
  http: { color: '#06b6d4', name: 'HTTP/REST',
    path: 'M1,5H9M7,3l2,2-2,2M3,7L1,5l2-2' },
  database: { color: '#22c55e', name: 'Database',
    path: 'M3,2.5C3,1.5,7,1.5,7,2.5V7.5C7,8.5,3,8.5,3,7.5ZM3,5C3,6,7,6,7,5' },
  cache: { color: '#f97316', name: 'Cache',
    path: 'M6,1L3,5.5H5.2L4,9L7.5,4.5H5.3Z' },
  queue: { color: '#a855f7', name: 'Message Queue',
    path: 'M1,3H6L4.5,1.5M6,3L4.5,4.5M1,7H6L4.5,5.5M6,7L4.5,8.5' }
};

// Category info for info popups
const CATEGORY_INFO = {
  'Compute': {
    desc: 'Application servers that handle business logic, request processing, and service orchestration.',
    role: 'The brain of your architecture — processes requests, runs business rules, and coordinates between services.',
    examples: 'Node.js, Go, Python FastAPI, Java Spring, Rust Actix',
    key: 'Choose based on I/O patterns (event-driven vs thread-per-request), ecosystem needs, and team expertise.'
  },
  'Data Storage': {
    desc: 'Persistent databases for structured data with ACID guarantees and complex query support.',
    role: 'The long-term memory — stores everything that needs to survive restarts: users, messages, settings.',
    examples: 'PostgreSQL, MongoDB, MySQL, CockroachDB, DynamoDB',
    key: 'Choose based on data model (relational vs document), consistency needs, and scaling requirements.'
  },
  'Caching': {
    desc: 'In-memory stores for fast data access, session management, and reducing database load.',
    role: 'The short-term memory — holds frequently accessed data close to compute for sub-millisecond reads.',
    examples: 'Redis, Memcached, KeyDB, Dragonfly',
    key: 'Choose based on data structure needs, persistence requirements, and cache invalidation strategy.'
  },
  'Messaging': {
    desc: 'Event streaming and message queue platforms for asynchronous, decoupled communication.',
    role: 'The nervous system — carries events between services without requiring them to be online simultaneously.',
    examples: 'Kafka, RabbitMQ, AWS SQS, Apache Pulsar, NATS',
    key: 'Choose based on ordering guarantees, throughput needs, and whether you need replay capability.'
  },
  'Delivery/Network': {
    desc: 'API gateways, load balancers, CDNs, and reverse proxies that route and manage network traffic.',
    role: 'The front door — manages how traffic enters your system, applies security policies, and distributes load.',
    examples: 'Nginx, AWS API Gateway, Kong, Traefik, CloudFront',
    key: 'Choose based on routing complexity, auth integration, and whether you need managed vs self-hosted.'
  },
  'Real-Time': {
    desc: 'WebSocket servers, SSE endpoints, and pub/sub systems for live data delivery to clients.',
    role: 'The live wire — pushes updates to clients instantly without polling, enabling chat and live dashboards.',
    examples: 'Socket.io, Pusher, Ably, Centrifugo, Phoenix Channels',
    key: 'Choose based on connection scale, message fanout patterns, and client platform requirements.'
  },
  'Auth/Security': {
    desc: 'Authentication providers, authorization engines, and security infrastructure.',
    role: 'The gatekeeper — verifies identity, enforces permissions, and protects data at rest and in transit.',
    examples: 'Auth0, Keycloak, AWS Cognito, custom JWT, OAuth2',
    key: 'Choose based on auth flow complexity (SSO, MFA), compliance requirements, and team capacity.'
  },
  'Monitoring': {
    desc: 'Observability platforms for metrics, logging, tracing, and alerting across your infrastructure.',
    role: 'The eyes and ears — shows what is happening, what broke, and why, before users report it.',
    examples: 'Datadog, Grafana, Prometheus, ELK Stack, Jaeger',
    key: 'Choose based on data volume, retention needs, and whether you need metrics, logs, traces, or all three.'
  },
  'Search': {
    desc: 'Full-text search engines and indexing systems for fast, relevance-ranked content retrieval.',
    role: 'The librarian — indexes your data for fast, fuzzy, and relevance-ranked search experiences.',
    examples: 'Elasticsearch, Algolia, Meilisearch, Typesense',
    key: 'Choose based on index size, query complexity, and whether you need analytics alongside search.'
  },
  'DevOps': {
    desc: 'CI/CD pipelines, container orchestration, infrastructure-as-code, and deployment automation.',
    role: 'The assembly line — automates building, testing, deploying, and scaling your applications.',
    examples: 'Docker, Kubernetes, Terraform, GitHub Actions, ArgoCD',
    key: 'Choose based on deployment frequency, infrastructure complexity, and team DevOps maturity.'
  }
};

// Dashboard metric category info
const DASHBOARD_INFO = {
  perf: {
    name: 'Performance',
    desc: 'How fast your architecture responds to requests and processes data.',
    metrics: 'Latency (p50/p95/p99), throughput (req/s), response time, TTFB',
    impact: 'Directly affects user experience. Every 100ms of added latency reduces conversion by ~1%. Bottlenecks cascade through connected components.',
    improve: 'Cache hot paths, reduce network hops, use connection pooling, optimize queries, consider async processing.'
  },
  cost: {
    name: 'Cost',
    desc: 'Total cost of ownership including infrastructure, licensing, operations, and engineering time.',
    metrics: 'Monthly infra cost, cost per request, license fees, maintenance hours',
    impact: 'Determines sustainability. Over-provisioning wastes money; under-provisioning causes outages.',
    improve: 'Right-size instances, use spot instances, optimize queries, consider serverless for bursty workloads.'
  },
  rel: {
    name: 'Reliability',
    desc: 'How well your architecture handles failures, maintains uptime, and recovers from incidents.',
    metrics: 'Uptime (99.9% = 8.7h/yr downtime), MTTR, error rates, failover success rate',
    impact: 'Trust and reputation. Every minute of downtime erodes user confidence. Requires redundancy.',
    improve: 'Add redundancy, circuit breakers, health checks, graceful degradation, chaos engineering.'
  },
  ops: {
    name: 'Operational Complexity',
    desc: 'How easy your architecture is to deploy, monitor, debug, and maintain day-to-day.',
    metrics: 'Deploy frequency, change failure rate, MTTR, on-call burden, runbook coverage',
    impact: 'Team productivity and morale. Complex ops mean slower shipping and more incidents.',
    improve: 'Automate deployments, improve observability, reduce moving parts, use managed services.'
  },
  scale: {
    name: 'Scalability',
    desc: 'How well your architecture grows with increasing users, data, and traffic.',
    metrics: 'Max concurrent users, horizontal scale factor, auto-scaling responsiveness',
    impact: 'Growth readiness. Non-scalable architectures force expensive rewrites.',
    improve: 'Stateless services, horizontal scaling, data partitioning, caching layers, queue decoupling.'
  },
  strat: {
    name: 'Strategic Flexibility',
    desc: 'Long-term flexibility including vendor independence, technology currency, and hiring.',
    metrics: 'Vendor lock-in score, technology freshness, community size, migration effort',
    impact: 'Future-proofing. Strategic debt accumulates silently until you need to pivot or hire.',
    improve: 'Use open standards, abstract vendor APIs, keep dependencies current, invest in documentation.'
  },
  dev: {
    name: 'Developer Experience',
    desc: 'How productive and happy developers are when building features and fixing bugs.',
    metrics: 'New dev setup time, build time, test feedback loop, debugging ease, docs quality',
    impact: 'Velocity and retention. Good DX means faster shipping. Bad DX means slow onboarding and turnover.',
    improve: 'Fast local setup, comprehensive tests, good docs, consistent patterns, fast CI/CD feedback.'
  }
};

// Code patterns per component + variant — shows WHAT changes at implementation level
const CODE_PATTERNS = {
  'api-gateway': {
    'nginx': `<span class="cm">// Nginx: manual config files</span>
<span class="kw">upstream</span> api {
  <span class="kw">server</span> api:<span class="num">3000</span>;
}
<span class="kw">server</span> {
  <span class="kw">listen</span> <span class="num">443</span> ssl;
  <span class="kw">location</span> /api/ {
    <span class="fn">proxy_pass</span> http://api;
  }
}`,
    'aws-apigw': `<span class="cm">// AWS API GW: declarative, managed</span>
<span class="kw">const</span> api = <span class="kw">new</span> <span class="fn">RestApi</span>(this, <span class="str">'Api'</span>)
api.<span class="fn">root</span>
  .<span class="fn">addResource</span>(<span class="str">'messages'</span>)
  .<span class="fn">addMethod</span>(<span class="str">'POST'</span>, lambdaIntegration, {
    <span class="fn">authorizer</span>: cognitoAuth,
    <span class="fn">throttle</span>: { rateLimit: <span class="num">1000</span> }
  })`,
    'kong': `<span class="cm">// Kong: plugin-based routing</span>
services:
  - name: <span class="str">api</span>
    url: <span class="str">http://api:3000</span>
    routes:
      - paths: [<span class="str">/api</span>]
    plugins:
      - name: <span class="fn">rate-limiting</span>
        config: { minute: <span class="num">100</span> }
      - name: <span class="fn">jwt</span>`
  },
  'nodejs-api': {
    'express': `<span class="cm">// Express: middleware chain</span>
app.<span class="fn">post</span>(<span class="str">'/messages'</span>,
  <span class="fn">authMiddleware</span>,
  <span class="fn">validate</span>(msgSchema),
  <span class="kw">async</span> (req, res) => {
    <span class="kw">const</span> msg = <span class="kw">await</span> db.<span class="fn">create</span>(req.body)
    res.<span class="fn">json</span>(msg)
  })`,
    'fastify': `<span class="cm">// Fastify: schema-first, 2-3x faster</span>
fastify.<span class="fn">post</span>(<span class="str">'/messages'</span>, {
  schema: { body: <span class="fn">msgSchema</span> },
  preHandler: [<span class="fn">authHook</span>]
}, <span class="kw">async</span> (req) => {
  <span class="kw">return</span> db.<span class="fn">create</span>(req.body)
  <span class="cm">// auto-serialized via schema</span>
})`,
    'nestjs': `<span class="cm">// NestJS: decorators + dependency injection</span>
<span class="fn">@Controller</span>(<span class="str">'messages'</span>)
<span class="kw">class</span> MessagesController {
  <span class="fn">@Post</span>()
  <span class="fn">@UseGuards</span>(AuthGuard)
  <span class="fn">create</span>(<span class="fn">@Body</span>() dto: CreateMsgDto) {
    <span class="kw">return</span> <span class="kw">this</span>.msgService.<span class="fn">create</span>(dto)
  }
}`
  },
  'postgresql': {
    'normalized': `<span class="cm">-- Normalized: relational JOINs</span>
<span class="kw">SELECT</span> m.*, u.name <span class="kw">AS</span> sender
<span class="kw">FROM</span> messages m
<span class="kw">JOIN</span> users u <span class="kw">ON</span> m.sender_id = u.id
<span class="kw">WHERE</span> m.chat_id = <span class="num">?</span>
<span class="kw">ORDER BY</span> m.created_at <span class="kw">DESC</span>
<span class="cm">-- Clean schema, but JOINs at scale</span>`,
    'denormalized': `<span class="cm">-- Denormalized: pre-joined, fast reads</span>
<span class="kw">SELECT</span> *
<span class="kw">FROM</span> chat_messages
<span class="kw">WHERE</span> chat_id = <span class="num">?</span>
<span class="kw">ORDER BY</span> created_at <span class="kw">DESC</span>
<span class="cm">-- sender_name, avatar_url stored</span>
<span class="cm">-- inline — no JOINs needed</span>`,
    'jsonb-hybrid': `<span class="cm">-- JSONB Hybrid: flexible + relational</span>
<span class="kw">SELECT</span> id,
  metadata<span class="fn">->></span><span class="str">'sender'</span> <span class="kw">AS</span> sender,
  metadata<span class="fn">->></span><span class="str">'text'</span> <span class="kw">AS</span> text
<span class="kw">FROM</span> messages
<span class="kw">WHERE</span> chat_id = <span class="num">?</span>
  <span class="kw">AND</span> metadata <span class="fn">@></span> <span class="str">'{"type":"text"}'</span>`
  },
  'redis': {
    'cache-aside': `<span class="cm">// Cache-Aside: app manages cache</span>
<span class="kw">async function</span> <span class="fn">getUser</span>(id) {
  <span class="kw">let</span> user = <span class="kw">await</span> redis.<span class="fn">get</span>(<span class="str">\`user:\${id}\`</span>)
  <span class="kw">if</span> (!user) {
    user = <span class="kw">await</span> db.<span class="fn">findUser</span>(id)
    <span class="kw">await</span> redis.<span class="fn">set</span>(<span class="str">\`user:\${id}\`</span>, user, <span class="str">'EX'</span>, <span class="num">300</span>)
  }
  <span class="kw">return</span> user
}`,
    'write-through': `<span class="cm">// Write-Through: sync both on write</span>
<span class="kw">async function</span> <span class="fn">updateUser</span>(id, data) {
  <span class="kw">await</span> db.<span class="fn">updateUser</span>(id, data)
  <span class="kw">await</span> redis.<span class="fn">set</span>(<span class="str">\`user:\${id}\`</span>, data)
  <span class="cm">// Both always in sync</span>
  <span class="cm">// Higher write latency, no stale reads</span>
  <span class="kw">return</span> data
}`,
    'write-behind': `<span class="cm">// Write-Behind: cache first, DB async</span>
<span class="kw">async function</span> <span class="fn">updateUser</span>(id, data) {
  <span class="kw">await</span> redis.<span class="fn">set</span>(<span class="str">\`user:\${id}\`</span>, data)
  writeQueue.<span class="fn">push</span>({ id, data })
  <span class="cm">// DB updated in background batch</span>
  <span class="cm">// Fast writes, but data loss risk</span>
  <span class="kw">return</span> data
}`
  },
  'kafka': {
    'single-partition': `<span class="cm">// Single Partition: strict global order</span>
producer.<span class="fn">send</span>({
  topic: <span class="str">'messages'</span>,
  partition: <span class="num">0</span>,  <span class="cm">// always partition 0</span>
  value: message
})
<span class="cm">// Consumer: 1 thread reads ALL</span>
<span class="cm">// Ordered but throughput ceiling</span>`,
    'multi-partition': `<span class="cm">// Multi-Partition: key-based parallelism</span>
producer.<span class="fn">send</span>({
  topic: <span class="str">'messages'</span>,
  key: chatId,  <span class="cm">// partition by chat</span>
  value: message
})
<span class="cm">// Consumers: parallel per partition</span>
<span class="cm">// Ordered per-chat, not globally</span>`,
    'compacted-topics': `<span class="cm">// Compacted: latest-state-per-key</span>
producer.<span class="fn">send</span>({
  topic: <span class="str">'user-presence'</span>,
  key: userId,   <span class="cm">// compaction key</span>
  value: { online: <span class="num">true</span>, ts: <span class="fn">now</span>() }
})
<span class="cm">// Only latest value per key kept</span>
<span class="cm">// Old entries auto-deleted</span>`
  }
};

// ═══════════════ DATA ═══════════════
const CATEGORIES = {
  'Compute':          { color: '#3b82f6', shape: 'rectangle' },
  'Data Storage':     { color: '#22c55e', shape: 'cylinder' },
  'Caching':          { color: '#f97316', shape: 'pill' },
  'Messaging':        { color: '#a855f7', shape: 'hexish' },
  'Delivery/Network': { color: '#06b6d4', shape: 'stadium' },
  'Real-Time':        { color: '#ec4899', shape: 'pill' },
  'Auth/Security':    { color: '#ef4444', shape: 'rectangle' },
  'Monitoring':       { color: '#eab308', shape: 'stadium' },
  'Search':           { color: '#14b8a6', shape: 'pill' },
  'DevOps':           { color: '#8b5cf6', shape: 'hexish' }
};

const components = {
  'api-gateway': {
    name: 'API Gateway', category: 'Delivery/Network',
    is: 'Routes and load-balances API traffic to backend services',
    gain: 'Single entry point, SSL termination, rate limiting',
    cost: 'Additional network hop, config complexity',
    position: { x: 330, y: 20 },
    heatStatus: 'green',
    connections: [
      { target: 'nodejs-api', label: 'HTTP/S', connType: 'http', protocol: 'HTTP/1.1 · HTTPS', pattern: 'Request → Response',
        direction: 'API Gateway forwards client requests to the backend API',
        role: 'Reverse Proxy',
        summary: 'All external traffic enters through the gateway, which terminates SSL, applies rate limiting, and proxies valid requests to the Node.js API server. The gateway shields the backend from direct internet exposure.',
        latency: '~1-5ms (reverse proxy hop)', colocatable: true,
        code: `<span class="cm">// Nginx proxies to Node.js</span>\n<span class="kw">upstream</span> api {\n  <span class="kw">server</span> <span class="str">127.0.0.1</span>:<span class="num">3000</span>;\n  <span class="fn">keepalive</span> <span class="num">64</span>;\n}\n<span class="kw">location</span> /api/ {\n  <span class="fn">proxy_pass</span> http://api;\n  <span class="fn">proxy_http_version</span> <span class="num">1.1</span>;\n}` }
    ],
    dataContext: [
      { name: 'SSL Termination', icon: 'ssl', behaviors: {
        'nginx': { fit: 'great', note: 'Native SSL support, near-zero overhead' },
        'aws-apigw': { fit: 'great', note: 'Fully managed, auto-renewed certificates' },
        'kong': { fit: 'good', note: 'SSL via plugin, simple configuration' }
      }},
      { name: 'Rate Limiting', icon: 'ratelimit', behaviors: {
        'nginx': { fit: 'tradeoff', note: 'Config-based only, no dynamic rules' },
        'aws-apigw': { fit: 'great', note: 'Built-in throttling with usage plans' },
        'kong': { fit: 'great', note: 'Rich rate-limiting plugin with policies' }
      }},
      { name: 'Auth Routing', icon: 'route', behaviors: {
        'nginx': { fit: 'poor', note: 'Manual proxy_pass rules, no auth logic' },
        'aws-apigw': { fit: 'great', note: 'Native Cognito/Lambda authorizers' },
        'kong': { fit: 'good', note: 'Auth plugins (JWT, OAuth, OIDC)' }
      }}
    ],
    variants: {
      'nginx': { label: 'Nginx Reverse Proxy',
        metrics: { 'Latency': 88, 'Throughput': 92, 'Cost Efficiency': 85, 'Op. Simplicity': 55, 'Reliability': 70, 'Portability': 95, 'Learning Curve': 55 },
        pros: ['Ultra-low latency','High throughput','Battle-tested'], cons: ['Manual config','No built-in auth'] },
      'aws-apigw': { label: 'AWS API Gateway',
        metrics: { 'Latency': 60, 'Throughput': 70, 'Cost Efficiency': 45, 'Op. Simplicity': 90, 'Reliability': 92, 'Portability': 30, 'Learning Curve': 78 },
        pros: ['Fully managed','Built-in auth','Auto-scaling'], cons: ['Vendor lock-in','Higher latency','Cost at scale'] },
      'kong': { label: 'Kong Gateway',
        metrics: { 'Latency': 75, 'Throughput': 82, 'Cost Efficiency': 65, 'Op. Simplicity': 50, 'Reliability': 75, 'Portability': 80, 'Learning Curve': 45 },
        pros: ['Plugin ecosystem','Open source','Flexible routing'], cons: ['Operational overhead','Learning curve'] }
    },
    currentVariant: 'nginx'
  },
  'nodejs-api': {
    name: 'Node.js API', category: 'Compute',
    is: 'Application server handling business logic and request processing',
    gain: 'Non-blocking I/O, fast JSON processing, huge ecosystem',
    cost: 'Single-threaded CPU bottleneck, callback complexity',
    position: { x: 330, y: 180 },
    heatStatus: 'yellow',
    connections: [
      { target: 'postgresql', label: 'TCP/pg', connType: 'database', protocol: 'PostgreSQL Wire Protocol (TCP:5432)', pattern: 'Connection Pool → Query → Response',
        direction: 'API reads and writes user data, messages, and groups to the database',
        role: 'Primary Data Store',
        summary: 'The API maintains a connection pool to PostgreSQL for all persistent data operations: user profiles, chat history, group metadata. Queries use parameterized SQL to prevent injection. Read-heavy paths may benefit from read replicas.',
        latency: '~1-10ms (query dependent)', colocatable: true,
        code: `<span class="cm">// Node.js → PostgreSQL via connection pool</span>\n<span class="kw">const</span> pool = <span class="kw">new</span> <span class="fn">Pool</span>({\n  host: <span class="str">'localhost'</span>,\n  port: <span class="num">5432</span>,\n  max: <span class="num">20</span>,\n  <span class="fn">idleTimeoutMillis</span>: <span class="num">30000</span>\n})\n<span class="kw">const</span> { rows } = <span class="kw">await</span> pool.<span class="fn">query</span>(\n  <span class="str">'SELECT * FROM messages WHERE chat_id = $1'</span>,\n  [chatId]\n)` },
      { target: 'redis', label: 'RESP', connType: 'cache', protocol: 'RESP (Redis Serialization Protocol, TCP:6379)', pattern: 'GET/SET → Instant Response',
        direction: 'API caches hot data in Redis to avoid hitting the database on every request',
        role: 'Cache Layer',
        summary: 'The API checks Redis before querying PostgreSQL. User sessions, recent messages, and presence data are cached here. Redis also serves as the session store, holding auth tokens with TTL-based expiry.',
        latency: '~0.1-0.5ms (sub-millisecond)', colocatable: true,
        code: `<span class="cm">// Node.js → Redis via ioredis</span>\n<span class="kw">const</span> redis = <span class="kw">new</span> <span class="fn">Redis</span>({\n  host: <span class="str">'127.0.0.1'</span>,\n  port: <span class="num">6379</span>,\n  <span class="fn">maxRetriesPerRequest</span>: <span class="num">3</span>\n})\n<span class="kw">await</span> redis.<span class="fn">set</span>(<span class="str">'session:uid'</span>, data, <span class="str">'EX'</span>, <span class="num">3600</span>)\n<span class="kw">const</span> val = <span class="kw">await</span> redis.<span class="fn">get</span>(<span class="str">'session:uid'</span>)` },
      { target: 'kafka', label: 'Kafka TCP', connType: 'queue', protocol: 'Kafka Binary Protocol (TCP:9092)', pattern: 'Produce → Ack (async)',
        direction: 'API produces events to Kafka for async processing by downstream consumers',
        role: 'Event Producer',
        summary: 'When a user sends a message, the API publishes it to Kafka rather than processing everything synchronously. This decouples the write path: the API confirms receipt quickly, and Kafka distributes the message to delivery, notification, and persistence consumers in parallel.',
        latency: '~5-20ms (broker ack + replication)', colocatable: false,
        code: `<span class="cm">// Node.js → Kafka producer</span>\n<span class="kw">const</span> producer = kafka.<span class="fn">producer</span>()\n<span class="kw">await</span> producer.<span class="fn">connect</span>()\n<span class="kw">await</span> producer.<span class="fn">send</span>({\n  topic: <span class="str">'chat-messages'</span>,\n  messages: [{\n    key: chatId,\n    value: <span class="fn">JSON.stringify</span>(msg),\n    headers: { source: <span class="str">'api'</span> }\n  }]\n})` }
    ],
    dataContext: [
      { name: '/api/auth', icon: 'endpoint', behaviors: {
        'express': { fit: 'good', note: 'Passport.js middleware, manual setup' },
        'fastify': { fit: 'good', note: 'Plugin-based auth, schema validation on input' },
        'nestjs': { fit: 'great', note: 'Guards + decorators, DI-powered auth modules' }
      }},
      { name: '/api/messages', icon: 'endpoint', behaviors: {
        'express': { fit: 'tradeoff', note: 'Manual routing, no schema validation by default' },
        'fastify': { fit: 'great', note: 'Schema-validated input, 2-3x faster serialization' },
        'nestjs': { fit: 'good', note: 'Typed controllers, but framework overhead on hot path' }
      }},
      { name: '/api/groups', icon: 'endpoint', behaviors: {
        'express': { fit: 'good', note: 'Simple CRUD routing, manual validation' },
        'fastify': { fit: 'good', note: 'Schema-driven, typed responses' },
        'nestjs': { fit: 'great', note: 'Module system keeps group logic isolated' }
      }}
    ],
    variants: {
      'express': { label: 'Express.js',
        metrics: { 'Latency': 72, 'Throughput': 68, 'Cost Efficiency': 90, 'Op. Simplicity': 85, 'Reliability': 65, 'Portability': 95, 'Learning Curve': 90 },
        pros: ['Minimal footprint','Huge middleware ecosystem','Easy to learn'], cons: ['No built-in validation','Manual structure'] },
      'fastify': { label: 'Fastify',
        metrics: { 'Latency': 88, 'Throughput': 85, 'Cost Efficiency': 88, 'Op. Simplicity': 70, 'Reliability': 72, 'Portability': 92, 'Learning Curve': 70 },
        pros: ['2-3x faster than Express','Schema validation built-in','Plugin system'], cons: ['Smaller ecosystem','Different patterns'] },
      'nestjs': { label: 'NestJS',
        metrics: { 'Latency': 65, 'Throughput': 62, 'Cost Efficiency': 80, 'Op. Simplicity': 55, 'Reliability': 78, 'Portability': 88, 'Learning Curve': 40 },
        pros: ['Enterprise patterns','TypeScript-first','Dependency injection'], cons: ['Heavier framework','More boilerplate','Steeper learning curve'] }
    },
    currentVariant: 'express'
  },
  'postgresql': {
    name: 'PostgreSQL', category: 'Data Storage',
    is: 'Relational database for structured data with ACID guarantees',
    gain: 'Strong consistency, complex queries, JSON support, mature',
    cost: 'Vertical scaling limits, schema migrations, tuning needed',
    position: { x: 80, y: 380 },
    heatStatus: 'green',
    connections: [],
    dataContext: [
      { name: 'User Profiles', icon: 'session', behaviors: {
        'normalized': { fit: 'great', note: 'Clean relational model, easy joins to roles/prefs' },
        'denormalized': { fit: 'tradeoff', note: 'Fast reads but duplicated across tables' },
        'jsonb-hybrid': { fit: 'good', note: 'Flexible fields (preferences, metadata) in JSONB column' }
      }},
      { name: 'Message History', icon: 'message', behaviors: {
        'normalized': { fit: 'poor', note: 'Complex JOINs for threads, slow at scale (millions of rows)' },
        'denormalized': { fit: 'great', note: 'Pre-joined read model, fast timeline queries' },
        'jsonb-hybrid': { fit: 'good', note: 'Message body as JSONB, metadata as columns' }
      }},
      { name: 'Group Metadata', icon: 'table', behaviors: {
        'normalized': { fit: 'great', note: 'Relational: groups → members → permissions' },
        'denormalized': { fit: 'tradeoff', note: 'Member lists duplicated, update anomalies' },
        'jsonb-hybrid': { fit: 'good', note: 'Settings as JSONB, members as relations' }
      }}
    ],
    variants: {
      'normalized': { label: 'Normalized Schema',
        metrics: { 'Read Perf': 70, 'Write Perf': 85, 'Scalability': 55, 'Op. Simplicity': 65, 'Reliability': 90, 'Portability': 90, 'Learning Curve': 70 },
        pros: ['Data integrity','Less storage','Flexible queries'], cons: ['Complex JOINs','Read latency at scale'] },
      'denormalized': { label: 'Denormalized Schema',
        metrics: { 'Read Perf': 90, 'Write Perf': 50, 'Scalability': 75, 'Op. Simplicity': 45, 'Reliability': 75, 'Portability': 90, 'Learning Curve': 55 },
        pros: ['Fast reads','Fewer JOINs','Better horizontal scaling'], cons: ['Data redundancy','Write complexity','Update anomalies'] },
      'jsonb-hybrid': { label: 'JSONB Hybrid',
        metrics: { 'Read Perf': 78, 'Write Perf': 72, 'Scalability': 65, 'Op. Simplicity': 55, 'Reliability': 82, 'Portability': 78, 'Learning Curve': 55 },
        pros: ['Schema flexibility','Good read/write balance','Document-style queries'], cons: ['Harder to index','Less type safety'] }
    },
    currentVariant: 'normalized'
  },
  'redis': {
    name: 'Redis', category: 'Caching',
    is: 'In-memory data store for caching, sessions, and pub/sub',
    gain: 'Sub-millisecond latency, versatile data structures',
    cost: 'Memory cost, persistence trade-offs, cache invalidation',
    position: { x: 330, y: 380 },
    heatStatus: 'green',
    connections: [
      { target: 'api-gateway', label: 'RESP', connType: 'cache', protocol: 'RESP (TCP:6379)', pattern: 'Rate Limit Check → Allow/Deny',
        direction: 'Redis provides real-time rate limit counters to the API Gateway',
        role: 'Rate Limit Backend',
        summary: 'The gateway checks Redis on every incoming request to enforce rate limits. Redis atomically increments a per-IP or per-user counter with TTL. If the counter exceeds the threshold, the gateway returns 429 without forwarding to the API. This protects the backend from abuse.',
        latency: '~0.1ms (co-located, sub-ms)', colocatable: true, offset: { x: -80, y: -20 },
        code: `<span class="cm">// Redis backs API Gateway rate limiting</span>\n<span class="cm">// Nginx + lua-resty-redis module</span>\n<span class="kw">local</span> redis = <span class="fn">require</span> <span class="str">"resty.redis"</span>\n<span class="kw">local</span> red = redis:<span class="fn">new</span>()\nred:<span class="fn">connect</span>(<span class="str">"127.0.0.1"</span>, <span class="num">6379</span>)\n<span class="kw">local</span> count = red:<span class="fn">incr</span>(key)\n<span class="kw">if</span> count > limit <span class="kw">then</span>\n  <span class="fn">ngx.exit</span>(<span class="num">429</span>)\n<span class="kw">end</span>` }
    ],
    dataContext: [
      { name: 'User Sessions', icon: 'session', behaviors: {
        'cache-aside': { fit: 'great', note: 'Read-heavy, TTL-based expiry is perfect for sessions' },
        'write-through': { fit: 'good', note: 'Always fresh session data, slight write overhead' },
        'write-behind': { fit: 'risky', note: 'Session data could be lost on Redis failure' }
      }},
      { name: 'Rate Limit Counters', icon: 'counter', behaviors: {
        'cache-aside': { fit: 'poor', note: 'Write-heavy — counters bypass cache on every increment' },
        'write-through': { fit: 'tradeoff', note: 'Accurate but adds write latency per request' },
        'write-behind': { fit: 'great', note: 'Fast atomic increments, batch persist to DB' }
      }},
      { name: 'Message Cache', icon: 'cache_item', behaviors: {
        'cache-aside': { fit: 'great', note: 'Read-heavy: cache recent messages, miss on new only' },
        'write-through': { fit: 'great', note: 'Always warm, new messages instantly cached' },
        'write-behind': { fit: 'good', note: 'Fast writes, but eventual consistency on reads' }
      }}
    ],
    variants: {
      'cache-aside': { label: 'Cache-Aside Pattern',
        metrics: { 'Read Perf': 92, 'Consistency': 60, 'Cost Efficiency': 75, 'Op. Simplicity': 80, 'Reliability': 78, 'Portability': 90, 'Learning Curve': 85 },
        pros: ['Simple pattern','App controls cache','Resilient to cache failure'], cons: ['Stale data possible','Cache miss penalty','Manual invalidation'] },
      'write-through': { label: 'Write-Through Cache',
        metrics: { 'Read Perf': 95, 'Consistency': 90, 'Cost Efficiency': 55, 'Op. Simplicity': 60, 'Reliability': 82, 'Portability': 85, 'Learning Curve': 62 },
        pros: ['Strong consistency','Always warm cache','No stale reads'], cons: ['Write latency increase','Higher complexity','More memory usage'] },
      'write-behind': { label: 'Write-Behind (Async)',
        metrics: { 'Read Perf': 95, 'Consistency': 40, 'Cost Efficiency': 65, 'Op. Simplicity': 40, 'Reliability': 45, 'Portability': 80, 'Learning Curve': 38 },
        pros: ['Fast writes','Batch DB updates','Reduced DB load'], cons: ['Data loss risk','Complex failure handling','Eventual consistency'] }
    },
    currentVariant: 'cache-aside'
  },
  'kafka': {
    name: 'Kafka', category: 'Messaging',
    is: 'Distributed event streaming platform for async messaging',
    gain: 'High throughput, durability, replay, decoupled services',
    cost: 'Operational complexity, Zookeeper dependency, learning curve',
    position: { x: 590, y: 380 },
    heatStatus: 'red',
    connections: [
      { target: 'nodejs-api', label: 'Consumer', connType: 'queue', protocol: 'Kafka Binary Protocol (TCP:9092)', pattern: 'Poll → Batch Consume → Commit Offset',
        direction: 'Kafka delivers queued events back to the API for processing (consumer group)',
        role: 'Event Consumer',
        summary: 'A separate Node.js consumer process polls Kafka for new events: incoming messages to route, read receipts to acknowledge, presence updates to broadcast. The consumer runs independently from the API server — it pulls work at its own pace and commits offsets after successful processing.',
        latency: '~10-100ms (batch poll interval)', colocatable: false, offset: { x: 100, y: -30 },
        code: `<span class="cm">// Kafka → Node.js consumer</span>\n<span class="kw">const</span> consumer = kafka.<span class="fn">consumer</span>({\n  groupId: <span class="str">'msg-processor'</span>\n})\n<span class="kw">await</span> consumer.<span class="fn">subscribe</span>({\n  topic: <span class="str">'chat-messages'</span>\n})\n<span class="kw">await</span> consumer.<span class="fn">run</span>({\n  <span class="fn">eachMessage</span>: <span class="kw">async</span> ({ message }) => {\n    <span class="kw">await</span> <span class="fn">processMessage</span>(message)\n  }\n})` },
      { target: 'postgresql', label: 'Sink', connType: 'database', protocol: 'Kafka Connect JDBC (or consumer → SQL)', pattern: 'Consume → Batch INSERT',
        direction: 'Kafka persists events to PostgreSQL for long-term storage and querying',
        role: 'Event Persistence Sink',
        summary: 'A Kafka Connect JDBC sink (or a dedicated consumer) writes events to PostgreSQL in batches. This ensures all messages are durably stored even if the API had only acknowledged them to the sender. The batch approach reduces database write pressure compared to per-message INSERTs.',
        latency: '~50-500ms (batch write interval)', colocatable: false,
        code: `<span class="cm">// Kafka → PostgreSQL persistence</span>\n<span class="cm">// Option A: Kafka Connect JDBC Sink</span>\n{\n  <span class="str">"connector.class"</span>: <span class="str">"JdbcSinkConnector"</span>,\n  <span class="str">"topics"</span>: <span class="str">"chat-messages"</span>,\n  <span class="str">"connection.url"</span>: <span class="str">"jdbc:postgresql://db:5432/app"</span>,\n  <span class="str">"insert.mode"</span>: <span class="str">"upsert"</span>,\n  <span class="str">"batch.size"</span>: <span class="num">100</span>\n}` }
    ],
    dataContext: [
      { name: 'Chat Messages', icon: 'message', behaviors: {
        'single-partition': { fit: 'tradeoff', note: 'Strict ordering preserved, but throughput ceiling hit fast' },
        'multi-partition': { fit: 'great', note: 'Partition by chat_id: ordered per-chat, parallel across chats' },
        'compacted-topics': { fit: 'poor', note: 'Messages are append-only — compaction deletes history' }
      }},
      { name: 'Read Receipts', icon: 'receipt', behaviors: {
        'single-partition': { fit: 'poor', note: 'Massive volume bottleneck — receipts per message per user' },
        'multi-partition': { fit: 'great', note: 'Parallel processing, partition by user or chat' },
        'compacted-topics': { fit: 'great', note: 'Only latest receipt per key — natural fit' }
      }},
      { name: 'Presence Updates', icon: 'presence', behaviors: {
        'single-partition': { fit: 'poor', note: 'Extremely write-heavy, single partition = bottleneck' },
        'multi-partition': { fit: 'good', note: 'Partition by user, but ordering less critical' },
        'compacted-topics': { fit: 'great', note: 'Latest online/offline per user — perfect for compaction' }
      }}
    ],
    variants: {
      'single-partition': { label: 'Single Partition',
        metrics: { 'Throughput': 50, 'Ordering': 95, 'Scalability': 30, 'Op. Simplicity': 75, 'Reliability': 58, 'Portability': 80, 'Learning Curve': 68 },
        pros: ['Guaranteed ordering','Simple consumer logic','Easy to reason about'], cons: ['No parallelism','Throughput ceiling','Single point of bottleneck'] },
      'multi-partition': { label: 'Multi-Partition',
        metrics: { 'Throughput': 92, 'Ordering': 45, 'Scalability': 90, 'Op. Simplicity': 45, 'Reliability': 88, 'Portability': 75, 'Learning Curve': 35 },
        pros: ['High throughput','Horizontal scaling','Consumer parallelism'], cons: ['No global ordering','Partition key design critical','Rebalancing disruption'] },
      'compacted-topics': { label: 'Compacted Topics',
        metrics: { 'Throughput': 70, 'Ordering': 60, 'Scalability': 70, 'Op. Simplicity': 50, 'Reliability': 75, 'Portability': 75, 'Learning Curve': 30 },
        pros: ['State snapshots','Reduced storage','Fast consumer recovery'], cons: ['Compaction lag','Key required','Tombstone management'] }
    },
    currentVariant: 'single-partition'
  }
};

const dashboardCategories = [
  { name: 'Perf', key: 'perf', icon: 'perf' },
  { name: 'Cost', key: 'cost', icon: 'cost_dash' },
  { name: 'Reliab', key: 'rel', icon: 'rel' },
  { name: 'Ops', key: 'ops', icon: 'ops' },
  { name: 'Scale', key: 'scale', icon: 'scale' },
  { name: 'Strat', key: 'strat', icon: 'strat' },
  { name: 'Dev', key: 'dev', icon: 'dev_dash' }
];

// Maps each component metric to a dashboard category key
const METRIC_TO_CATEGORY = {
  'Latency': 'perf',
  'Throughput': 'perf',
  'Read Perf': 'perf',
  'Write Perf': 'perf',
  'Cost Efficiency': 'cost',
  'Reliability': 'rel',
  'Consistency': 'rel',
  'Ordering': 'rel',
  'Op. Simplicity': 'ops',
  'Scalability': 'scale',
  'Portability': 'strat',
  'Learning Curve': 'dev'
};

// ═══════════════ STATE ═══════════════
const state = {
  selectedNode: null,
  selectedConnection: null, // { sourceId, targetId }
  heatmapEnabled: false,
  toolboxTab: 'components',
  swapOpenNode: null,
  variantOpenNode: null,
  // Node drag state
  dragging: null,    // node id being dragged
  dragStart: null,   // { mx, my, nx, ny } mouse + node start positions
  dragMoved: false,  // true if mouse actually moved (to distinguish click vs drag)
  // Connection label drag state
  draggingConn: null,  // { sourceId, targetId, connIdx }
  connDragStart: null, // { mx, my, ox, oy } mouse + original offset
  // Collapsible section state
  collapsedSections: new Set(),
  lastDeltas: {},
  deltaTimeout: null,
  issuesOpen: false,
  flowParticles: [],
  flowAnimationId: null,
  hiddenMetrics: new Set(['Reliability', 'Portability', 'Learning Curve']),
  metricFilterOpen: false,
  inspSwapOpen: false,
  inspVariantOpen: false,
  dashboardExpanded: false
};
let connectionPathData = [];

// ═══════════════ HELPER FUNCTIONS ═══════════════

function getMetricColor(value) {
  if (value >= 70) return 'var(--green)';
  if (value >= 40) return 'var(--yellow)';
  return 'var(--red)';
}

function getHeatColor(status) {
  if (status === 'green') return 'var(--green)';
  if (status === 'yellow') return 'var(--yellow)';
  return 'var(--red)';
}

function getConnectionHealth(srcId, tgtId) {
  const src = components[srcId];
  const tgt = components[tgtId];
  // Worst of the two endpoints
  const priority = { 'red': 0, 'yellow': 1, 'green': 2 };
  return priority[src.heatStatus] <= priority[tgt.heatStatus] ? src.heatStatus : tgt.heatStatus;
}

const HEALTH_LABELS = {
  green: { label: 'Healthy', color: 'var(--green)', icon: 'gain',
    desc: 'Both endpoints are performing well. This connection is not a bottleneck — data flows efficiently between these components.' },
  yellow: { label: 'Warning', color: 'var(--yellow)', icon: 'Monitoring',
    desc: 'One or both endpoints have degraded metrics. This connection may become a bottleneck under load. Consider optimizing the weaker endpoint or adjusting its configuration variant.' },
  red: { label: 'Bottleneck', color: 'var(--red)', icon: 'cons',
    desc: 'One or both endpoints are critically underperforming. This connection is likely a system bottleneck. The weakest endpoint constrains the entire path — improving it will have the most impact.' }
};

function buildEndpointMetricDetail(nodeId, panelId) {
  const c = components[nodeId];
  const metrics = c.variants[c.currentVariant].metrics;
  const entries = Object.entries(metrics);
  const belowThreshold = entries.filter(([, v]) => v < 70);
  const causeText = belowThreshold.length === 0
    ? '<div style="font-size:10px;color:var(--green);margin-bottom:4px">All metrics above threshold</div>'
    : `<div class="conn-health-metrics-label">${belowThreshold.length} metric${belowThreshold.length > 1 ? 's' : ''} below threshold (70)</div>`;
  return `<div class="conn-health-metrics" id="${panelId}">
    ${causeText}
    ${entries.map(([name, val]) => {
      const color = getMetricColor(val);
      const isCause = val < 70;
      return `<div class="conn-health-metric-row">
        <span class="conn-health-metric-flag" style="color:${isCause ? 'var(--red)' : 'transparent'}">${isCause ? '!' : ''}</span>
        <span class="conn-health-metric-name" style="${isCause ? 'color:var(--text-primary);font-weight:500' : ''}">${name}</span>
        <div class="conn-health-metric-bar">
          <div class="conn-health-metric-fill" style="width:${val}%;background:${color}"></div>
        </div>
        <span class="conn-health-metric-val" style="color:${color}">${val}</span>
      </div>`;
    }).join('')}
  </div>`;
}

function toggleConnHealthDetail(panelId, event) {
  if (event) event.stopPropagation();
  const el = document.getElementById(panelId);
  if (el) el.classList.toggle('visible');
}

function renderConnectionHealth(srcId, tgtId) {
  const health = getConnectionHealth(srcId, tgtId);
  const h = HEALTH_LABELS[health];
  const src = components[srcId];
  const tgt = components[tgtId];
  const srcH = HEALTH_LABELS[src.heatStatus];
  const tgtH = HEALTH_LABELS[tgt.heatStatus];
  const infoIcon = `<svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><circle cx="8" cy="8" r="6"/><path d="M8 7v4M8 5v.5"/></svg>`;
  const content = `<div class="conn-health-indicator">
      <div class="conn-health-badge" style="background:${h.color}20;color:${h.color};border:1px solid ${h.color}40">
        <span class="conn-health-dot" style="background:${h.color}"></span> ${h.label}
      </div>
      <div class="conn-health-desc">${h.desc}</div>
      <div class="conn-health-endpoints">
        <div>
          <div class="conn-health-ep" style="cursor:pointer" title="Inspect ${src.name}">
            <span class="conn-health-dot" style="background:${srcH.color}"></span>
            <span onclick="selectNode('${srcId}')" style="text-decoration:underline;text-decoration-style:dotted;cursor:pointer">${src.name}</span>
            <span style="color:${srcH.color};font-weight:600;margin-left:auto">${srcH.label}</span>
            <button class="conn-health-info-btn" onclick="toggleConnHealthDetail('chd-${srcId}', event)" title="Show metric details">${infoIcon}</button>
          </div>
          ${buildEndpointMetricDetail(srcId, 'chd-' + srcId)}
        </div>
        <div>
          <div class="conn-health-ep" style="cursor:pointer" title="Inspect ${tgt.name}">
            <span class="conn-health-dot" style="background:${tgtH.color}"></span>
            <span onclick="selectNode('${tgtId}')" style="text-decoration:underline;text-decoration-style:dotted;cursor:pointer">${tgt.name}</span>
            <span style="color:${tgtH.color};font-weight:600;margin-left:auto">${tgtH.label}</span>
            <button class="conn-health-info-btn" onclick="toggleConnHealthDetail('chd-${tgtId}', event)" title="Show metric details">${infoIcon}</button>
          </div>
          ${buildEndpointMetricDetail(tgtId, 'chd-' + tgtId)}
        </div>
      </div>
      <div class="conn-health-rule">Health = worst of the two endpoints</div>
    </div>`;
  return collapsible('conn-health', 'Monitoring', 'var(--text-secondary)', 'Connection Health', content);
}

function icon(name, color) {
  const svg = ICONS[name] || '';
  if (color) return svg.replace(/stroke="currentColor"/g, `stroke="${color}"`);
  return svg;
}

// ═══════════════ COLLAPSIBLE HELPER ═══════════════

function toggleInspSwap(event) {
  if (event) event.stopPropagation();
  state.inspVariantOpen = false;
  state.inspSwapOpen = !state.inspSwapOpen;
  renderInspector();
  if (state.inspSwapOpen) positionInspDropdown('.insp-swap-btn', '.insp-header-dropdown.swap');
}

function toggleInspVariant(event) {
  if (event) event.stopPropagation();
  state.inspSwapOpen = false;
  state.inspVariantOpen = !state.inspVariantOpen;
  renderInspector();
  if (state.inspVariantOpen) positionInspDropdown('.insp-variant-btn', '.insp-header-dropdown.variant');
}

function positionInspDropdown(btnSelector, menuSelector) {
  const btn = document.querySelector(btnSelector);
  const menu = document.querySelector(menuSelector);
  if (!btn || !menu) return;
  const rect = btn.getBoundingClientRect();
  menu.style.top = (rect.bottom + 4) + 'px';
  // For swap dropdown, align left; for variant, align right
  if (menuSelector.includes('swap')) {
    menu.style.left = rect.left + 'px';
  } else {
    menu.style.right = (window.innerWidth - rect.right) + 'px';
  }
}

function inspSwapComponent(newId, event) {
  if (event) event.stopPropagation();
  state.inspSwapOpen = false;
  swapComponent(state.selectedNode, newId);
}

function inspChangeVariant(variantKey, event) {
  if (event) event.stopPropagation();
  state.inspVariantOpen = false;
  changeVariant(state.selectedNode, variantKey);
}

function toggleMetricFilter(event) {
  if (event) event.stopPropagation();
  state.metricFilterOpen = !state.metricFilterOpen;
  renderInspector();
  if (state.metricFilterOpen) {
    positionMetricFilterMenu();
  }
}

function positionMetricFilterMenu() {
  const btn = document.querySelector('.metric-filter-btn');
  const menu = document.querySelector('.metric-filter-menu');
  if (!btn || !menu) return;
  const rect = btn.getBoundingClientRect();
  menu.style.top = (rect.bottom + 4) + 'px';
  menu.style.right = (window.innerWidth - rect.right) + 'px';
}

function toggleMetricVisibility(metricName, event) {
  if (event) event.stopPropagation();
  if (state.hiddenMetrics.has(metricName)) {
    state.hiddenMetrics.delete(metricName);
  } else {
    state.hiddenMetrics.add(metricName);
  }
  renderInspector();
  if (state.metricFilterOpen) positionMetricFilterMenu();
}

function setAllMetrics(show, event) {
  if (event) event.stopPropagation();
  const c = components[state.selectedNode];
  const v = c.variants[c.currentVariant];
  if (show) {
    Object.keys(v.metrics).forEach(name => state.hiddenMetrics.delete(name));
  } else {
    Object.keys(v.metrics).forEach(name => state.hiddenMetrics.add(name));
  }
  renderInspector();
  if (state.metricFilterOpen) positionMetricFilterMenu();
}

function toggleMetricExplanation(panelId, event) {
  if (event) event.stopPropagation();
  const el = document.getElementById(panelId);
  if (!el) return;
  // Close other open metric explanations first
  document.querySelectorAll('.metric-explanation.visible').forEach(other => {
    if (other.id !== panelId) other.classList.remove('visible');
  });
  el.classList.toggle('visible');
}

function toggleSection(sectionId) {
  if (state.collapsedSections.has(sectionId)) {
    state.collapsedSections.delete(sectionId);
  } else {
    state.collapsedSections.add(sectionId);
  }
  const body = document.getElementById(sectionId);
  if (body) body.classList.toggle('collapsed');
  const title = document.querySelector(`[data-toggle="${sectionId}"]`);
  if (title) {
    const chev = title.querySelector('.section-chevron');
    if (chev) chev.classList.toggle('open');
  }
}

function collapsible(id, titleIcon, titleColor, titleText, content) {
  const isCollapsed = state.collapsedSections.has(id);
  return `<div class="insp-section">
    <div class="insp-section-title collapsible" data-toggle="${id}" onclick="toggleSection('${id}')">
      ${icon(titleIcon, titleColor)} ${titleText}
      <span class="section-chevron ${isCollapsed ? '' : 'open'}">${icon('chevron', 'var(--text-secondary)')}</span>
    </div>
    <div class="insp-section-body ${isCollapsed ? 'collapsed' : ''}" id="${id}">${content}</div>
  </div>`;
}

// ═══════════════ RENDER FUNCTIONS ═══════════════

function renderLegend() {
  const el = document.getElementById('canvasLegend');
  if (state.heatmapEnabled) {
    el.innerHTML = `
      <div class="legend-title">${icon('Monitoring', 'var(--text-secondary)')} Health Overlay</div>
      <div class="legend-item"><div class="legend-dot" style="border-color:var(--green)"></div> Healthy</div>
      <div class="legend-item"><div class="legend-dot" style="border-color:var(--yellow)"></div> Warning</div>
      <div class="legend-item"><div class="legend-dot" style="border-color:var(--red)"></div> Bottleneck</div>
      <div class="legend-divider"></div>
      <div class="legend-item"><div class="legend-swatch" style="background:var(--green)"></div> Line: healthy</div>
      <div class="legend-item"><div class="legend-swatch" style="background:var(--yellow);height:2px;border-top:1px dashed var(--yellow)"></div> Line: warning</div>
      <div class="legend-item"><div class="legend-swatch" style="background:var(--red);height:2px;border-top:1px dashed var(--red)"></div> Line: bottleneck</div>
    `;
  } else {
    // Show category legend for visible categories
    const usedCats = new Set(Object.values(components).map(c => c.category));
    el.innerHTML = `
      <div class="legend-title">${icon('Search', 'var(--text-secondary)')} Component Types</div>
      ${[...usedCats].map(cat => `<div class="legend-item clickable" onclick="showCategoryInfo('${cat}')" title="About ${cat}">${icon(cat, CATEGORIES[cat].color)} <span style="color:var(--text-secondary)">${cat}</span></div>`).join('')}
    `;
  }
}

function renderToolbox() {
  const el = document.getElementById('toolboxContent');
  if (state.toolboxTab === 'components') {
    // Build a set of component names currently on canvas
    const onCanvas = new Set(Object.values(components).map(c => c.name));

    el.innerHTML = Object.entries(COMPONENT_CATALOG).map(([catName, items]) => {
      const cat = CATEGORIES[catName];
      const info = CATEGORY_INFO[catName];
      const groupId = `catgrp-${catName.replace(/[^a-zA-Z]/g, '')}`;
      const isCollapsed = state.collapsedSections.has(groupId);
      const activeCount = items.filter(i => onCanvas.has(i.name)).length;

      return `<div class="cat-group">
        <div class="cat-group-header" onclick="toggleSection('${groupId}')" data-toggle="${groupId}">
          ${icon(catName, cat.color)}
          <span class="cat-group-name" style="color:${cat.color}">${catName}</span>
          ${activeCount ? `<span class="cat-item-active">${activeCount} in use</span>` : ''}
          <span class="cat-group-count">${items.length}</span>
          <span class="section-chevron ${isCollapsed ? '' : 'open'}">${icon('chevron', 'var(--text-secondary)')}</span>
        </div>
        <div class="cat-group-body ${isCollapsed ? 'collapsed' : ''}" id="${groupId}">
          ${info ? `<div class="cat-group-desc">${info.role}</div>` : ''}
          ${items.map(item => {
            const isActive = onCanvas.has(item.name);
            const fromTags = item.connectsFrom.map(t => `<span class="cat-item-tip-tag">${t}</span>`).join('');
            const toTags = item.connectsTo.map(t => `<span class="cat-item-tip-tag">${t}</span>`).join('');
            // Find the canvas node id if this component is on canvas
            const canvasId = Object.entries(components).find(([, c]) => c.name === item.name)?.[0];
            return `<div class="cat-item${isActive ? ' active-item' : ''}" ${canvasId ? `ondblclick="selectNode('${canvasId}')"` : ''}>
              <span class="cat-item-dot" style="background:${cat.color}${isActive ? '' : '60'}"></span>
              <span class="cat-item-name">${item.name}</span>
              ${isActive ? '<span class="cat-item-active">ON CANVAS</span>' : ''}
              <span class="cat-item-sub">${item.sub}</span>
              <div class="cat-item-tip">
                <strong>${item.name}</strong> <span style="color:var(--text-secondary)">· ${item.sub}</span>
                ${item.connectsFrom.length ? `<div class="cat-item-tip-label">Receives from</div><div class="cat-item-tip-list">${fromTags}</div>` : ''}
                ${item.connectsTo.length ? `<div class="cat-item-tip-label">Connects to</div><div class="cat-item-tip-list">${toTags}</div>` : ''}
              </div>
            </div>`;
          }).join('')}
        </div>
      </div>`;
    }).join('');
  } else if (state.toolboxTab === 'stacks') {
    el.innerHTML = `<div class="component-card" style="border-left-color:var(--accent)">
      <div class="card-header">
        <div class="card-icon">${icon('Messaging', 'var(--accent)')}</div>
        <div><div class="card-name">Real-Time Messaging Stack</div><div class="card-category">${icon('Messaging', 'var(--accent)')} 5 components</div></div></div>
      <div class="card-section"><div class="card-section-label card-is">${icon('is', 'var(--text-secondary)')} IS</div>Pre-wired stack for real-time message delivery with persistence and caching</div>
      <div class="card-section"><div class="card-section-label card-gain">${icon('gain', 'var(--green)')} GAIN</div>Complete messaging pipeline, proven pattern</div>
      <div class="card-section"><div class="card-section-label card-cost">${icon('cost', 'var(--yellow)')} COST</div>Full Kafka + Redis operational burden</div>
    </div>
    <div class="component-card" style="border-left-color:var(--cat-auth)">
      <div class="card-header">
        <div class="card-icon">${icon('Auth/Security', 'var(--cat-auth)')}</div>
        <div><div class="card-name">Auth Stack</div><div class="card-category">${icon('Auth/Security', 'var(--cat-auth)')} 3 components</div></div></div>
      <div class="card-section"><div class="card-section-label card-is">${icon('is', 'var(--text-secondary)')} IS</div>Authentication and authorization with JWT, rate limiting, and session store</div>
    </div>`;
  } else {
    el.innerHTML = `<div class="component-card" style="border-left-color:var(--accent)">
      <div class="card-header">
        <div class="card-icon">${icon('Delivery/Network', 'var(--accent)')}</div>
        <div><div class="card-name">WhatsApp Architecture</div><div class="card-category">${icon('Monitoring', 'var(--accent)')} Tier 2 · 5 components</div></div></div>
      <div class="card-section"><div class="card-section-label card-is">${icon('is', 'var(--text-secondary)')} IS</div>Real-time messaging with persistent storage, caching layer, and event streaming</div>
    </div>
    <div class="component-card" style="border-left-color:var(--cat-realtime)">
      <div class="card-header">
        <div class="card-icon">${icon('Real-Time', 'var(--cat-realtime)')}</div>
        <div><div class="card-name">Telegram Architecture</div><div class="card-category">${icon('Monitoring', 'var(--cat-realtime)')} Tier 2 · 6 components</div></div></div>
      <div class="card-section"><div class="card-section-label card-is">${icon('is', 'var(--text-secondary)')} IS</div>Multi-datacenter messaging with MTProto, distributed file storage, and bot platform</div>
    </div>`;
  }
}

const VARIANT_ICON = '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.5"><circle cx="6" cy="6" r="2"/><path d="M6 1v2M6 9v2M1 6h2M9 6h2"/></svg>';

function renderNodes() {
  const container = document.getElementById('nodesContainer');
  container.innerHTML = Object.entries(components).map(([id, c]) => {
    const cat = CATEGORIES[c.category];
    const v = c.variants[c.currentVariant];
    const allMetrics = Object.entries(v.metrics);
    const visibleMetrics = allMetrics.filter(([k]) => !state.hiddenMetrics.has(k));
    const isSelected = state.selectedNode === id;
    let heatClass = '';
    if (state.heatmapEnabled) heatClass = `heatmap-${c.heatStatus}`;
    const alts = ALTERNATIVES[id] || [];
    const swapOpen = state.swapOpenNode === id;
    const variantOpen = state.variantOpenNode === id;
    const variantKeys = Object.keys(c.variants);
    const hasDropdown = swapOpen || variantOpen;
    return `<div class="node ${isSelected ? 'selected' : ''} ${heatClass}" id="node-${id}"
      data-shape="${cat.shape}" data-node-id="${id}"
      style="left:${c.position.x}px;top:${c.position.y}px;border-top:3px solid ${cat.color}${hasDropdown ? ';z-index:15' : ''}"
      onmousedown="startDrag(event, '${id}')">
      <div class="node-tooltip">
        <div class="tooltip-header">${icon(c.category, cat.color)} <strong>${c.name}</strong> · <span style="color:var(--text-secondary)">${c.category}</span></div>
        <div class="tooltip-metrics">
          ${visibleMetrics.slice(0,4).map(([k,val]) => `<div class="tooltip-metric">${k}: <span>${val}</span></div>`).join('')}
        </div>
      </div>
      <div class="node-body">
        <div class="node-header">
          <div class="node-icon clickable" onclick="event.stopPropagation(); ${alts.length > 1 ? `toggleSwapDropdown('${id}')` : `showCategoryInfo('${c.category}')`}" title="${alts.length > 1 ? 'Swap component' : 'About ' + c.category}">${icon(c.category, cat.color)}</div>
          <div class="node-name">${c.name}</div>
        </div>
        ${swapOpen ? `<div class="node-dropdown left" onclick="event.stopPropagation()">
          ${alts.map(a => `<div class="swap-option ${a.id === id ? 'current' : ''}" onclick="swapComponent('${id}', '${a.id}')">
            ${icon(c.category, cat.color)} ${a.name} <span class="swap-option-sub">${a.sub}</span>
          </div>`).join('')}
        </div>` : ''}
        ${variantKeys.length > 1 ? `<div class="node-variant-btn" onclick="event.stopPropagation(); toggleVariantDropdown('${id}')" title="Change configuration variant">${VARIANT_ICON}</div>` : ''}
        ${variantOpen ? `<div class="node-dropdown right" onclick="event.stopPropagation()">
          ${variantKeys.map(vk => {
            const vl = c.variants[vk];
            return `<div class="swap-option ${vk === c.currentVariant ? 'current' : ''}" onclick="changeVariantFromNode('${id}', '${vk}')">
              ${VARIANT_ICON} ${vl.label} ${vk === c.currentVariant ? '<span class="swap-option-sub">Current</span>' : ''}
            </div>`;
          }).join('')}
        </div>` : ''}
        <div class="node-variant">${v.label}</div>
        <div class="node-mini-metrics">
          ${visibleMetrics.map(([k,val]) => `<div class="node-mini-bar"><div class="node-mini-fill" style="width:${val}%;background:${getMetricColor(val)}"></div></div>`).join('')}
        </div>
      </div>
    </div>`;
  }).join('');
}

function renderConnections() {
  connectionPathData = [];
  const svg = document.getElementById('canvasSvg');
  let defs = `<defs>
    <marker id="arrowDefault" markerWidth="8" markerHeight="6" refX="8" refY="3" orient="auto"><path d="M0,0 L8,3 L0,6" fill="var(--border)"/></marker>
    <marker id="arrowGreen" markerWidth="8" markerHeight="6" refX="8" refY="3" orient="auto"><path d="M0,0 L8,3 L0,6" fill="var(--green)"/></marker>
    <marker id="arrowYellow" markerWidth="8" markerHeight="6" refX="8" refY="3" orient="auto"><path d="M0,0 L8,3 L0,6" fill="var(--yellow)"/></marker>
    <marker id="arrowRed" markerWidth="8" markerHeight="6" refX="8" refY="3" orient="auto"><path d="M0,0 L8,3 L0,6" fill="var(--red)"/></marker>
    <marker id="arrowAccent" markerWidth="8" markerHeight="6" refX="8" refY="3" orient="auto"><path d="M0,0 L8,3 L0,6" fill="var(--accent)"/></marker>
  </defs>`;
  let paths = '';
  let labels = '';
  Object.entries(components).forEach(([id, c]) => {
    c.connections.forEach((conn, ci) => {
      const targetId = conn.target;
      const src = c.position;
      const tgt = components[targetId].position;
      const sx = src.x + 76, sy = src.y + 50;
      const tx = tgt.x + 76, ty = tgt.y + 10;
      const baseMx = (sx + tx) / 2, baseMy = (sy + ty) / 2;
      // Offset defines where the LABEL sits (on the curve at t=0.5)
      if (!conn.offset) conn.offset = { x: 0, y: 0 };
      // Label position = midpoint + offset (this is where the curve passes at t=0.5)
      const lx = baseMx + conn.offset.x;
      const ly = baseMy + conn.offset.y;
      // Derive control point so curve passes through label at t=0.5
      // P(0.5) = 0.25*P0 + 0.5*Pc + 0.25*P1  →  Pc = 2*P(0.5) - 0.5*(P0+P1)
      const cpx = 2 * lx - 0.5 * (sx + tx);
      const cpy = 2 * ly - 0.5 * (sy + ty);
      const pathD = `M${sx},${sy} Q${cpx},${cpy} ${tx},${ty}`;
      const health = getConnectionHealth(id, targetId);
      connectionPathData.push({ sx, sy, cpx, cpy, tx, ty, health });
      let heatClass = '';
      let markerEnd = 'url(#arrowDefault)';
      if (state.heatmapEnabled) {
        heatClass = `heat-${health}`;
        markerEnd = `url(#arrow${health.charAt(0).toUpperCase() + health.slice(1)})`;
      }
      const isSelected = state.selectedConnection &&
        state.selectedConnection.sourceId === id && state.selectedConnection.targetId === targetId;
      if (isSelected) markerEnd = 'url(#arrowAccent)';
      paths += `<path id="conn-${id}-${targetId}" class="conn-path ${heatClass} ${isSelected ? 'conn-selected' : ''}" d="${pathD}" marker-end="${markerEnd}"/>`;
      // Label sits exactly on the curve at t=0.5
      const labelText = conn.label || '';
      const connType = conn.connType || 'http';
      const ctDef = CONN_TYPE_DEFS[connType];
      const iconSpace = 14; // 10px icon + 4px gap
      const labelW = labelText.length * 6 + 16 + iconSpace;
      const iconX = lx - labelW/2 + 4;
      const iconY = ly - 5;
      const textX = lx + iconSpace/2;
      labels += `<g class="conn-label-group ${isSelected ? 'selected' : ''}"
        onmousedown="event.stopPropagation(); startConnDrag(event, '${id}', '${targetId}', ${ci})"
        onclick="event.stopPropagation();">
        <rect class="conn-label-bg ${isSelected ? 'selected' : ''}" x="${lx - labelW/2}" y="${ly - 9}" width="${labelW}" height="18" />
        <g transform="translate(${iconX},${iconY}) scale(1)"><path d="${ctDef.path}" fill="none" stroke="${ctDef.color}" stroke-width="1.3"/></g>
        <text class="conn-label-text" x="${textX}" y="${ly}">${labelText}</text>
      </g>`;
    });
  });
  svg.innerHTML = defs + paths + labels;
}

function renderInspector() {
  const el = document.getElementById('inspectorContent');

  // Connection detail view
  if (state.selectedConnection) {
    const { sourceId, targetId } = state.selectedConnection;
    const conn = getConnectionData(sourceId, targetId);
    const srcComp = components[sourceId];
    const tgtComp = components[targetId];
    if (!conn || !srcComp || !tgtComp) { state.selectedConnection = null; return renderInspector(); }
    const srcCat = CATEGORIES[srcComp.category];
    const tgtCat = CATEGORIES[tgtComp.category];
    el.innerHTML = `
      <div class="conn-header">
        <div class="conn-endpoint" onclick="selectNode('${sourceId}')" title="Inspect ${srcComp.name}">
          <div class="conn-ep-icon" style="border-color:${srcCat.color}">${icon(srcComp.category, srcCat.color)}</div>
          <div class="conn-ep-name">${srcComp.name}</div>
        </div>
        <div class="conn-header-arrow">${icon('arrow_right', 'var(--text-secondary)')}</div>
        <div class="conn-endpoint" onclick="selectNode('${targetId}')" title="Inspect ${tgtComp.name}">
          <div class="conn-ep-icon" style="border-color:${tgtCat.color}">${icon(tgtComp.category, tgtCat.color)}</div>
          <div class="conn-ep-name">${tgtComp.name}</div>
        </div>
      </div>
      <div class="conn-meta">
        <span class="conn-protocol-badge">${conn.label}</span>
        ${conn.role ? `<span class="conn-role-tag">${conn.role}</span>` : ''}
      </div>
      ${conn.direction ? `<div class="conn-direction-text">${conn.direction}</div>` : ''}
      <div class="conn-props-strip">
        <div class="conn-prop-chip">
          ${icon('protocol', 'var(--text-secondary)')}
          <span class="conn-prop-chip-label">Protocol</span>
          <span class="conn-prop-chip-val">${conn.protocol}</span>
        </div>
        <div class="conn-prop-chip">
          ${icon('pattern', 'var(--text-secondary)')}
          <span class="conn-prop-chip-label">Pattern</span>
          <span class="conn-prop-chip-val">${conn.pattern}</span>
        </div>
        <div class="conn-prop-chip">
          ${icon('speed', 'var(--text-secondary)')}
          <span class="conn-prop-chip-label">Latency</span>
          <span class="conn-prop-chip-val">${conn.latency}</span>
        </div>
        <div class="conn-prop-chip ${conn.colocatable ? 'positive' : 'negative'}">
          ${icon('coloc', conn.colocatable ? 'var(--green)' : 'var(--red)')}
          <span class="conn-prop-chip-label">Co-locatable</span>
          <span class="conn-prop-chip-val">${conn.colocatable ? 'Yes' : 'No'}</span>
        </div>
      </div>
      ${conn.summary ? collapsible('conn-summary', 'is', 'var(--text-secondary)', 'What This Connection Does',
        `<div class="conn-summary">${conn.summary}</div>`) : ''}
      ${renderConnectionHealth(sourceId, targetId)}
      ${conn.code ? collapsible('conn-code', 'code', 'var(--text-secondary)', 'Connection Code',
        `<div class="conn-code-pattern">${conn.code}</div>`) : ''}
      <div class="conn-footer">
        <div class="conn-footer-link" onclick="selectNode('${sourceId}')">
          ${icon(srcComp.category, srcCat.color)} ${srcComp.name}
        </div>
        <div class="conn-footer-link" onclick="selectNode('${targetId}')">
          ${icon(tgtComp.category, tgtCat.color)} ${tgtComp.name}
        </div>
      </div>
    `;
    return;
  }

  if (!state.selectedNode) {
    el.innerHTML = `<div class="inspector-empty">
      <svg viewBox="0 0 32 32" fill="none" stroke="currentColor" stroke-width="1"><circle cx="16" cy="16" r="12"/><path d="M16 10v6M16 20v1"/></svg>
      Click a component or connection on the canvas to inspect it.
    </div>`;
    return;
  }
  const c = components[state.selectedNode];
  const cat = CATEGORIES[c.category];
  const v = c.variants[c.currentVariant];
  const alts = ALTERNATIVES[state.selectedNode] || [];
  const variantKeys = Object.keys(c.variants);
  const currentMetrics = v.metrics;
  const rec = getVariantRecommendation(state.selectedNode);

  // Build swap dropdown items with metric diffs
  const swapDropdownHTML = alts.length > 1 ? `<div class="insp-header-dropdown swap ${state.inspSwapOpen ? 'visible' : ''}">
    ${alts.map(a => {
      const isCurrent = a.id === state.selectedNode;
      const altComp = components[a.id];
      const altMetrics = altComp ? altComp.variants[altComp.currentVariant].metrics : {};
      const metricDiffs = !isCurrent ? Object.entries(currentMetrics).map(([mk, mv]) => {
        const altVal = altMetrics[mk];
        if (altVal === undefined || state.hiddenMetrics.has(mk)) return '';
        const diff = altVal - mv;
        if (diff === 0) return '';
        const mi = METRIC_ICON_MAP[mk] ? icon(METRIC_ICON_MAP[mk], diff > 0 ? 'var(--green)' : 'var(--red)') : '';
        return `<span class="insp-dd-metric ${diff > 0 ? 'positive' : 'negative'}">${mi}${diff > 0 ? '+' : ''}${diff}</span>`;
      }).filter(Boolean).join('') : '';
      return `<div class="insp-dd-item ${isCurrent ? 'current' : ''}" onclick="inspSwapComponent('${a.id}', event)">
        <div class="insp-dd-item-header">
          ${icon(c.category, cat.color)} ${a.name}
          <span class="insp-dd-item-sub">${a.sub}</span>
          ${isCurrent ? '<span class="insp-dd-item-current">Current</span>' : ''}
        </div>
        ${metricDiffs ? `<div class="insp-dd-metrics">${metricDiffs}</div>` : ''}
      </div>`;
    }).join('')}
  </div>` : '';

  // Build variant dropdown items with metric change previews
  const variantDropdownHTML = variantKeys.length > 1 ? `<div class="insp-header-dropdown variant ${state.inspVariantOpen ? 'visible' : ''}">
    ${variantKeys.map(vk => {
      const vv = c.variants[vk];
      const isCurrent = vk === c.currentVariant;
      const metricDiffs = !isCurrent ? Object.entries(vv.metrics).map(([mk, mv]) => {
        const diff = mv - currentMetrics[mk];
        if (diff === 0 || state.hiddenMetrics.has(mk)) return '';
        const mi = METRIC_ICON_MAP[mk] ? icon(METRIC_ICON_MAP[mk], diff > 0 ? 'var(--green)' : 'var(--red)') : '';
        return `<span class="insp-dd-metric ${diff > 0 ? 'positive' : 'negative'}">${mi}${diff > 0 ? '+' : ''}${diff}</span>`;
      }).filter(Boolean).join('') : '';
      return `<div class="insp-dd-item ${isCurrent ? 'current' : ''}" onclick="inspChangeVariant('${vk}', event)">
        <div class="insp-dd-item-header">
          ${VARIANT_ICON} ${vv.label}
          ${isCurrent ? '<span class="insp-dd-item-current">Current</span>' : ''}
        </div>
        ${metricDiffs ? `<div class="insp-dd-metrics">${metricDiffs}</div>` : ''}
      </div>`;
    }).join('')}
    ${rec ? `<div class="insp-dd-rec">${icon('gain', 'var(--accent)')} Try <strong>${rec.label}</strong> for <span class="delta-positive" style="margin-left:2px">+${rec.improvement} ${rec.metric}</span></div>` : ''}
  </div>` : '';
  const allMetricEntries = Object.entries(v.metrics);
  const visibleCount = allMetricEntries.filter(([name]) => !state.hiddenMetrics.has(name)).length;
  const checkSvg = '<svg viewBox="0 0 10 10" fill="none" stroke="white" stroke-width="2"><path d="M2 5l2 2 4-4"/></svg>';
  const filterMenuItems = allMetricEntries.map(([name, val]) => {
    const isVisible = !state.hiddenMetrics.has(name);
    const mi = METRIC_ICON_MAP[name] ? icon(METRIC_ICON_MAP[name], 'var(--text-secondary)') : '';
    return `<div class="metric-filter-item ${isVisible ? 'checked' : ''}" onclick="toggleMetricVisibility('${name}', event)">
      <div class="metric-filter-check">${isVisible ? checkSvg : ''}</div>
      <span class="metric-filter-name">${mi} ${name}</span>
      <span class="metric-filter-val" style="color:${getMetricColor(val)}">${val}</span>
    </div>`;
  }).join('');
  const filterMenu = `<div class="metric-filter-menu ${state.metricFilterOpen ? 'visible' : ''}">
    <div class="metric-filter-actions">
      <button class="metric-filter-action" onclick="setAllMetrics(true, event)">All</button>
      <button class="metric-filter-action" onclick="setAllMetrics(false, event)">None</button>
    </div>
    ${filterMenuItems}
  </div>`;
  const filterBtnLabel = visibleCount < allMetricEntries.length ? `${visibleCount}/${allMetricEntries.length}` : '';
  const filterBtn = `<div class="metric-filter-wrap">
    <button class="metric-filter-btn ${state.metricFilterOpen ? 'active' : ''}" onclick="toggleMetricFilter(event)" title="Choose which metrics to show">
      ${icon('filter', 'currentColor')} ${filterBtnLabel}
    </button>
    ${filterMenu}
  </div>`;

  const metricBars = allMetricEntries.filter(([name]) => !state.hiddenMetrics.has(name)).map(([name, val], idx) => {
    const metricIcon = METRIC_ICON_MAP[name] ? icon(METRIC_ICON_MAP[name], 'var(--text-secondary)') : '';
    const delta = state.lastDeltas[name];
    const deltaHTML = delta ? ` <span class="metric-delta ${delta > 0 ? 'positive' : delta < 0 ? 'negative' : 'neutral'}">${delta > 0 ? '+' : ''}${delta}</span>` : '';
    const explData = METRIC_EXPLANATIONS[state.selectedNode] && METRIC_EXPLANATIONS[state.selectedNode][c.currentVariant] && METRIC_EXPLANATIONS[state.selectedNode][c.currentVariant][name];
    const explId = `mexpl-${idx}`;
    const infoBtn = explData ? `<button class="metric-info-btn" onclick="toggleMetricExplanation('${explId}', event)" title="Why this score?">${icon('info', 'currentColor')}</button>` : '';
    const explPanel = explData ? `<div class="metric-explanation" id="${explId}"><div class="metric-expl-reason">${explData.reason}</div><ul class="metric-expl-factors">${explData.factors.map(f => `<li>${f}</li>`).join('')}</ul></div>` : '';
    return `<div class="metric-row-wrap">
      <div class="metric-row">
        <div class="metric-label"><span class="metric-name">${metricIcon} ${name}</span><span class="metric-value" style="color:${getMetricColor(val)}">${val}${deltaHTML}</span>${infoBtn}</div>
        <div class="metric-bar-track"><div class="metric-bar-fill" style="width:${val}%;background:${getMetricColor(val)}"></div><div class="metric-threshold" style="left:70%" title="Healthy threshold"></div></div>
      </div>
      ${explPanel}
    </div>`;
  }).join('');
  const metricsEmpty = visibleCount === 0 ? '<div style="font-size:11px;color:var(--text-secondary);padding:8px 0;text-align:center;">No metrics selected. Click the filter to add metrics.</div>' : '';

  const codePattern = CODE_PATTERNS[state.selectedNode] && CODE_PATTERNS[state.selectedNode][c.currentVariant];

  // Auto-open metrics for components with issues
  if (c.heatStatus !== 'green') {
    state.collapsedSections.delete('insp-metrics');
  }

  el.innerHTML = `
    <div class="insp-header">
      <div class="insp-header-btn insp-swap-btn ${state.inspSwapOpen ? 'active' : ''}" ${alts.length > 1 ? 'onclick="toggleInspSwap(event)"' : 'style="cursor:default;opacity:0.6"'} title="${alts.length > 1 ? 'Swap component' : c.category}">${icon(c.category, cat.color)}</div>
      <div class="insp-header-center">
        <div class="insp-name">${c.name}</div>
        <div class="insp-variant-label">${v.label}</div>
      </div>
      ${variantKeys.length > 1 ? `<div class="insp-header-btn insp-variant-btn ${state.inspVariantOpen ? 'active' : ''}" onclick="toggleInspVariant(event)" title="Change configuration variant">${VARIANT_ICON}</div>` : ''}
    </div>
    <div class="insp-category"><div class="insp-cat-dot" style="background:${cat.color}"></div>${c.category}</div>
    ${swapDropdownHTML}
    ${variantDropdownHTML}
    <div class="insp-section">
      <div class="insp-section-title collapsible" data-toggle="insp-metrics" onclick="toggleSection('insp-metrics')">
        <span class="metric-section-title-row">
          ${icon('metrics', 'var(--text-secondary)')} Metrics
          <span onclick="event.stopPropagation()">${filterBtn}</span>
        </span>
        <span class="section-chevron ${state.collapsedSections.has('insp-metrics') ? '' : 'open'}">${icon('chevron', 'var(--text-secondary)')}</span>
      </div>
      <div class="insp-section-body ${state.collapsedSections.has('insp-metrics') ? 'collapsed' : ''}" id="insp-metrics">${metricsEmpty}${metricBars}</div>
    </div>
    ${collapsible('insp-tradeoffs', 'cons', 'var(--text-secondary)', 'Pros & Cons',
      `<div class="pros-cons">${v.pros.map(p => `<div class="pro">${p}</div>`).join('')}${v.cons.map(cc => `<div class="con">${cc}</div>`).join('')}</div>`)}
    ${c.dataContext ? collapsible('insp-data', 'data_ctx', 'var(--accent)', 'Your Data Context',
      c.dataContext.map(item => {
        const behavior = item.behaviors[c.currentVariant];
        if (!behavior) return '';
        return `<div class="data-item fit-${behavior.fit}">
          <div class="data-item-header">
            ${icon(item.icon, 'var(--text-secondary)')}
            ${item.name}
            <span class="fit-badge ${behavior.fit}">${behavior.fit === 'tradeoff' ? 'trade-off' : behavior.fit}</span>
          </div>
          <div class="data-item-note">${behavior.note}</div>
        </div>`;
      }).join('')) : ''}
    ${codePattern ? collapsible('insp-code', 'code', 'var(--text-secondary)', 'Implementation Pattern',
      `<div class="code-pattern">${codePattern}</div>`) : ''}
  `;
}

function renderDashboard() {
  // Compact bottom bar
  const el = document.getElementById('dashboardBars');
  const { scores, breakdown } = calculateDashboardScores();
  el.innerHTML = dashboardCategories.map(cat => {
    const val = scores[cat.key];
    return `<div class="dash-bar-group">
      <div class="dash-bar-track clickable" onclick="highlightForDashboard('${cat.key}')"><div class="dash-bar-fill" style="width:${val}%;background:${getMetricColor(val)}">
        <span class="dash-bar-value">${val}</span>
      </div></div>
      <div class="dash-bar-label">${icon(cat.icon, 'var(--text-secondary)')} ${cat.name}</div>
    </div>`;
  }).join('');

  // Overlay grid (always update so it's ready when toggled)
  const overlayGrid = document.getElementById('dashOverlayGrid');
  overlayGrid.innerHTML = dashboardCategories.map(cat => {
    const val = scores[cat.key];
    const factors = breakdown[cat.key] || [];
    const info = DASHBOARD_INFO[cat.key];
    const catFullName = info ? info.name : cat.name;
    return `<div class="dash-card">
      <div class="dash-card-header">
        ${icon(cat.icon, getMetricColor(val))} ${catFullName}
        <span class="dash-card-score" style="color:${getMetricColor(val)}">${val}</span>
      </div>
      <div class="dash-card-bar"><div class="dash-card-fill" style="width:${val}%;background:${getMetricColor(val)}"></div></div>
      ${info ? `<div class="dash-card-desc">${info.desc}</div>` : ''}
      <div class="dash-card-factors">
        ${factors.map(f => {
          const mi = METRIC_ICON_MAP[f.metric] ? icon(METRIC_ICON_MAP[f.metric], getMetricColor(f.value)) : '';
          return `<div class="dash-card-factor">
            <span class="dash-card-factor-tip">${f.comp} — ${f.metric}: ${f.value}</span>
            <span class="dash-card-factor-comp">${f.comp}</span>
            <span class="dash-card-factor-icon">${mi}</span>
            <span class="dash-card-factor-bar"><span class="dash-card-factor-fill" style="width:${f.value}%;background:${getMetricColor(f.value)}"></span></span>
            <span class="dash-card-factor-val" style="color:${getMetricColor(f.value)}">${f.value}</span>
          </div>`;
        }).join('')}
      </div>
    </div>`;
  }).join('');

  // Sync overlay visibility
  document.getElementById('dashOverlay').classList.toggle('visible', state.dashboardExpanded);
  document.getElementById('dashboard').classList.toggle('expanded', state.dashboardExpanded);
}

function toggleDashboardExpand() {
  state.dashboardExpanded = !state.dashboardExpanded;
  document.getElementById('dashOverlay').classList.toggle('visible', state.dashboardExpanded);
  document.getElementById('dashboard').classList.toggle('expanded', state.dashboardExpanded);
  if (state.dashboardExpanded) renderDashboard(); // refresh overlay content
}

function calculateDashboardScores() {
  // Build breakdown: for each category, collect { comp, metric, value } entries
  const breakdown = {};
  dashboardCategories.forEach(cat => { breakdown[cat.key] = []; });

  Object.entries(components).forEach(([id, c]) => {
    const v = c.variants[c.currentVariant];
    Object.entries(v.metrics).forEach(([metricName, value]) => {
      const catKey = METRIC_TO_CATEGORY[metricName];
      if (catKey && breakdown[catKey]) {
        breakdown[catKey].push({ comp: c.name, metric: metricName, value });
      }
    });
  });

  // Score per category = average of all contributing metric values
  const scores = {};
  dashboardCategories.forEach(cat => {
    const factors = breakdown[cat.key];
    if (factors.length > 0) {
      scores[cat.key] = Math.round(factors.reduce((sum, f) => sum + f.value, 0) / factors.length);
    } else {
      scores[cat.key] = 50; // default if no data
    }
  });

  return { scores, breakdown };
}

// ═══════════════ INTERACTIONS ═══════════════

function selectNode(id) {
  if (state.selectedNode !== id) state.lastDeltas = {}; // clear deltas when switching components
  state.inspSwapOpen = false;
  state.inspVariantOpen = false;
  state.selectedNode = id;
  state.selectedConnection = null; // deselect connection when selecting node
  renderNodes();
  renderConnections();
  renderInspector();
  updatePrompt();
}

// ═══════════════ DRAG & DROP ═══════════════

function startDrag(e, nodeId) {
  // Ignore if clicking on interactive children (icon swap, variant btn, dropdowns, select)
  if (e.target.closest('.node-variant-btn') || e.target.closest('.node-dropdown') || e.target.closest('.swap-dropdown') || e.target.closest('.node-icon.clickable') || e.target.closest('select')) return;
  e.preventDefault();
  const c = components[nodeId];
  state.dragging = nodeId;
  state.dragMoved = false;
  state.dragStart = { mx: e.clientX, my: e.clientY, nx: c.position.x, ny: c.position.y };
}

function onDrag(e) {
  if (!state.dragging) return;
  const dx = e.clientX - state.dragStart.mx;
  const dy = e.clientY - state.dragStart.my;
  // Only count as drag if moved more than 4px (to allow click)
  if (Math.abs(dx) > 4 || Math.abs(dy) > 4) state.dragMoved = true;
  if (!state.dragMoved) return;
  const c = components[state.dragging];
  c.position.x = state.dragStart.nx + dx;
  c.position.y = state.dragStart.ny + dy;
  // Move the DOM element directly for performance (no full re-render)
  const nodeEl = document.getElementById(`node-${state.dragging}`);
  if (nodeEl) {
    nodeEl.style.left = c.position.x + 'px';
    nodeEl.style.top = c.position.y + 'px';
    nodeEl.classList.add('dragging');
  }
  // Update connection lines
  renderConnections();
}

function endDrag(e) {
  if (!state.dragging) return;
  const nodeId = state.dragging;
  const nodeEl = document.getElementById(`node-${nodeId}`);
  if (nodeEl) nodeEl.classList.remove('dragging');
  state.dragging = null;
  if (!state.dragMoved) {
    // It was a click, not a drag — select the node
    selectNode(nodeId);
  }
  state.dragStart = null;
  state.dragMoved = false;
}

// ═══════════════ CONNECTION LABEL DRAG ═══════════════

function startConnDrag(e, sourceId, targetId, connIdx) {
  e.preventDefault();
  const conn = components[sourceId].connections[connIdx];
  if (!conn.offset) conn.offset = { x: 0, y: 0 };
  state.draggingConn = { sourceId, targetId, connIdx };
  state.connDragStart = { mx: e.clientX, my: e.clientY, ox: conn.offset.x, oy: conn.offset.y };
  state.dragMoved = false;
}

function onConnDrag(e) {
  if (!state.draggingConn) return;
  const dx = e.clientX - state.connDragStart.mx;
  const dy = e.clientY - state.connDragStart.my;
  if (Math.abs(dx) > 3 || Math.abs(dy) > 3) state.dragMoved = true;
  if (!state.dragMoved) return;
  const { sourceId, connIdx } = state.draggingConn;
  const conn = components[sourceId].connections[connIdx];
  conn.offset.x = state.connDragStart.ox + dx;
  conn.offset.y = state.connDragStart.oy + dy;
  renderConnections();
}

function endConnDrag(e) {
  if (!state.draggingConn) return;
  const wasDrag = state.dragMoved;
  const { sourceId, targetId } = state.draggingConn;
  state.draggingConn = null;
  state.connDragStart = null;
  if (!wasDrag) {
    // It was a click, not a drag — select the connection
    selectConnection(sourceId, targetId);
  }
  state.dragMoved = false;
}

// Combined mouse handlers for both node and connection dragging
document.addEventListener('mousemove', function(e) { onDrag(e); onConnDrag(e); });
document.addEventListener('mouseup', function(e) { endDrag(e); endConnDrag(e); });

function changeVariant(nodeId, variantKey) {
  const c = components[nodeId];
  // Store previous metrics for delta display
  const prevMetrics = { ...c.variants[c.currentVariant].metrics };
  c.currentVariant = variantKey;

  // Calculate deltas for display
  const newMetrics = c.variants[variantKey].metrics;
  state.lastDeltas = {};
  Object.entries(newMetrics).forEach(([key, val]) => {
    if (prevMetrics[key] !== undefined) state.lastDeltas[key] = val - prevMetrics[key];
  });
  // Deltas persist until the next variant change (cleared at top of this function)

  // Update heatmap status based on new metrics
  const v = c.variants[variantKey];
  const avg = Object.values(v.metrics).reduce((a,b) => a+b, 0) / Object.values(v.metrics).length;
  c.heatStatus = avg >= 70 ? 'green' : avg >= 50 ? 'yellow' : 'red';

  // Immediate update on source
  renderInspector();
  renderNodes();
  renderConnections();

  // Sequential ripple through connections
  triggerRipple(nodeId);

  // Dashboard updates after ripple
  setTimeout(() => renderDashboard(), 300 + c.connections.length * 150);
  restartFlowIfActive();
  renderIssuesButton();
  updatePrompt();
}

function triggerRipple(sourceId) {
  const c = components[sourceId];
  const sourceNode = document.getElementById(`node-${sourceId}`);
  if (sourceNode) { sourceNode.classList.add('rippling'); setTimeout(() => sourceNode.classList.remove('rippling'), 400); }

  c.connections.forEach((conn, i) => {
    const targetId = conn.target;
    setTimeout(() => {
      // Flash the connection line
      const line = document.getElementById(`conn-${sourceId}-${targetId}`);
      if (line) { line.classList.add('ripple'); setTimeout(() => line.classList.remove('ripple'), 300); }

      // Ripple the target node
      const targetNode = document.getElementById(`node-${targetId}`);
      if (targetNode) {
        targetNode.classList.add('rippling');
        setTimeout(() => targetNode.classList.remove('rippling'), 400);
      }

      renderNodes();
      renderConnections();
      if (i === c.connections.length - 1) restartFlowIfActive();
    }, (i + 1) * 150);
  });
}

function toggleHeatmap() {
  state.heatmapEnabled = !state.heatmapEnabled;
  document.getElementById('heatmapToggle').classList.toggle('active', state.heatmapEnabled);
  renderNodes();
  renderConnections();
  renderLegend();
  if (state.heatmapEnabled) {
    startFlowAnimation();
  } else {
    stopFlowAnimation();
  }
  updatePrompt();
}

function togglePanel(panelId) {
  document.getElementById(panelId).classList.toggle('collapsed');
}

function switchTab(tabEl, tabName) {
  document.querySelectorAll('.toolbox-tab').forEach(t => t.classList.remove('active'));
  tabEl.classList.add('active');
  state.toolboxTab = tabName;
  renderToolbox();
}

// ═══════════════ CONNECTION SELECTION ═══════════════

function selectConnection(sourceId, targetId) {
  // Toggle selection
  if (state.selectedConnection &&
      state.selectedConnection.sourceId === sourceId &&
      state.selectedConnection.targetId === targetId) {
    state.selectedConnection = null;
  } else {
    state.selectedConnection = { sourceId, targetId };
    state.selectedNode = null; // deselect node when selecting connection
  }
  renderNodes();
  renderConnections();
  renderInspector();
  updatePrompt();
}

function getConnectionData(sourceId, targetId) {
  const c = components[sourceId];
  if (!c) return null;
  return c.connections.find(conn => conn.target === targetId) || null;
}

// ═══════════════ COMPONENT SWAP ═══════════════

function toggleSwapDropdown(nodeId) {
  state.variantOpenNode = null;
  state.swapOpenNode = state.swapOpenNode === nodeId ? null : nodeId;
  renderNodes();
  renderConnections();
}

function toggleVariantDropdown(nodeId) {
  state.swapOpenNode = null;
  state.variantOpenNode = state.variantOpenNode === nodeId ? null : nodeId;
  renderNodes();
  renderConnections();
}

function changeVariantFromNode(nodeId, variantKey) {
  state.variantOpenNode = null;
  changeVariant(nodeId, variantKey);
}

function swapComponent(currentId, newId) {
  if (currentId === newId) {
    state.swapOpenNode = null;
    renderNodes();
    renderConnections();
    return;
  }
  // In a real app this would replace the component entirely.
  // For this playground, show feedback that it would swap.
  const alt = (ALTERNATIVES[currentId] || []).find(a => a.id === newId);
  const node = document.getElementById(`node-${currentId}`);
  if (node) {
    node.style.transition = 'transform 0.2s, opacity 0.2s';
    node.style.transform = 'scale(0.9)';
    node.style.opacity = '0.5';
    setTimeout(() => {
      node.style.transform = 'scale(1)';
      node.style.opacity = '1';
    }, 200);
  }
  state.swapOpenNode = null;
  // Update the prompt to reflect the swap intention
  if (alt) {
    const c = components[currentId];
    c._swapTarget = alt;
  }
  renderNodes();
  renderConnections();
  renderInspector();
  updatePrompt();
}

// Close swap/variant dropdown on click outside
document.addEventListener('click', function(e) {
  if (state.swapOpenNode && !e.target.closest('.node-icon.clickable') && !e.target.closest('.node-dropdown') && !e.target.closest('.swap-dropdown')) {
    state.swapOpenNode = null;
    renderNodes();
    renderConnections();
  }
  if (state.variantOpenNode && !e.target.closest('.node-variant-btn') && !e.target.closest('.node-dropdown')) {
    state.variantOpenNode = null;
    renderNodes();
    renderConnections();
  }
  if (state.issuesOpen && !e.target.closest('#issuesBtn') && !e.target.closest('#issuesDropdown')) {
    state.issuesOpen = false;
    document.getElementById('issuesDropdown').classList.remove('visible');
  }
  if (state.metricFilterOpen && !e.target.closest('.metric-filter-wrap') && !e.target.closest('.metric-filter-menu')) {
    state.metricFilterOpen = false;
    const menu = document.querySelector('.metric-filter-menu');
    if (menu) menu.classList.remove('visible');
  }
  if (state.inspSwapOpen && !e.target.closest('.insp-swap-btn') && !e.target.closest('.insp-header-dropdown.swap')) {
    state.inspSwapOpen = false;
    renderInspector();
  }
  if (state.inspVariantOpen && !e.target.closest('.insp-variant-btn') && !e.target.closest('.insp-header-dropdown.variant')) {
    state.inspVariantOpen = false;
    renderInspector();
  }
});

// ═══════════════ PROMPT OUTPUT ═══════════════

function updatePrompt() {
  const el = document.getElementById('promptText');
  const parts = [];
  parts.push('Build the Archie architecture simulator interface with these specifications:');
  parts.push('');
  parts.push('LAYOUT: VS Code three-zone pattern — Toolbox sidebar (left, 270px), Canvas (center, dark bg #0f1117), Inspector panel (right, 310px). Dashboard bar at bottom (110px). Top bar with logo, architecture name, tier badge, and icon+label action buttons.');
  parts.push('');
  parts.push('THEME: Dark mode primary. Panel bg: #1a1d27, Surface: #242736, Border: #2e3348, Text: #e2e4eb / #8b8fa3, Accent: #6366f1 (indigo). Font: Inter, 13px base. 4px spacing unit.');
  parts.push('');
  parts.push('ICONOGRAPHY: Every category, action, metric, and label has an SVG icon. Icons are the primary visual communication — users identify component types by icon before text. 10 category icons: CPU (compute), Database cylinder (data storage), Lightning bolt (caching), Chat bubble (messaging), Globe (delivery/network), Signal waves (real-time), Shield (auth), Chart (monitoring), Magnifying glass (search), Gear (devops). Icons appear in nodes, toolbox cards, inspector, dashboard labels, tabs, and buttons.');
  parts.push('');
  parts.push('NODE SHAPES: Each component category has a distinct node shape: Compute = sharp rectangle (4px radius), Data Storage = bottom-rounded cylinder shape (4px top, 14px bottom radius), Caching = pill (16px radius), Messaging = alternating corners (12px/4px), Delivery = stadium (20px radius). Nodes show: category color top stripe, category icon + name, variant label, mini metric bars.');
  parts.push('');
  parts.push('COLOR SYSTEM: Two separate color layers — category colors (10 distinct hues) identify component TYPE via accent stripes and icon fills. Heatmap colors (green/yellow/red) show HEALTH status on borders and connection lines when heatmap is enabled. These never overlap — category = identity, heatmap = performance.');
  parts.push('');

  if (state.heatmapEnabled) {
    parts.push('HEATMAP: Enabled — node borders glow with health colors (green/yellow/red). Connection LINES also colored by health (worst of two endpoints). Dashed lines for warning/bottleneck connections. Legend visible in top-right corner of canvas.');
    parts.push('');
  }

  if (state.selectedNode) {
    const c = components[state.selectedNode];
    const v = c.variants[c.currentVariant];
    parts.push(`CURRENT SELECTION: ${c.name} (${c.category}) with "${v.label}" config variant.`);
    parts.push(`Metrics: ${Object.entries(v.metrics).map(([k,val]) => `${k}: ${val}/100`).join(', ')}`);
    parts.push('');
  }

  parts.push('CORE INTERACTION: Config variant dropdown in inspector. On change → metric bars animate (0.5s cubic-bezier), sequential ripple propagates through connections (~150ms per hop), heatmap colors shift on nodes AND lines, dashboard updates after ripple completes.');
  parts.push('');
  parts.push('TOOLBOX: Three tabs with icons (grid=Components | stack=Stacks | blueprint=Blueprints). Component cards in IS/GAIN/COST format with category icon + color left border. Section labels have micro-icons (circle=IS, up-arrow=GAIN, down-arrow=COST).');
  parts.push('');
  parts.push('DASHBOARD: 7 horizontal bars with category icons (rocket=Perf, dollar=Cost, shield=Reliab, gear=Ops, mountain=Scale, flag=Strat, code=Dev). Color-coded: green >70, yellow 40-70, red <40.');
  parts.push('');
  parts.push('DATA CONTEXT: Each component has user-defined data items (e.g., Redis: "User Sessions", "Rate Limits", "Message Cache"). When switching config variants, a "Your Data Context" section in the inspector shows how each data item behaves under that variant with fit indicators (great/good/trade-off/poor/risky) and specific notes. This makes abstract metrics concrete: "Your sessions are read-heavy → Cache-Aside is a great fit" vs "Your rate limit counters are write-heavy → Cache-Aside is a poor fit." Users can edit their data items to personalize the trade-off analysis.');
  parts.push('');
  parts.push('COMPONENT SWAP: Each node shows a swap button (arrows icon) on hover in the top-right corner. Clicking opens a dropdown with alternative components in the same category (e.g., Redis → Memcached, KeyDB, Dragonfly). The inspector also shows a "Swap to" dropdown below the component name. This enables quick comparison of alternative tools without rebuilding the architecture.');
  parts.push('');
  parts.push('IMPLEMENTATION PATTERNS: Below the config variant dropdown in the inspector, a code snippet panel shows the actual implementation pattern for the current variant. Syntax-highlighted (keywords purple, functions blue, strings green, comments gray). This makes the difference between variants tangible — users see HOW the code changes, not just abstract metric scores.');
  parts.push('');
  parts.push('CONNECTIONS AS FIRST-CLASS OBJECTS: Connections between components are not just lines — they have properties. Each connection specifies: protocol (HTTP, RESP, Kafka TCP, PostgreSQL Wire, etc.), communication pattern (request-response, pub-sub, poll-consume, fire-and-forget), typical latency, whether components can be co-located on the same machine, and implementation code showing HOW the connection works. Click any connection label on the canvas to inspect its properties. Connections show directional arrows. The WhatsApp architecture has bidirectional flows: API→DB writes, Kafka→API consumer reads, Redis→Gateway rate limiting.');

  if (state.selectedConnection) {
    const conn = getConnectionData(state.selectedConnection.sourceId, state.selectedConnection.targetId);
    if (conn) {
      const src = components[state.selectedConnection.sourceId];
      const tgt = components[state.selectedConnection.targetId];
      parts.push('');
      parts.push(`SELECTED CONNECTION: ${src.name} → ${tgt.name} via ${conn.protocol}. Pattern: ${conn.pattern}. Latency: ${conn.latency}. Co-locatable: ${conn.colocatable ? 'Yes' : 'No'}.`);
    }
  }

  el.textContent = parts.join('\n');
}

function copyPrompt() {
  const text = document.getElementById('promptText').textContent;
  navigator.clipboard.writeText(text).then(() => {
    const btn = document.querySelector('.prompt-copy-btn');
    const original = btn.innerHTML;
    btn.innerHTML = '<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 6l3 3 5-5"/></svg> Copied!';
    setTimeout(() => btn.innerHTML = original, 1500);
  });
}

// ═══════════════ INFO POPUPS ═══════════════

function showInfoPopup(headerHTML, bodyHTML) {
  const overlay = document.getElementById('infoPopupOverlay');
  document.getElementById('infoPopupHeader').innerHTML = headerHTML + `<button class="info-popup-close" onclick="hideInfoPopup()">${icon('close', 'var(--text-secondary)')}</button>`;
  document.getElementById('infoPopupBody').innerHTML = bodyHTML;
  overlay.classList.add('visible');
}

function hideInfoPopup() {
  document.getElementById('infoPopupOverlay').classList.remove('visible');
}

function showCategoryInfo(categoryName) {
  const info = CATEGORY_INFO[categoryName];
  if (!info) return;
  const cat = CATEGORIES[categoryName];
  const headerHTML = `${icon(categoryName, cat.color)} <span style="color:${cat.color}">${categoryName}</span>`;
  const bodyHTML = `
    <p><strong>${info.desc}</strong></p>
    <div class="info-popup-section">
      <div class="info-popup-section-title">Role in Architecture</div>
      <p>${info.role}</p>
    </div>
    <div class="info-popup-section">
      <div class="info-popup-section-title">Common Examples</div>
      <p>${info.examples}</p>
    </div>
    <div class="info-popup-section">
      <div class="info-popup-section-title">How to Choose</div>
      <p>${info.key}</p>
    </div>
  `;
  showInfoPopup(headerHTML, bodyHTML);
}

function showDashboardInfo(categoryKey) {
  const info = DASHBOARD_INFO[categoryKey];
  if (!info) return;
  const dashCat = dashboardCategories.find(c => c.key === categoryKey);
  const headerHTML = `${dashCat ? icon(dashCat.icon, 'var(--accent)') : ''} <span style="color:var(--accent)">${info.name}</span>`;
  const bodyHTML = `
    <p><strong>${info.desc}</strong></p>
    <div class="info-popup-section">
      <div class="info-popup-section-title">Key Metrics</div>
      <p>${info.metrics}</p>
    </div>
    <div class="info-popup-section">
      <div class="info-popup-section-title">Why It Matters</div>
      <p>${info.impact}</p>
    </div>
    <div class="info-popup-section">
      <div class="info-popup-section-title">How to Improve</div>
      <p>${info.improve}</p>
    </div>
  `;
  showInfoPopup(headerHTML, bodyHTML);
}

// Close popup on Escape key
document.addEventListener('keydown', function(e) {
  if (e.key === 'Escape') {
    hideInfoPopup();
    if (state.issuesOpen) { state.issuesOpen = false; document.getElementById('issuesDropdown').classList.remove('visible'); }
    if (state.swapOpenNode || state.variantOpenNode) { state.swapOpenNode = null; state.variantOpenNode = null; renderNodes(); renderConnections(); }
  }
});

// ═══════════════ ISSUES SUMMARY ═══════════════

function getIssues() {
  const issues = [];
  Object.entries(components).forEach(([id, c]) => {
    if (c.heatStatus !== 'green') {
      const v = c.variants[c.currentVariant];
      const avg = Math.round(Object.values(v.metrics).reduce((a,b) => a+b, 0) / Object.values(v.metrics).length);
      const worst = Object.entries(v.metrics).sort((a,b) => a[1] - b[1])[0];
      issues.push({ id, name: c.name, category: c.category, status: c.heatStatus, avg, worstMetric: worst[0], worstValue: worst[1] });
    }
  });
  const priority = { 'red': 0, 'yellow': 1 };
  issues.sort((a, b) => (priority[a.status] ?? 2) - (priority[b.status] ?? 2) || a.avg - b.avg);
  return issues;
}

function renderIssuesButton() {
  const issues = getIssues();
  const badge = document.getElementById('issuesBadge');
  if (issues.length === 0) {
    badge.classList.add('hidden');
  } else {
    badge.classList.remove('hidden');
    badge.textContent = issues.length;
    badge.className = 'issues-badge' + (issues.some(i => i.status === 'red') ? '' : ' warning');
  }
}

function toggleIssues() {
  state.issuesOpen = !state.issuesOpen;
  const dropdown = document.getElementById('issuesDropdown');
  const btn = document.getElementById('issuesBtn');
  if (state.issuesOpen) {
    const rect = btn.getBoundingClientRect();
    dropdown.style.top = (rect.bottom + 4) + 'px';
    dropdown.style.left = Math.max(8, rect.left - 80) + 'px';
    const issues = getIssues();
    if (issues.length === 0) {
      dropdown.innerHTML = `<div class="issues-dropdown-title">${icon('gain', 'var(--green)')} Architecture Health</div>
        <div class="issues-none">All components healthy — no issues detected</div>`;
    } else {
      dropdown.innerHTML = `<div class="issues-dropdown-title">${icon('cons', 'var(--red)')} ${issues.length} Issue${issues.length > 1 ? 's' : ''} Detected</div>
        ${issues.map(i => {
          const cat = CATEGORIES[i.category];
          const h = HEALTH_LABELS[i.status];
          return `<div class="issues-item" onclick="selectNode('${i.id}'); toggleIssues();">
            <span class="issues-item-dot" style="background:${h.color}"></span>
            ${icon(i.category, cat.color)}
            <span class="issues-item-name">${i.name}</span>
            <span class="issues-item-detail">${h.label} · worst: ${i.worstMetric} ${i.worstValue}</span>
          </div>`;
        }).join('')}`;
    }
    dropdown.classList.add('visible');
  } else {
    dropdown.classList.remove('visible');
  }
}

// ═══════════════ VARIANT RECOMMENDATION ═══════════════

function getVariantRecommendation(nodeId) {
  const c = components[nodeId];
  const currentMetrics = c.variants[c.currentVariant].metrics;
  const worst = Object.entries(currentMetrics).sort((a,b) => a[1] - b[1])[0];
  if (worst[1] >= 70) return null;
  let bestAlt = null;
  let bestImprovement = 0;
  Object.entries(c.variants).forEach(([vk, vv]) => {
    if (vk === c.currentVariant) return;
    const altValue = vv.metrics[worst[0]];
    if (altValue !== undefined && altValue > worst[1]) {
      const improvement = altValue - worst[1];
      if (improvement > bestImprovement) {
        bestImprovement = improvement;
        bestAlt = { key: vk, label: vv.label, metric: worst[0], from: worst[1], to: altValue, improvement };
      }
    }
  });
  if (!bestAlt) return null;
  const altMetrics = c.variants[bestAlt.key].metrics;
  let worstRegression = null;
  Object.entries(currentMetrics).forEach(([k, v]) => {
    if (k === worst[0]) return;
    const altV = altMetrics[k];
    if (altV !== undefined && altV < v) {
      const loss = v - altV;
      if (!worstRegression || loss > worstRegression.loss) worstRegression = { metric: k, loss };
    }
  });
  bestAlt.tradeoff = worstRegression;
  return bestAlt;
}

// ═══════════════ TIER INFO ═══════════════

function showTierInfo() {
  const headerHTML = `${icon('strat', 'var(--accent)')} <span style="color:var(--accent)">Architecture Tier System</span>`;
  const issues = getIssues();
  const redCount = issues.filter(i => i.status === 'red').length;
  const yellowCount = issues.filter(i => i.status === 'yellow').length;
  const bodyHTML = `
    <p><strong>Tiers measure how complete and production-ready your architecture is.</strong></p>
    <div class="info-popup-section">
      <div class="info-popup-section-title">Current: Tier 2 / 3</div>
      <p>Your architecture has core components with defined connections and configuration variants. Metrics are tracked and trade-offs are visible.</p>
    </div>
    <div class="info-popup-section">
      <div class="info-popup-section-title">Tier Criteria</div>
      <ul class="info-popup-list">
        <li><strong style="color:var(--green)">Tier 1:</strong> Components placed with basic connections defined</li>
        <li><strong style="color:var(--accent)">Tier 2 (current):</strong> Config variants selected, metrics profiled, trade-offs mapped</li>
        <li><strong style="color:var(--yellow)">Tier 3:</strong> All bottlenecks addressed, heatmap mostly green, data context personalized</li>
      </ul>
    </div>
    <div class="info-popup-section">
      <div class="info-popup-section-title">Gap to Tier 3</div>
      <ul class="info-popup-list">
        ${redCount > 0 ? `<li style="color:var(--red)">Resolve ${redCount} bottleneck${redCount > 1 ? 's' : ''} (red components)</li>` : `<li style="color:var(--green)">No bottlenecks — great!</li>`}
        ${yellowCount > 0 ? `<li style="color:var(--yellow)">Address ${yellowCount} warning${yellowCount > 1 ? 's' : ''} (yellow components)</li>` : `<li style="color:var(--green)">No warnings — great!</li>`}
        <li>Customize data context items for your specific use case</li>
        <li>Verify connection health across all paths</li>
      </ul>
    </div>
  `;
  showInfoPopup(headerHTML, bodyHTML);
}

// ═══════════════ DASHBOARD LINKING ═══════════════

function highlightForDashboard(catKey) {
  const issues = getIssues();
  if (issues.length > 0) {
    issues.forEach(issue => {
      const nodeEl = document.getElementById('node-' + issue.id);
      if (nodeEl) {
        nodeEl.classList.add('flash-highlight');
        setTimeout(() => nodeEl.classList.remove('flash-highlight'), 800);
      }
    });
  }
  showDashboardInfo(catKey);
}

// ═══════════════ FLOW PARTICLE ANIMATION ═══════════════
const FLOW_SPEEDS = { green: 0.014, yellow: 0.006, red: 0.0025 };
const FLOW_COLORS = { green: '#22c55e', yellow: '#eab308', red: '#ef4444' };

function startFlowAnimation() {
  stopFlowAnimation();
  if (connectionPathData.length === 0) return;
  state.flowParticles = [];
  connectionPathData.forEach((path, pi) => {
    const count = path.health === 'green' ? 3 : 2;
    for (let i = 0; i < count; i++) {
      state.flowParticles.push({
        pathIdx: pi,
        t: i / count + Math.random() * 0.1,
        speed: FLOW_SPEEDS[path.health] * (0.9 + Math.random() * 0.2)
      });
    }
  });
  const svg = document.getElementById('flowSvg');
  svg.innerHTML = '<defs><filter id="flowGlow"><feGaussianBlur stdDeviation="2" result="blur"/>' +
    '<feMerge><feMergeNode in="blur"/><feMergeNode in="SourceGraphic"/></feMerge></filter></defs>' +
    state.flowParticles.map((p, i) => {
      const color = FLOW_COLORS[connectionPathData[p.pathIdx].health];
      return `<circle id="fp${i}" cx="0" cy="0" r="3" fill="${color}" opacity="0.9" filter="url(#flowGlow)"/>`;
    }).join('');
  function tick() {
    if (!state.heatmapEnabled) return;
    for (let i = 0; i < state.flowParticles.length; i++) {
      const p = state.flowParticles[i];
      p.t += p.speed;
      if (p.t > 1) p.t -= 1;
      const pd = connectionPathData[p.pathIdx];
      if (!pd) continue;
      const mt = 1 - p.t;
      const x = mt * mt * pd.sx + 2 * mt * p.t * pd.cpx + p.t * p.t * pd.tx;
      const y = mt * mt * pd.sy + 2 * mt * p.t * pd.cpy + p.t * p.t * pd.ty;
      const el = document.getElementById(`fp${i}`);
      if (el) {
        el.setAttribute('cx', x);
        el.setAttribute('cy', y);
        el.setAttribute('r', 2.5 + Math.sin(p.t * Math.PI * 4) * 0.8);
      }
    }
    state.flowAnimationId = requestAnimationFrame(tick);
  }
  state.flowAnimationId = requestAnimationFrame(tick);
}

function stopFlowAnimation() {
  if (state.flowAnimationId) cancelAnimationFrame(state.flowAnimationId);
  state.flowAnimationId = null;
  state.flowParticles = [];
  const svg = document.getElementById('flowSvg');
  if (svg) svg.innerHTML = '';
}

function restartFlowIfActive() {
  if (state.heatmapEnabled) startFlowAnimation();
}

// ═══════════════ INIT ═══════════════
function init() {
  renderLegend();
  renderToolbox();
  renderNodes();
  renderConnections();
  renderDashboard();
  renderIssuesButton();
  updatePrompt();
}

init();
</script>
</body>
</html>
