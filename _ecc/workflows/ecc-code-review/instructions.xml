<workflow>
  <critical>The workflow execution engine is governed by: {project-root}/_bmad/core/tasks/workflow.xml</critical>
  <critical>You MUST have already loaded and processed: {installed_path}/workflow.yaml</critical>
  <critical>Communicate all responses in {communication_language} and language MUST be tailored to {user_skill_level}</critical>
  <critical>Generate all documents in {document_output_language}</critical>

  <critical>ECC ADAPTIVE CODE REVIEW - Orchestrator selects and spawns agents based on story complexity</critical>
  <critical>Use a SINGLE message with MULTIPLE Task calls for true parallelism</critical>

  <!-- AUTO-PROCEED: This workflow runs non-interactively between steps.
       Do NOT ask "Continue to next step?" or pause for confirmation.
       ONLY pause at Step 4 (triage choice) and Step 6e (E2E gap action).
       All other steps execute automatically in sequence. -->
  <critical>AUTO-PROCEED MODE: Skip all generic "Continue?" confirmations.
    Only pause at Step 4 triage and Step 6e E2E gap. All other steps auto-proceed.</critical>

  <!-- STEP 0: Project Knowledge Loading -->

  <step n="0" goal="Load project knowledge for ECC review agents" tag="knowledge-init">
    <critical>Load project patterns ONCE for all review agents</critical>

    <action>Load {project-root}/_ecc/knowledge/code-review-patterns.md -> {{cached_review_patterns}}</action>
    <action>Load any docs/architecture/*.md files that exist -> {{cached_architecture}}</action>
    <action>Store combined as {{project_patterns}} for ECC agents</action>
    <action>Store testing content as {{project_testing_patterns}} for TDD Guide</action>

    <output>**ECC Orchestrator Initialized for Parallel Review**

      Project knowledge loaded for review agents:
      - Code review patterns (MUST CHECK): {{review_patterns_summary}}
      - Architecture docs: loaded (if available)
      - Testing guidelines: loaded

      Ready to spawn parallel review team.
    </output>
  </step>

  <!-- STEP 1: Load Story and Discover Changes -->

  <step n="1" goal="Load story and discover files to review">
    <action>Use provided {{story_path}} or ask user which story to review</action>
    <action>Read COMPLETE story file</action>
    <action>Extract {{story_key}} from filename</action>
    <action>Parse sections: Acceptance Criteria, Tasks, File List</action>

    <!-- ARCHITECTURE ENFORCEMENT: Extract architectural ACs -->
    <critical>ARCHITECTURE ENFORCEMENT: Extract architectural ACs for validation</critical>
    <action>Parse "Architectural Acceptance Criteria" section from story</action>
    <action>Extract {{architectural_acs}} - all architectural ACs</action>
    <action>Extract {{file_specification_table}} from "File Specification" section</action>
    <action>Extract {{architecture_reference}} - source of architectural patterns</action>

    <check if="architectural ACs found">
      <output>**Architectural ACs Loaded for Review**

        **Architecture Source:** {{architecture_reference}}

        - File Location ACs: {{file_location_ac_count}}
        - Pattern ACs: {{pattern_ac_count}}
        - Anti-Pattern ACs: {{antipattern_ac_count}}

        Architecture agent will validate against documented patterns.
      </output>
    </check>

    <check if="NO architectural ACs found">
      <action>Set {{architectural_acs}} = "No architectural ACs specified in story"</action>
      <output>**Warning: No Architectural ACs in Story**

        This story lacks architectural acceptance criteria from documented architecture.
        Architecture review will flag any obvious pattern violations but cannot
        validate against specific documented patterns.

        **Recommendation:** Re-create story using `ecc-create-story` to generate
        ACs from architecture documentation.
      </output>
    </check>

    <!-- Git discovery -->
    <check if="git repository exists">
      <action>Run `git status --porcelain` to find uncommitted changes</action>
      <action>Run `git diff --name-only` to see modified files</action>
      <action>Compile {{files_to_review}} as a FILE PATH LIST from git + story File List</action>
    </check>

    <!-- CONTEXT BUDGET: Read files ONCE here, pass to agents (avoids 4x duplication) -->
    <critical>Read ALL files in {{files_to_review}} NOW using parallel Read calls.
      Store as {{file_contents_manifest}} â€” each file's path and full content.
      Agents will receive this content in their prompts and MUST NOT read files themselves.
      This avoids each agent independently reading the same files (4x cost savings).</critical>
    <action>Read all {{files_to_review}} in parallel (use multiple Read tool calls in one message)</action>
    <action>Store combined content as {{file_contents_manifest}}</action>

    <output>**Review Target Identified**

      Story: {{story_key}}
      Files to review: {{file_count}}
      Functional ACs to validate: {{functional_ac_count}}
      Architectural ACs to validate: {{arch_ac_count}}
    </output>
  </step>

  <!-- STEP 1.5: Adaptive Story Classification -->

  <step n="1.5" goal="Classify story complexity for adaptive review agent selection" tag="classification">
    <critical>ADAPTIVE REVIEW: Select appropriate review agents based on story complexity</critical>
    <critical>Not every story needs 4 agents - TRIVIAL stories get code-reviewer only</critical>

    <!-- Parse story metrics -->
    <action>Parse metrics from story file and {{files_to_review}}:
      - {{task_count}}: Number of top-level tasks
      - {{subtask_count}}: Total subtasks across all tasks
      - {{file_count}}: Number of files in File List / git diff
      - {{file_paths}}: List of all file paths
    </action>

    <!-- Check for security-sensitive files -->
    <action>Check if any {{file_paths}} match security patterns:
      - "**/security/**"
      - "**/auth/**"
      - "**/middleware/**"
    </action>
    <action>Set {{has_security_files}} = true/false</action>

    <!-- Check for architecture-sensitive files -->
    <action>Check if any {{file_paths}} match architecture patterns:
      - "**/stores/**"
      - "**/contexts/**"
      - "**/*.types.ts"
    </action>
    <action>Set {{has_architecture_files}} = true/false</action>

    <!-- Check for security keywords in story content -->
    <action>Search story content for keywords: authentication, authorization, delete, cascade, password, token, secret</action>
    <action>Set {{has_security_keywords}} = true/false</action>

    <!-- Classification logic (cascade â€” first match wins, then force-includes adjust) -->
    <classification>
      <check if="task_count > 6 OR file_count > 10 OR ({{has_architecture_files}} AND {{has_security_files}})">
        <action>Set {{classification}} = "COMPLEX"</action>
        <action>Set {{review_agents}} = ["code-reviewer", "security-reviewer", "architect", "tdd-guide"]</action>
      </check>

      <check if="{{classification}} is NOT set AND (task_count > 4 OR file_count > 6 OR {{has_security_files}} OR {{has_security_keywords}})">
        <action>Set {{classification}} = "STANDARD"</action>
        <action>Set {{review_agents}} = ["code-reviewer", "security-reviewer"]</action>
      </check>

      <check if="{{classification}} is NOT set AND task_count &lt;= 2 AND subtask_count &lt;= 5 AND file_count &lt;= 3 AND NOT {{has_security_files}}">
        <action>Set {{classification}} = "TRIVIAL"</action>
        <action>Set {{review_agents}} = ["code-reviewer"]</action>
      </check>

      <check if="{{classification}} is NOT set AND task_count &lt;= 4 AND subtask_count &lt;= 12 AND file_count &lt;= 6">
        <action>Set {{classification}} = "SIMPLE"</action>
        <action>Set {{review_agents}} = ["code-reviewer", "tdd-guide"]</action>
      </check>

      <check if="{{classification}} is NOT set">
        <action>Set {{classification}} = "SIMPLE"</action>
        <action>Set {{review_agents}} = ["code-reviewer", "tdd-guide"]</action>
      </check>
    </classification>

    <!-- Force-include agents based on file sensitivity -->
    <check if="{{has_security_files}} OR {{has_security_keywords}}">
      <action>Force add "security-reviewer" to {{review_agents}} if not already present</action>
    </check>
    <check if="{{has_architecture_files}} AND task_count > 6">
      <action>Force add "architect" to {{review_agents}} if not already present</action>
    </check>

    <output>**Adaptive Review Classification**

      **Story:** {{story_key}}
      **Classification:** {{classification}}

      **Metrics:**
      - Tasks: {{task_count}}
      - Subtasks: {{subtask_count}}
      - Files: {{file_count}}

      **Sensitivity Flags:**
      - Security-sensitive files: {{has_security_files}}
      - Architecture-sensitive files: {{has_architecture_files}}
      - Security keywords in story: {{has_security_keywords}}

      **Selected Review Agents ({{agent_count}}):** {{review_agents}}
    </output>

    <!-- CONTEXT BUDGET: Large story warning -->
    <check if="file_count > 12">
      <output>**Context Budget Warning:** {{file_count}} files exceeds the 12-file story
        sizing guideline. This review may exhaust context if all agents produce
        detailed findings. Consider:
        1. Splitting the story via `/story-sizing` before review
        2. Running only 2 agents (e.g., code-reviewer + tdd-guide) then a second
           pass with (security-reviewer + architect)
        3. Proceeding as-is but with strict compact output mode</output>
    </check>

    <!-- Auto-proceed: classification displayed above, no confirmation needed -->
  </step>

  <!-- STEP 2: ADAPTIVE ECC REVIEW - Spawn Selected Agents -->

  <step n="2" goal="Spawn selected ECC agents based on adaptive classification">
    <critical>ECC ORCHESTRATOR: Spawning ONLY agents from {{review_agents}} ({{classification}} classification)</critical>
    <critical>CRITICAL: Send ALL selected Task calls in a SINGLE message for true parallelism!</critical>

    <parallel-execution-rule>
      HOW TO ACHIEVE TRUE PARALLELISM:

      You MUST issue ALL selected agent Task calls in your NEXT SINGLE RESPONSE.
      Only spawn agents listed in {{review_agents}} - skip the rest.
    </parallel-execution-rule>

    <output>**Spawning {{classification}} Review Team...**

      **Classification:** {{classification}}
      **Agents launching:** {{review_agents}}
    </output>

    <!-- ADAPTIVE PARALLEL SPAWN - Only selected agents, ALL IN ONE MESSAGE -->
    <!-- All agent prompts include file contents and compact output directive -->
    <agent-directives>
      IMPORTANT â€” include these directives in EVERY agent prompt:
      1. File contents are provided below. Do NOT use Read/Grep/Glob to read review files.
      2. Return ONLY: numbered findings table (severity | description | file:line), recommendation (APPROVE / CHANGES REQUESTED / BLOCKED), score (X/10). Max ~50 lines. No code snippets or lengthy reasoning.
    </agent-directives>

    <ecc-parallel-spawn agents="{{review_agents}}">
      <!-- Task 1: Code Reviewer (ALWAYS included) -->
      <task-call id="code_review" if="code-reviewer in {{review_agents}}">
        subagent_type: "everything-claude-code:code-reviewer"
        model: "sonnet"
        max_turns: 5
        description: "Code quality review for {{story_key}}"
        prompt: |
          ## Code Review Task
          **Story:** {{story_key}}
          **IMPORTANT: File contents provided below. Do NOT read files yourself.**

          **Acceptance Criteria:** {{acceptance_criteria}}
          **Project Patterns:** {{project_patterns}}

          **Review:** quality, error handling, performance, naming, DRY, complexity

          **Output (max 50 lines):**
          | # | Sev | Finding | file:line |
          Recommendation: APPROVE / CHANGES REQUESTED
          Score: X/10

          ---
          **FILE CONTENTS:**
          {{file_contents_manifest}}
      </task-call>

      <!-- Task 2: Security Reviewer (STANDARD + COMPLEX only) -->
      <task-call id="security_review" if="security-reviewer in {{review_agents}}">
        subagent_type: "everything-claude-code:security-reviewer"
        model: "sonnet"
        max_turns: 5
        description: "Security review for {{story_key}}"
        prompt: |
          ## Security Review Task
          **Story:** {{story_key}}
          **IMPORTANT: File contents provided below. Do NOT read files yourself.**

          **Check:** OWASP Top 10 (injection, XSS, auth, access control, secrets, data exposure, CSRF, input validation)

          **Output (max 50 lines):**
          | # | Sev | Vulnerability | file:line | Remediation |
          Secrets detected: Y/N
          Recommendation: APPROVE / BLOCK / CHANGES REQUESTED
          Score: X/10

          ---
          **FILE CONTENTS:**
          {{file_contents_manifest}}
      </task-call>

      <!-- Task 3: Architect (COMPLEX only) -->
      <task-call id="architecture_review" if="architect in {{review_agents}}">
        subagent_type: "everything-claude-code:architect"
        model: "opus"
        max_turns: 5
        description: "Architecture review for {{story_key}}"
        prompt: |
          ## Architecture Review Task
          **Story:** {{story_key}}
          **IMPORTANT: File contents provided below. Do NOT read files yourself.**

          **Architecture Source:** {{architecture_reference}}
          **Architectural ACs:** {{architectural_acs}}
          **File Specification:** {{file_specification_table}}
          **Patterns:** {{project_patterns}}

          **Validate:** file locations, pattern compliance, anti-patterns, architectural ACs, separation of concerns, dependency management, layer violations, coupling

          **Output (max 50 lines):**
          | AC ID | Status | Notes |
          File location compliance: X/Y
          Pattern violations: [list or none]
          Anti-patterns: [list or none]
          Alignment: ALIGNED / DRIFT DETECTED
          Recommendation: APPROVE / CHANGES REQUESTED / BLOCKED
          Score: X/10

          ---
          **FILE CONTENTS:**
          {{file_contents_manifest}}
      </task-call>

      <!-- Task 4: TDD Guide (SIMPLE + COMPLEX only) -->
      <task-call id="test_review" if="tdd-guide in {{review_agents}}">
        subagent_type: "everything-claude-code:tdd-guide"
        model: "haiku"
        max_turns: 5
        description: "Test review for {{story_key}}"
        prompt: |
          ## Test Coverage Review Task
          **Story:** {{story_key}}
          **IMPORTANT: File contents provided below. Do NOT read files yourself.**

          **Acceptance Criteria:** {{acceptance_criteria}}
          **Testing Patterns:** {{project_testing_patterns}}

          **Review:** AC coverage, edge cases, error scenarios, assertion quality, mock appropriateness, naming

          **TEA Score (each 0-100):** Determinism, Isolation, Maintainability, Coverage, Performance. 70+ = GOOD.

          **Output (max 50 lines):**
          Coverage gaps: [AC] missing test for [scenario] [file]
          Quality issues: [test] [issue] [file:line]
          | Dimension | Score | Notes |
          Overall: X/100 â€” GOOD / NEEDS IMPROVEMENT
          Recommendation: APPROVE / CHANGES REQUESTED
          Score: X/10

          ---
          **FILE CONTENTS:**
          {{file_contents_manifest}}
      </task-call>
    </ecc-parallel-spawn>

    <action>Wait for all selected agents to complete</action>
    <action>Collect outputs â€” extract ONLY: finding #, severity, agent, one-line description, file:line</action>
  </step>

  <!-- STEP 3: Review Synthesis -->

  <step n="3" goal="Synthesis of parallel review outputs">
    <critical>REVIEW SYNTHESIS - Merge findings, resolve conflicts, add workflow analysis</critical>
    <critical>ARCHITECTURE GATE: Architectural violations are BLOCKING</critical>
    <critical>WEIGHTED SCORING: Adjust weights based on which agents were used</critical>

    <action>Merge findings from all spawned agents by severity:
      - CRITICAL: Security vulnerabilities requiring immediate fix
      - HIGH: Must fix before approval (includes architectural violations)
      - MEDIUM: Should fix, can be action items
      - LOW: Nice to have improvements
    </action>

    <action>Identify conflicts between agent recommendations</action>
    <action>Calculate individual agent scores (1-10 scale) for each spawned agent</action>
    <action>Calculate overall score as average of all active agent scores</action>

    <output>## ECC Adaptive Review Synthesis

      **Story:** {{story_key}} | **Date:** {date} | **Classification:** {{classification}} | **Agents:** {{review_agents}}

      ---

      ### Overall Assessment

      | Agent | Score | Status |
      |-------|-------|--------|
      | Code Quality | {{code_score}}/10 | {{code_status}} |
      {{#if security-reviewer in review_agents}}
      | Security | {{security_score}}/10 | {{security_status}} |
      {{/if}}
      {{#if architect in review_agents}}
      | Architecture | {{arch_score}}/10 | {{arch_status}} |
      {{/if}}
      {{#if tdd-guide in review_agents}}
      | Testing | {{test_score}}/10 | {{test_status}} |
      {{/if}}
      | **OVERALL** | **{{overall_score}}/10** | **{{overall_status}}** |

      ---

      ### Numbered Findings

      | # | Sev | Agent | Finding | Effort |
      |---|-----|-------|---------|--------|
      {{#each all_findings_numbered}}
      | {{index}} | {{severity}} | {{agent}} | {{description}} [{{file}}:{{line}}] | {{effort_class}} |
      {{/each}}

      ---

      **Recommendation:** {{final_recommendation}}
    </output>
  </step>

  <!-- STEP 4: Smart Triage -->

  <step n="4" goal="Auto-triage findings by effort, let user choose handling per item or batch">
    <critical>SMART TRIAGE: Every finding gets an effort classification + suggested action</critical>

    <!-- 4a: Auto-classify each finding by effort -->
    <action>For each finding from Step 3, classify effort:

      QUICK (fix in current session):
      - Missing validation or guard clause (1-5 lines)
      - Naming convention fix
      - Missing error handling on a single call
      - Adding a missing test assertion
      - Import cleanup or unused variable
      - Simple type fix
      - Missing null check
      - Documentation/comment fix
      - Single-file, localized change

      COMPLEX (needs separate work):
      - Multi-file refactoring
      - New abstraction or pattern introduction
      - Architectural restructuring
      - Service layer redesign
      - New test infrastructure needed
      - Security model change
      - State management refactoring
      - Performance optimization requiring profiling
      - Changes touching >3 files
    </action>

    <!-- 4b: Present triage options -->
    <ask>**Smart Triage** - {{quick_count}} quick fixes, {{complex_count}} complex items

      1. **[Q]uick + Defer** - Fix all QUICK now -> create TD stories for COMPLEX *(Recommended)*
      2. **[F]ix all** - Fix everything now (only if scope fits in session)
      3. **[C]ustom** - Per-item control with range syntax (e.g., `fix 1-3, defer 4-6`)
      4. **[S]kip** - Mark review complete without changes

      Choose [Q], [F], [C], or [S]:</ask>

    <!-- 4c: Execute chosen triage strategy -->
    <check if="user chooses Q (Quick + Defer)">
      <action>Fix all findings where effort_class = QUICK</action>
      <action>Re-run tests after fixes</action>
      <action>Set {{td_items}} = all findings where effort_class = COMPLEX</action>
      <action>Proceed to Step 4.5 with {{td_items}}</action>
    </check>

    <check if="user chooses F (Fix all)">
      <action>Fix ALL findings</action>
      <action>Re-run tests after fixes</action>
      <action>Update File List in story</action>
    </check>

    <check if="user chooses C (Custom)">
      <ask>Enter triage commands using range syntax:

        - `fix 1-5` or `fix 1,3,5` - fix these items now
        - `defer 6-8` - create TD stories for these items
        - Combine: `fix 1-3, defer 4-6`
        - Shortcuts: `fix quick`, `defer complex`

        Enter triage commands:</ask>
    </check>

    <check if="user chooses S (Skip)">
      <output>Review marked complete without changes.</output>
    </check>
  </step>

  <!-- STEP 4.5: Tech Debt Story Creation (Optional) -->

  <step n="4.5" goal="Create tech debt stories for deferred items">
    <critical>TECH DEBT TRACKING - Every deferred item becomes a tracked TD story</critical>

    <action>Group deferred items by theme to minimize story count</action>

    <action>For each TD story group, create story file in {sprint_artifacts}/stories/</action>

    <action>Update sprint-status.yaml with each TD story: ready-for-dev</action>
    <action>Update source story with TD links</action>

    <output>**Tech Debt Stories Created**

      Created {{td_story_count}} TD stories.
      Sprint status updated. Stories ready for sprint planning.
    </output>
  </step>

  <!-- STEP 5: Cost Tracking (MANDATORY â€” always runs) -->

  <step n="5" goal="Run cost analyzer â€” this step is NEVER skippable" tag="cost-tracking">
    <critical>MANDATORY STEP â€” You MUST execute this bash command and capture its output.
      Do NOT skip it. Do NOT proceed to Step 6 without running this command first.
      This step exists separately from E2E analysis so it cannot be accidentally skipped
      when E2E is N/A.</critical>

    <action>Run cost analyzer: `workflow-cost --csv --stats --workflow "ecc-code-review" --story "{{story_key}}"`</action>
    <action>Store the FULL terminal output as {{cost_report_output}} â€” include the COST NOTICE box</action>

    <output>ðŸ’° **Cost Tracking Complete** â€” {{cost_report_output}}</output>
  </step>

  <!-- STEP 6: E2E Coverage Analysis + Commit Prep (conditional) -->

  <step n="6" goal="Check E2E coverage gaps and build commit list" tag="e2e-analysis">
    <!-- 6a: Quick check for UI changes -->
    <action>Check if any {{files_to_review}} match UI patterns:
      "src/components/**/*.tsx" (excluding ui/), "src/hooks/*.ts", "src/stores/*.ts"</action>
    <action>Set {{has_ui_changes}} = true/false</action>

    <check if="{{has_ui_changes}}">
      <!-- 6b: Search existing E2E specs for coverage of changed UI -->
      <action>Extract data-testid values from changed .tsx files, search tests/e2e/*.spec.ts for coverage</action>
      <action>Set {{uncovered_testids}} and {{ui_missing_e2e}}</action>

      <!-- 6c: Critical path assessment -->
      <action>Check if changes are on critical user path (auth, canvas, toolbox, inspector, YAML import/export)</action>
    </check>

    <!-- Build commit commands for the user -->
    <action>Build list of {{review_changed_files}} â€” files modified/created during THIS review session:
      - Story file (status update + review summary)
      - sprint-status.yaml (status change + any new TD entries)
      - Any new TD story files created in Step 4.5
      - Any source/test files modified by quick fixes in Step 4
    </action>

    <output>âœ… **E2E Analysis Complete** â€” proceeding to story status update.</output>
  </step>

  <!-- STEP 7: Story Status Update + Review Complete (MUST be last step) -->

  <step n="7" goal="Update story status and present final review summary">
    <critical>Story status update is the FINAL step. Cost tracking (Step 5) and E2E analysis (Step 6) already ran.</critical>

    <check if="no CRITICAL or HIGH issues OR all fixed">
      <action>Update story Status to "done"</action>
      <action>Set {{new_status}} = "done"</action>
    </check>

    <check if="CRITICAL or HIGH issues remain">
      <action>Update story Status to "in-progress"</action>
      <action>Set {{new_status}} = "in-progress"</action>
    </check>

    <check if="{{sprint_status}} file exists">
      <action>Update sprint-status.yaml: {{story_key}} -> {{new_status}}</action>
    </check>

    <action>Add "Senior Developer Review (ECC)" section to story</action>

    <!-- Final unified output with cost, commit commands, and next steps -->
    <output>**ECC Code Review Complete!**

      **Story:** {{story_key}} | **Status:** {{new_status}} | **Classification:** {{classification}}
      **Triage:** {{fixed_count}} fixed, {{td_story_count}} TD stories
      **Agents:** {{review_agents}}

      {{#if has_ui_changes}}
      {{#if ui_missing_e2e}}
      **E2E:** gaps detected for {{uncovered_testids}}
      **Critical path:** {{is_critical_path}} â€” {{critical_path_reason}}
      {{/if}}
      {{#if NOT ui_missing_e2e}}
      **E2E:** Existing specs cover changed UI components.
      {{/if}}
      {{/if}}
      {{#if NOT has_ui_changes}}
      **E2E:** No UI changes â€” E2E check skipped.
      {{/if}}

      **Session Cost:**
      {{cost_report_output}}

      ---

      **Commit Commands (copy-paste):**

      ```bash
      # Stage review artifacts
      {{#each review_changed_files}}
      git add {{file_path}}
      {{/each}}

      # Commit
      git commit -m "$(cat &lt;&lt;'EOF'
      Review {{story_key}}: {{overall_status}} {{overall_score}}/10{{#if td_story_count}}, create {{td_stories_list}}{{/if}}

      Co-Authored-By: Claude Opus 4.6 &lt;noreply@anthropic.com&gt;
      EOF
      )"
      ```

      **Next Steps:**
      - Run `/workflow-close` to verify tests, status files, and branch state
      {{#if new_status == "done"}}
      - Run `/deploy-story` to deploy â€” or [C]ommit to branch for batching multiple stories
      {{/if}}
      {{#if has_ui_changes}}
      {{#if ui_missing_e2e}}
      {{#if is_critical_path}}
      - **Recommend:** Run `/ecc-e2e` â€” E2E gap on critical path ({{critical_path_reason}})
      {{/if}}
      {{#if NOT is_critical_path}}
      - Consider running `/ecc-e2e` for E2E coverage of new UI changes
      {{/if}}
      {{/if}}
      {{/if}}
      {{#if new_status != "done"}}
      - Address remaining issues
      - Re-run `/ecc-code-review` after fixes
      {{/if}}
    </output>
  </step>

</workflow>
