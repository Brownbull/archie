<workflow>
  <critical>The workflow execution engine is governed by: {project-root}/_bmad/core/tasks/workflow.xml</critical>
  <critical>You MUST have already loaded and processed: {installed_path}/workflow.yaml</critical>
  <critical>Communicate all responses in {communication_language} and language MUST be tailored to {user_skill_level}</critical>
  <critical>Generate all documents in {document_output_language}</critical>

  <critical>ECC ADAPTIVE CODE REVIEW - ECC Orchestrator selects and spawns agents based on story complexity!</critical>
  <critical>Step 1.5 classifies story as TRIVIAL/SIMPLE/STANDARD/COMPLEX -> selects appropriate agents</critical>
  <critical>CRITICAL: Use a SINGLE message with MULTIPLE Task calls for true parallelism</critical>

  <!-- ECC ORCHESTRATOR PROTOCOL -->
  <orchestrator-protocol>
    <principle>Orchestrator spawns specialized ECC agents in parallel</principle>
    <principle>SINGLE message, MULTIPLE Task calls = true parallel execution</principle>
    <principle>Collect all outputs, then synthesize findings</principle>
    <principle>Resolve conflicts between agent recommendations</principle>

    <parallel-team>
      | Agent | subagent_type | Focus Area |
      |-------|---------------|------------|
      | Code Reviewer | everything-claude-code:code-reviewer | Quality, maintainability |
      | Security Reviewer | everything-claude-code:security-reviewer | OWASP, vulnerabilities |
      | Architect | everything-claude-code:architect | Patterns, design |
      | TDD Guide | everything-claude-code:tdd-guide | Test coverage, TDD |
    </parallel-team>
  </orchestrator-protocol>

  <!-- STEP 0: Project Knowledge Loading -->

  <step n="0" goal="Load project knowledge for ECC review agents" tag="knowledge-init">
    <critical>Load project patterns ONCE for all review agents</critical>

    <action>Load {project-root}/_ecc/knowledge/code-review-patterns.md -> {{cached_review_patterns}}</action>
    <action>Load any docs/architecture/*.md files that exist -> {{cached_architecture}}</action>
    <action>Store combined as {{project_patterns}} for ECC agents</action>
    <action>Store testing content as {{project_testing_patterns}} for TDD Guide</action>

    <output>**ECC Orchestrator Initialized for Parallel Review**

      Project knowledge loaded for review agents:
      - Code review patterns (MUST CHECK): {{review_patterns_summary}}
      - Architecture docs: loaded (if available)
      - Testing guidelines: loaded

      Ready to spawn parallel review team.
    </output>
  </step>

  <!-- STEP 1: Load Story and Discover Changes -->

  <step n="1" goal="Load story and discover files to review">
    <action>Use provided {{story_path}} or ask user which story to review</action>
    <action>Read COMPLETE story file</action>
    <action>Extract {{story_key}} from filename</action>
    <action>Parse sections: Acceptance Criteria, Tasks, File List</action>

    <!-- ARCHITECTURE ENFORCEMENT: Extract architectural ACs -->
    <critical>ARCHITECTURE ENFORCEMENT: Extract architectural ACs for validation</critical>
    <action>Parse "Architectural Acceptance Criteria" section from story</action>
    <action>Extract {{architectural_acs}} - all architectural ACs</action>
    <action>Extract {{file_specification_table}} from "File Specification" section</action>
    <action>Extract {{architecture_reference}} - source of architectural patterns</action>

    <check if="architectural ACs found">
      <output>**Architectural ACs Loaded for Review**

        **Architecture Source:** {{architecture_reference}}

        - File Location ACs: {{file_location_ac_count}}
        - Pattern ACs: {{pattern_ac_count}}
        - Anti-Pattern ACs: {{antipattern_ac_count}}

        Architecture agent will validate against documented patterns.
      </output>
    </check>

    <check if="NO architectural ACs found">
      <action>Set {{architectural_acs}} = "No architectural ACs specified in story"</action>
      <output>**Warning: No Architectural ACs in Story**

        This story lacks architectural acceptance criteria from documented architecture.
        Architecture review will flag any obvious pattern violations but cannot
        validate against specific documented patterns.

        **Recommendation:** Re-create story using `ecc-create-story` to generate
        ACs from architecture documentation.
      </output>
    </check>

    <!-- Git discovery -->
    <check if="git repository exists">
      <action>Run `git status --porcelain` to find uncommitted changes</action>
      <action>Run `git diff --name-only` to see modified files</action>
      <action>Compile {{files_to_review}} from git + story File List</action>
    </check>

    <output>**Review Target Identified**

      Story: {{story_key}}
      Files to review: {{file_count}}
      Functional ACs to validate: {{functional_ac_count}}
      Architectural ACs to validate: {{arch_ac_count}}
    </output>
  </step>

  <!-- STEP 1.5: Adaptive Story Classification -->

  <step n="1.5" goal="Classify story complexity for adaptive review agent selection" tag="classification">
    <critical>ADAPTIVE REVIEW: Select appropriate review agents based on story complexity</critical>
    <critical>Not every story needs 4 agents - TRIVIAL stories get code-reviewer only</critical>

    <!-- Parse story metrics -->
    <action>Parse metrics from story file and {{files_to_review}}:
      - {{task_count}}: Number of top-level tasks
      - {{subtask_count}}: Total subtasks across all tasks
      - {{file_count}}: Number of files in File List / git diff
      - {{file_paths}}: List of all file paths
    </action>

    <!-- Check for security-sensitive files -->
    <action>Check if any {{file_paths}} match security patterns:
      - "**/security/**"
      - "**/auth/**"
      - "**/middleware/**"
    </action>
    <action>Set {{has_security_files}} = true/false</action>

    <!-- Check for architecture-sensitive files -->
    <action>Check if any {{file_paths}} match architecture patterns:
      - "**/stores/**"
      - "**/contexts/**"
      - "**/*.types.ts"
    </action>
    <action>Set {{has_architecture_files}} = true/false</action>

    <!-- Check for security keywords in story content -->
    <action>Search story content for keywords: authentication, authorization, delete, cascade, password, token, secret</action>
    <action>Set {{has_security_keywords}} = true/false</action>

    <!-- Classification logic -->
    <classification>
      <check if="task_count > 4 OR file_count > 8 OR {{has_security_files}} OR {{has_security_keywords}}">
        <check if="{{has_architecture_files}} OR task_count > 4">
          <action>Set {{classification}} = "COMPLEX"</action>
          <action>Set {{review_agents}} = ["code-reviewer", "security-reviewer", "architect", "tdd-guide"]</action>
        </check>
        <check if="NOT {{has_architecture_files}} AND task_count &lt;= 4">
          <action>Set {{classification}} = "STANDARD"</action>
          <action>Set {{review_agents}} = ["code-reviewer", "security-reviewer"]</action>
        </check>
      </check>

      <check if="task_count &lt;= 4 AND subtask_count &lt;= 15 AND file_count &lt;= 8">
        <check if="any file_paths match **/services/** OR **/stores/** OR **/hooks/**">
          <action>Set {{classification}} = "STANDARD"</action>
          <action>Set {{review_agents}} = ["code-reviewer", "security-reviewer"]</action>
        </check>
      </check>

      <check if="task_count &lt;= 3 AND subtask_count &lt;= 10 AND file_count &lt;= 5 AND NOT {{has_security_files}}">
        <action>Set {{classification}} = "SIMPLE"</action>
        <action>Set {{review_agents}} = ["code-reviewer", "tdd-guide"]</action>
      </check>

      <check if="task_count &lt;= 1 AND subtask_count &lt;= 3 AND file_count &lt;= 2 AND NOT {{has_security_files}} AND NOT {{has_architecture_files}}">
        <action>Set {{classification}} = "TRIVIAL"</action>
        <action>Set {{review_agents}} = ["code-reviewer"]</action>
      </check>

      <check if="{{classification}} is NOT set">
        <action>Set {{classification}} = "STANDARD"</action>
        <action>Set {{review_agents}} = ["code-reviewer", "security-reviewer"]</action>
      </check>
    </classification>

    <!-- Force-include agents based on file sensitivity -->
    <check if="{{has_security_files}} OR {{has_security_keywords}}">
      <action>Force add "security-reviewer" to {{review_agents}} if not already present</action>
    </check>
    <check if="{{has_architecture_files}} AND task_count > 4">
      <action>Force add "architect" to {{review_agents}} if not already present</action>
    </check>

    <output>**Adaptive Review Classification**

      **Story:** {{story_key}}
      **Classification:** {{classification}}

      **Metrics:**
      - Tasks: {{task_count}}
      - Subtasks: {{subtask_count}}
      - Files: {{file_count}}

      **Sensitivity Flags:**
      - Security-sensitive files: {{has_security_files}}
      - Architecture-sensitive files: {{has_architecture_files}}
      - Security keywords in story: {{has_security_keywords}}

      **Selected Review Agents ({{agent_count}}):** {{review_agents}}
    </output>

    <ask>Proceed with {{classification}} review using {{agent_count}} agents? [Y/N/Override]</ask>
  </step>

  <!-- STEP 2: ADAPTIVE ECC REVIEW - Spawn Selected Agents -->

  <step n="2" goal="Spawn selected ECC agents based on adaptive classification">
    <critical>ECC ORCHESTRATOR: Spawning ONLY agents from {{review_agents}} ({{classification}} classification)</critical>
    <critical>CRITICAL: Send ALL selected Task calls in a SINGLE message for true parallelism!</critical>

    <parallel-execution-rule>
      HOW TO ACHIEVE TRUE PARALLELISM:

      You MUST issue ALL selected agent Task calls in your NEXT SINGLE RESPONSE.
      Only spawn agents listed in {{review_agents}} - skip the rest.
    </parallel-execution-rule>

    <output>**Spawning {{classification}} Review Team...**

      **Classification:** {{classification}}
      **Agents launching:** {{review_agents}}
    </output>

    <!-- ADAPTIVE PARALLEL SPAWN - Only selected agents, ALL IN ONE MESSAGE -->
    <ecc-parallel-spawn agents="{{review_agents}}">
      <!-- Task 1: Code Reviewer (ALWAYS included) -->
      <task-call id="code_review" if="code-reviewer in {{review_agents}}">
        subagent_type: "everything-claude-code:code-reviewer"
        description: "Code quality review for {{story_key}}"
        prompt: |
          ## Code Review Task

          **Story:** {{story_key}}

          **Files to Review:**
          {{files_to_review}}

          **Acceptance Criteria:**
          {{acceptance_criteria}}

          **Project Context:**
          {{project_patterns}}

          **Review Checklist:**
          1. Code quality and readability
          2. Error handling completeness
          3. Performance considerations
          4. Naming conventions
          5. DRY principle compliance
          6. Complexity analysis
          7. Documentation quality

          **Output Format:**
          ```
          ## Code Review Findings

          ### HIGH Severity
          - [Finding]: [Description] [file:line]

          ### MEDIUM Severity
          - [Finding]: [Description] [file:line]

          ### LOW Severity
          - [Finding]: [Description] [file:line]

          ### Summary
          - Total issues: X
          - Recommendation: APPROVE / CHANGES REQUESTED
          ```
      </task-call>

      <!-- Task 2: Security Reviewer (STANDARD + COMPLEX only) -->
      <task-call id="security_review" if="security-reviewer in {{review_agents}}">
        subagent_type: "everything-claude-code:security-reviewer"
        description: "Security review for {{story_key}}"
        prompt: |
          ## Security Review Task

          **Story:** {{story_key}}

          **Files to Review:**
          {{files_to_review}}

          **Security Checklist (OWASP Top 10):**
          1. Injection vulnerabilities (SQL, command, XSS)
          2. Broken authentication
          3. Sensitive data exposure
          4. Broken access control
          5. Security misconfiguration
          6. Cross-site scripting (XSS)
          7. Insecure deserialization
          8. Using components with known vulnerabilities
          9. Insufficient logging and monitoring

          **Additional Checks:**
          - Hardcoded secrets (API keys, passwords, tokens)
          - Input validation
          - Output encoding
          - CSRF protection
          - Rate limiting

          **Output Format:**
          ```
          ## Security Review Findings

          ### CRITICAL
          - [Vulnerability]: [Description] [file:line] [REMEDIATION]

          ### HIGH
          - [Vulnerability]: [Description] [file:line] [REMEDIATION]

          ### MEDIUM
          - [Vulnerability]: [Description] [file:line] [REMEDIATION]

          ### Summary
          - Vulnerabilities found: X
          - Secrets detected: Y/N
          - Recommendation: APPROVE / BLOCK / CHANGES REQUESTED
          ```
      </task-call>

      <!-- Task 3: Architect (COMPLEX only) -->
      <task-call id="architecture_review" if="architect in {{review_agents}}">
        subagent_type: "everything-claude-code:architect"
        description: "Architecture review for {{story_key}}"
        prompt: |
          ## Architecture Review Task

          **Story:** {{story_key}}

          **Files to Review:**
          {{files_to_review}}

          **Architecture Patterns:**
          {{project_patterns}}

          **Architectural Acceptance Criteria (from story):**
          {{architectural_acs}}

          **Expected File Specification (from story):**
          {{file_specification_table}}

          ---

          ## CRITICAL: Documented Architecture Compliance Check

          **Architecture Source:** {{architecture_reference}}

          **This review MUST validate compliance with DOCUMENTED architectural patterns.**

          ### 1. File Location Compliance
          {{file_location_acs}}

          ### 2. Pattern Compliance
          {{pattern_acs}}

          ### 3. Anti-Pattern Compliance
          {{antipattern_acs}}

          ### 4. Architectural AC Validation
          {{architectural_acs}}

          ---

          **Standard Review Checklist:**
          1. Pattern compliance with documented architecture
          2. Separation of concerns
          3. Dependency management
          4. Layer violations
          5. API design consistency
          6. Data flow correctness
          7. Scalability considerations
          8. Coupling and cohesion

          **Output Format:**
          ```
          ## Architecture Review Findings

          **Architecture Source:** {{architecture_reference}}

          ### File Location Compliance
          - Files in documented locations: X/Y
          - Location violations: [list]

          ### Pattern Compliance
          - Pattern requirements met: X/Y
          - Pattern violations: [list]

          ### Anti-Pattern Compliance
          - Anti-patterns detected: [list]
          - Clean: [count]

          ### Architectural AC Validation
          | AC ID | Description | Status | Notes |
          |-------|-------------|--------|-------|

          ### Summary
          - Architecture alignment: ALIGNED / DRIFT DETECTED
          - Recommendation: APPROVE / CHANGES REQUESTED / BLOCKED
          ```
      </task-call>

      <!-- Task 4: TDD Guide (SIMPLE + COMPLEX only) -->
      <task-call id="test_review" if="tdd-guide in {{review_agents}}">
        subagent_type: "everything-claude-code:tdd-guide"
        description: "Test review for {{story_key}}"
        prompt: |
          ## Test Coverage Review Task

          **Story:** {{story_key}}

          **Files to Review:**
          {{files_to_review}}

          **Acceptance Criteria:**
          {{acceptance_criteria}}

          **Testing Patterns:**
          {{project_testing_patterns}}

          **Review Checklist:**
          1. Test coverage percentage
          2. AC coverage - each AC has corresponding test
          3. Edge case coverage
          4. Error scenario coverage
          5. Test quality (real assertions vs placeholders)
          6. TDD compliance (tests written first?)
          7. Test naming conventions
          8. Mock/stub appropriateness

          **TEA 5-Dimension Test Quality Scoring:**
          Score each dimension 0-100:
          1. **Determinism**: No random/time-dependent failures, no flaky tests
          2. **Isolation**: No shared state between tests, proper setup/teardown
          3. **Maintainability**: Readable, follows project patterns, DRY test helpers
          4. **Coverage**: Happy path + critical error paths covered, ACs tested
          5. **Performance**: Tests run within time budgets

          Overall = weighted average. Threshold: 70+ = GOOD, <70 = NEEDS IMPROVEMENT.

          **Output Format:**
          ```
          ## Test Review Findings

          ### Coverage Gaps
          - [AC/Feature]: Missing test for [scenario] [file]

          ### Test Quality Issues
          - [Test]: [Issue] [file:line]

          ### TEA 5-Dimension Quality Score
          | Dimension | Score | Notes |
          |-----------|-------|-------|
          | Determinism | X/100 | [details] |
          | Isolation | X/100 | [details] |
          | Maintainability | X/100 | [details] |
          | Coverage | X/100 | [details] |
          | Performance | X/100 | [details] |
          | **Overall** | **X/100** | **GOOD / NEEDS IMPROVEMENT** |

          ### Summary
          - Test quality: GOOD / NEEDS IMPROVEMENT
          - TDD compliance: COMPLIANT / NON-COMPLIANT
          - Recommendation: APPROVE / CHANGES REQUESTED
          ```
      </task-call>
    </ecc-parallel-spawn>

    <action>Wait for all selected agents to complete</action>
    <action>Collect outputs from spawned agents only</action>
  </step>

  <!-- STEP 3: Review Synthesis -->

  <step n="3" goal="Synthesis of parallel review outputs">
    <critical>REVIEW SYNTHESIS - Merge findings, resolve conflicts, add workflow analysis</critical>
    <critical>ARCHITECTURE GATE: Architectural violations are BLOCKING</critical>
    <critical>WEIGHTED SCORING: Adjust weights based on which agents were used</critical>

    <action>Merge findings from all spawned agents by severity:
      - CRITICAL: Security vulnerabilities requiring immediate fix
      - HIGH: Must fix before approval (includes architectural violations)
      - MEDIUM: Should fix, can be action items
      - LOW: Nice to have improvements
    </action>

    <action>Identify conflicts between agent recommendations</action>
    <action>Calculate individual agent scores (1-10 scale) for each spawned agent</action>
    <action>Calculate overall score as average of all active agent scores</action>

    <output>## ECC Adaptive Review Synthesis

      **Story:** {{story_key}} | **Date:** {date} | **Classification:** {{classification}} | **Agents:** {{review_agents}}

      ---

      ### Overall Assessment

      | Agent | Score | Status |
      |-------|-------|--------|
      | Code Quality | {{code_score}}/10 | {{code_status}} |
      {{#if security-reviewer in review_agents}}
      | Security | {{security_score}}/10 | {{security_status}} |
      {{/if}}
      {{#if architect in review_agents}}
      | Architecture | {{arch_score}}/10 | {{arch_status}} |
      {{/if}}
      {{#if tdd-guide in review_agents}}
      | Testing | {{test_score}}/10 | {{test_status}} |
      {{/if}}
      | **OVERALL** | **{{overall_score}}/10** | **{{overall_status}}** |

      ---

      ### Numbered Findings

      | # | Sev | Agent | Finding | Effort |
      |---|-----|-------|---------|--------|
      {{#each all_findings_numbered}}
      | {{index}} | {{severity}} | {{agent}} | {{description}} [{{file}}:{{line}}] | {{effort_class}} |
      {{/each}}

      ---

      **Recommendation:** {{final_recommendation}}
    </output>
  </step>

  <!-- STEP 4: Smart Triage -->

  <step n="4" goal="Auto-triage findings by effort, let user choose handling per item or batch">
    <critical>SMART TRIAGE: Every finding gets an effort classification + suggested action</critical>

    <!-- 4a: Auto-classify each finding by effort -->
    <action>For each finding from Step 3, classify effort:

      QUICK (fix in current session):
      - Missing validation or guard clause (1-5 lines)
      - Naming convention fix
      - Missing error handling on a single call
      - Adding a missing test assertion
      - Import cleanup or unused variable
      - Simple type fix
      - Missing null check
      - Documentation/comment fix
      - Single-file, localized change

      COMPLEX (needs separate work):
      - Multi-file refactoring
      - New abstraction or pattern introduction
      - Architectural restructuring
      - Service layer redesign
      - New test infrastructure needed
      - Security model change
      - State management refactoring
      - Performance optimization requiring profiling
      - Changes touching >3 files
    </action>

    <!-- 4b: Present triage options -->
    <ask>**Smart Triage** - {{quick_count}} quick fixes, {{complex_count}} complex items

      1. **[Q]uick + Defer** - Fix all QUICK now -> create TD stories for COMPLEX *(Recommended)*
      2. **[F]ix all** - Fix everything now (only if scope fits in session)
      3. **[C]ustom** - Per-item control with range syntax (e.g., `fix 1-3, defer 4-6`)
      4. **[S]kip** - Mark review complete without changes

      Choose [Q], [F], [C], or [S]:</ask>

    <!-- 4c: Execute chosen triage strategy -->
    <check if="user chooses Q (Quick + Defer)">
      <action>Fix all findings where effort_class = QUICK</action>
      <action>Re-run tests after fixes</action>
      <action>Set {{td_items}} = all findings where effort_class = COMPLEX</action>
      <action>Proceed to Step 4.5 with {{td_items}}</action>
    </check>

    <check if="user chooses F (Fix all)">
      <action>Fix ALL findings</action>
      <action>Re-run tests after fixes</action>
      <action>Update File List in story</action>
    </check>

    <check if="user chooses C (Custom)">
      <ask>Enter triage commands using range syntax:

        - `fix 1-5` or `fix 1,3,5` - fix these items now
        - `defer 6-8` - create TD stories for these items
        - Combine: `fix 1-3, defer 4-6`
        - Shortcuts: `fix quick`, `defer complex`

        Enter triage commands:</ask>
    </check>

    <check if="user chooses S (Skip)">
      <output>Review marked complete without changes.</output>
    </check>
  </step>

  <!-- STEP 4.5: Tech Debt Story Creation (Optional) -->

  <step n="4.5" goal="Create tech debt stories for deferred items">
    <critical>TECH DEBT TRACKING - Every deferred item becomes a tracked TD story</critical>

    <action>Group deferred items by theme to minimize story count</action>

    <action>For each TD story group, create story file in {sprint_artifacts}/stories/</action>

    <action>Update sprint-status.yaml with each TD story: ready-for-dev</action>
    <action>Update source story with TD links</action>

    <output>**Tech Debt Stories Created**

      Created {{td_story_count}} TD stories.
      Sprint status updated. Stories ready for sprint planning.
    </output>
  </step>

  <!-- STEP 5: Update Story Status -->

  <step n="5" goal="Update story status based on review outcome">
    <check if="no CRITICAL or HIGH issues OR all fixed">
      <action>Update story Status to "done"</action>
      <action>Set {{new_status}} = "done"</action>
    </check>

    <check if="CRITICAL or HIGH issues remain">
      <action>Update story Status to "in-progress"</action>
      <action>Set {{new_status}} = "in-progress"</action>
    </check>

    <check if="{{sprint_status}} file exists">
      <action>Update sprint-status.yaml: {{story_key}} -> {{new_status}}</action>
    </check>

    <action>Add "Senior Developer Review (ECC)" section to story</action>
  </step>

  <!-- STEP 6: E2E Coverage Check & Review Complete -->

  <step n="6" goal="Check E2E coverage gaps, finalize review and report results">

    <!-- 6a: Check for UI changes without E2E coverage -->
    <action>Check if any {{files_to_review}} match UI component patterns:
      - "src/components/**/*.tsx" (excluding ui/ - those are shadcn primitives)
      - "src/hooks/*.ts" (hooks that drive UI behavior)
      - "src/stores/*.ts" (state that drives UI)
    </action>
    <action>Set {{has_ui_changes}} = true/false</action>
    <action>Set {{changed_ui_files}} = list of matching UI files</action>

    <check if="{{has_ui_changes}}">
      <!-- 6b: Search existing E2E specs for coverage -->
      <action>Search tests/e2e/*.spec.ts for data-testid values from {{changed_ui_files}}:
        - For each changed .tsx component, extract data-testid attributes from source
        - Search existing E2E specs for those testids
        - Set {{covered_testids}} = testids found in E2E specs
        - Set {{uncovered_testids}} = testids NOT found in any E2E spec
      </action>
      <action>Set {{ui_missing_e2e}} = true if {{uncovered_testids}} is non-empty</action>

      <!-- 6c: Assess critical path importance -->
      <action>Evaluate if the UI changes are on a critical user path:
        - Check if story ACs reference core user flows (authentication, main canvas, toolbox browsing,
          component placement, connection wiring, YAML import/export)
        - Check if changed files are in the primary interaction chain
          (AppLayout, ToolboxPanel, Canvas, Inspector, Dashboard)
        - Set {{is_critical_path}} = true if any of the above match
        - Set {{critical_path_reason}} = brief explanation of why
      </action>
    </check>

    <!-- 6d: Final output with E2E recommendation -->
    <output>**ECC Code Review Complete!**

      **Story:** {{story_key}}
      **Status:** {{new_status}}
      **Classification:** {{classification}}

      **Triage Summary:**
      - Fixed now: {{fixed_count}} items
      {{#if td_story_count}}
      - TD stories created: {{td_story_count}} stories
      {{/if}}

      **ECC Agents Used:**
      {{#each review_agents}}
      - {{agent}}
      {{/each}}

      {{#if has_ui_changes}}
      {{#if ui_missing_e2e}}
      **E2E Coverage Gap Detected**
      UI components changed: {{changed_ui_files}}
      Missing E2E coverage for: {{uncovered_testids}}
      {{#if is_critical_path}}
      **Critical path:** {{critical_path_reason}}
      **Recommendation:** Run `/ecc-e2e` — these changes affect a core user flow.
      {{/if}}
      {{#if NOT is_critical_path}}
      **Recommendation:** Consider running `/ecc-e2e` for E2E coverage of new UI changes.
      {{/if}}
      {{/if}}
      {{#if NOT ui_missing_e2e}}
      E2E: Existing specs cover the changed UI components.
      {{/if}}
      {{/if}}

      **Next Steps:**
      {{#if new_status == "done"}}
      - Deploy or commit to branch
      {{/if}}
      {{#if ui_missing_e2e}}
      - Run `/ecc-e2e` to add E2E coverage for new UI changes
      {{/if}}
      {{#if new_status != "done"}}
      - Address remaining issues
      - Re-run `/ecc-code-review` after fixes
      {{/if}}
    </output>

    <!-- 6e: Prompt user on critical path E2E gaps -->
    <check if="{{has_ui_changes}} AND {{ui_missing_e2e}} AND {{is_critical_path}}">
      <ask>E2E gap on critical path. How to proceed?
        [E] Run `/ecc-e2e` now to add E2E coverage
        [S] Skip — will add E2E later or not needed
        [N] Note in story Dev Notes for future reference

        Choose [E], [S], or [N]:</ask>

      <check if="user chooses E">
        <output>Run `/ecc-e2e {{story_key}}` to generate E2E coverage.</output>
      </check>
      <check if="user chooses N">
        <action>Add to story Dev Notes:
          - E2E Gap: {{uncovered_testids}} — deferred by user ({date})
          - Critical path: {{critical_path_reason}}
        </action>
        <output>E2E gap noted in story Dev Notes for future tracking.</output>
      </check>
    </check>
  </step>

</workflow>
