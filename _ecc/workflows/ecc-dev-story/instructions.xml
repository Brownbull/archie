<workflow>
  <critical>The workflow execution engine is governed by: {project-root}/_bmad/core/tasks/workflow.xml</critical>
  <critical>You MUST have already loaded and processed: {installed_path}/workflow.yaml</critical>
  <critical>Communicate all responses in {communication_language} and language MUST be tailored to {user_skill_level}</critical>
  <critical>Generate all documents in {document_output_language}</critical>

  <critical>ECC-ORCHESTRATED STORY DEVELOPMENT - ECC Orchestrator spawns specialized ECC agents!</critical>
  <critical>This workflow uses the Task tool to spawn ECC agents for focused tasks</critical>
  <critical>Sequence: planner -> tdd-guide -> build-error-resolver -> code-reviewer</critical>

  <!-- ECC ORCHESTRATOR PROTOCOL -->
  <orchestrator-protocol>
    <principle>Orchestrator spawns specialized ECC agents, coordinates work, synthesizes outputs</principle>
    <principle>Use Task tool with appropriate subagent_type for each ECC agent</principle>
    <principle>For parallel tasks, spawn multiple agents in a SINGLE message with multiple Task calls</principle>
    <principle>Create handoff documents between sequential agent phases</principle>
    <principle>Synthesize outputs after each agent completes</principle>

    <available-agents>
      | Agent | subagent_type | Purpose |
      |-------|---------------|---------|
      | Planner | everything-claude-code:planner | Implementation planning |
      | TDD Guide | everything-claude-code:tdd-guide | Test-first development |
      | Build Resolver | everything-claude-code:build-error-resolver | Fix build errors |
      | Code Reviewer | everything-claude-code:code-reviewer | Quality review |
      | Security Reviewer | everything-claude-code:security-reviewer | Security analysis |
    </available-agents>
  </orchestrator-protocol>

  <!-- STEP 0: Project Knowledge Loading -->

  <step n="0" goal="Load project knowledge once at session start" tag="knowledge-init">
    <critical>Load ALL project knowledge ONCE at session start, pass to ECC agents</critical>

    <action>Load and cache {project-root}/_ecc/knowledge/code-review-patterns.md -> {{cached_review_patterns}}</action>
    <action>Load and cache any docs/architecture/*.md files that exist -> {{cached_architecture}}</action>
    <action>Store combined as {{project_patterns}} for passing to ECC agents</action>
    <action>Store testing guidelines as {{project_testing_patterns}} for TDD Guide agents</action>

    <output>**ECC Orchestrator Initialized - Project Knowledge Cached**

      Knowledge loaded for session:
      - Code review patterns: {{review_patterns_summary}}
      - Architecture docs: loaded (if available)
      - Testing guidelines: loaded

      ECC agents will receive cached context.
    </output>
  </step>

  <!-- STEP 1: Find and Load Story -->

  <step n="1" goal="Find next ready story and load it" tag="story-discovery">
    <check if="{{story_path}} is provided">
      <action>Use {{story_path}} directly</action>
      <action>Read COMPLETE story file</action>
      <action>Extract story_key from filename or metadata</action>
      <goto anchor="task_check" />
    </check>

    <check if="{{sprint_status}} file exists">
      <action>Load the FULL file: {{sprint_status}}</action>
      <action>Find the FIRST story with status "ready-for-dev"</action>

      <check if="no ready-for-dev story found">
        <output>No ready-for-dev stories found in sprint-status.yaml

          **Options:**
          1. Run `ecc-create-story` to create next story with ECC planning
          2. Specify a particular story file path
        </output>
        <ask>Choose option [1] or [2], or provide story path:</ask>
      </check>
    </check>

    <anchor id="task_check" />
    <action>Parse sections: Story, Acceptance Criteria, Tasks/Subtasks, Dev Notes</action>
    <action>Identify first incomplete task (unchecked [ ])</action>
    <action>Set {{story_context}} = summary of story requirements for ECC agents</action>

    <!-- ARCHITECTURE ENFORCEMENT: Load architectural ACs and documented patterns -->
    <critical>ARCHITECTURE ENFORCEMENT: Extract architectural ACs and pattern documentation</critical>
    <action>Parse "Architectural Acceptance Criteria" section from story</action>
    <action>Extract {{file_location_acs}} - list of required file paths</action>
    <action>Extract {{pattern_acs}} - required patterns from documented architecture</action>
    <action>Extract {{antipattern_acs}} - things that must NOT happen per docs</action>
    <action>Parse "File Specification" table for {{expected_file_paths}}</action>
    <action>Extract {{architecture_reference}} - source of architectural patterns</action>

    <check if="architectural ACs found">
      <output>**Architectural Requirements Loaded**

        **Architecture Source:** {{architecture_reference}}

        **File Location ACs:** {{file_location_ac_count}}
        **Pattern ACs:** {{pattern_ac_count}}
        **Anti-Pattern ACs:** {{antipattern_ac_count}}

        Implementation will be validated against documented patterns.
      </output>
    </check>

    <check if="NO architectural ACs found">
      <output>**Warning: No Architectural ACs Found**

        This story was created without architectural acceptance criteria.
        This may lead to deviation from documented architecture.

        **Recommended Action:** Re-create story using `ecc-create-story` workflow
        to generate ACs from architecture documentation.
      </output>
      <ask>Continue without architectural validation? [Y/N]</ask>
    </check>

    <!-- IMPACT ANALYSIS PRE-FLIGHT: Check for cross-cutting risks -->
    <check if="story File Specification touches files in multiple directories or shared services/components">
      <output>**Pre-flight:** This story crosses module boundaries.
        Consider running `/ecc-impact-analysis {{story_key}}` to check for sprint conflicts and transitive dependents before starting implementation.
      </output>
    </check>
  </step>

  <!-- STEP 1.5: Branch Verification and Setup -->

  <step n="1.5" goal="Ensure correct feature branch before any code changes" tag="branch-check">
    <critical>BRANCH GUARD: All development MUST happen on a feature branch off dev.</critical>
    <critical>NEVER start coding on main or dev - always use a feature branch.</critical>

    <action>Run `git branch --show-current` -> {{current_branch}}</action>
    <action>Run `git status --porcelain` -> {{git_status}}</action>

    <!-- Case 1: On a protected branch (main or dev) -->
    <check if="{{current_branch}} == 'main' OR {{current_branch}} == 'dev'">
      <check if="{{git_status}} has uncommitted changes">
        <output>**BRANCH WARNING**

          You are on **{{current_branch}}** (protected) with uncommitted changes.
          These changes must be moved to a feature branch before proceeding.</output>
        <ask>Stash changes and create feature branch? [Y/N]</ask>
        <check if="user says Y">
          <action>Run `git stash`</action>
        </check>
        <check if="user says N">
          <output>Cannot proceed on a protected branch. Commit or stash changes, then create a feature branch.</output>
          <action>EXIT workflow</action>
        </check>
      </check>

      <action>Run `git checkout dev`</action>
      <action>Run `git pull origin dev`</action>
      <action>Derive branch name from story key: feature/{{story_key}}</action>
      <action>Run `git checkout -b feature/{{story_key}}`</action>

      <check if="stashed changes exist">
        <action>Run `git stash pop`</action>
        <output>Stashed changes restored on feature branch.</output>
      </check>

      <action>Set {{current_branch}} = feature/{{story_key}}</action>
      <output>**Feature Branch Created**

        Branch: feature/{{story_key}} (from dev)

        All development will happen on this branch.</output>
    </check>

    <!-- Case 2: Already on a feature branch -->
    <check if="{{current_branch}} != 'main' AND {{current_branch}} != 'dev'">
      <action>Run `git fetch origin`</action>
      <action>Run `git log HEAD..origin/dev --oneline` -> {{behind_commits}}</action>

      <check if="{{behind_commits}} is not empty">
        <output>**BRANCH SYNC WARNING**

          Branch **{{current_branch}}** is behind dev by commits:
          {{behind_commits}}

          Rebasing before development prevents merge conflicts later.</output>
        <ask>Rebase onto latest dev? [Y/N]</ask>
        <check if="user says Y">
          <action>Run `git rebase origin/dev`</action>
          <check if="rebase conflict">
            <output>**REBASE CONFLICT** - Resolve manually and re-run ecc-dev-story.</output>
            <action>EXIT workflow</action>
          </check>
          <output>Branch rebased onto latest dev.</output>
        </check>
        <check if="user says N">
          <output>Proceeding with potentially outdated branch. Merge conflicts may occur later.</output>
        </check>
      </check>

      <check if="{{behind_commits}} is empty">
        <output>**Branch Verified**

          Branch: {{current_branch}} (up-to-date with dev)

          Ready to proceed with devment.</output>
      </check>
    </check>
  </step>

  <!-- STEP 2: ECC Planner - Implementation Planning -->

  <step n="2" goal="Spawn ECC Planner for implementation planning" tag="ecc-planner">
    <critical>ECC ORCHESTRATOR: Spawning ECC Planner agent</critical>

    <action>Prepare planner context:
      - Story requirements: {{story_context}}
      - Architecture patterns: {{project_patterns}}
      - Incomplete tasks: {{task_list}}
    </action>

    <output>**Spawning ECC Planner...**

      Task: Create implementation plan for story {{story_key}}
      Context: Project patterns + story requirements
    </output>

    <ecc-spawn agent="planner">
      <task-call>
        subagent_type: "everything-claude-code:planner"
        description: "Plan story implementation"
        prompt: |
          Plan the implementation for story: {{story_key}}

          **Story Requirements:**
          {{story_context}}

          **Tasks to Implement:**
          {{task_list}}

          **Architecture Patterns:**
          {{project_patterns}}

          **Output Required:**
          1. Implementation approach for each task
          2. File changes required
          3. Dependencies and order
          4. Risk assessment
          5. Testing strategy alignment

          Create a clear implementation plan that the TDD Guide agent can follow.
      </task-call>
    </ecc-spawn>

    <action>Collect planner output as {{implementation_plan}}</action>
    <action>Store in Dev Agent Record -> Implementation Plan</action>

    <output>**ECC Planner Complete**

      Implementation plan created:
      {{implementation_plan_summary}}
    </output>
  </step>

  <!-- STEP 2.5: Post-Planning Complexity Check -->

  <step n="2.5" goal="Validate story size after planning reveals true scope" tag="post-planning-size">
    <critical>MID-STORY SIZING: Check if planning revealed hidden complexity</critical>

    <action>Extract from {{implementation_plan}}:
      - {{planned_files}}: Number of files planner identified for changes
      - {{planned_subtasks}}: Subtasks inferred from plan
      - {{dependencies_discovered}}: New dependencies found during planning
    </action>

    <action>Compare to original story metrics:
      - {{original_files}}: From story File List / File Specification
      - {{original_subtasks}}: From story Tasks section
    </action>

    <action>Calculate growth:
      - {{file_growth}} = planned_files - original_files
      - {{subtask_growth}} = planned_subtasks - original_subtasks
    </action>

    <check if="file_growth > 3 OR subtask_growth > 5">
      <output>**COMPLEXITY GROWTH DETECTED**

        **Original Story Estimate:**
        - Files: {{original_files}}
        - Subtasks: {{original_subtasks}}

        **After Planning:**
        - Files: {{planned_files}} (+{{file_growth}})
        - Subtasks: {{planned_subtasks}} (+{{subtask_growth}})

        **Recommendation:** Consider splitting this story before proceeding.
      </output>

      <ask>How to proceed?
        [C]ontinue - Accept increased scope (document risk)
        [S]plit - Split story now before implementation
        [A]bort - Stop and re-scope

        Choose [C], [S], or [A]:</ask>

      <check if="user chooses C">
        <action>Document in Dev Notes:
          - Complexity Growth Accepted: {date}
          - Original scope: {{original_files}} files, {{original_subtasks}} subtasks
          - Actual scope: {{planned_files}} files, {{planned_subtasks}} subtasks
          - Risk: May require extended implementation time
        </action>
        <output>Proceeding with increased scope. Risk documented.</output>
      </check>

      <check if="user chooses S">
        <action>Invoke story-sizing workflow for this story</action>
        <action>Create split stories</action>
        <action>Update sprint-status.yaml with new stories</action>
        <action>Continue with first split story</action>
      </check>

      <check if="user chooses A">
        <action>Mark story status as "blocked" in sprint-status.yaml</action>
        <output>Story blocked for re-scoping. Run create-story to revise.</output>
        <stop/>
      </check>
    </check>

    <check if="file_growth &lt;= 3 AND subtask_growth &lt;= 5">
      <output>Planning scope matches story estimate. Proceeding.</output>
    </check>
  </step>

  <!-- STEP 3: Mark Story In-Progress -->

  <step n="3" goal="Mark story in-progress" tag="status-update">
    <check if="{{sprint_status}} file exists">
      <action>Update story status: ready-for-dev -> in-progress</action>
      <output>Story {{story_key}} marked in-progress</output>
    </check>
  </step>

  <!-- STEP 4: ECC TDD Guide - Test-First Implementation -->

  <step n="4" goal="Spawn ECC TDD Guide for test-first implementation" tag="ecc-tdd">
    <critical>ECC ORCHESTRATOR: Spawning ECC TDD Guide agent for each task</critical>
    <critical>ARCHITECTURE ENFORCEMENT: Validate file locations after each task</critical>
    <critical>TDD WATCH MODE: Start watcher once, cache files, avoid re-reads</critical>
    <critical>BATCHED PROGRESS: Track subtasks in memory, write story file only on task_complete</critical>

    <!-- PROGRESS TRACKER: Initialize in-memory tracking -->
    <action>Initialize progress tracker in memory:
      {{progress_tracker}} = {
        completed_subtasks: [],
        completed_tasks: [],
        current_task: null,
        files_changed: []
      }
    </action>
    <output>Progress tracker initialized. Story file updates batched at task boundaries.</output>

    <!-- SIZING METRICS: Track cumulative implementation size in memory -->
    <action>Run `dust src/ -d 2` to capture baseline directory sizes for context budgeting</action>
    <action>Initialize sizing metrics in memory:
      {{sizing_metrics}} = {
        current_files: 0,
        current_loc: 0,
        completed_task_count: 0,
        remaining_tasks: length of {{task_list}},
        baseline_dir_sizes: output of dust command
      }
    </action>

    <!-- TDD EFFICIENCY: Minimize redundant reads and test runs -->
    <action>For each task, read test + implementation files ONCE before starting TDD loop.
      After editing, context already has new content - avoid redundant re-reads of unchanged files.
      Run tests per-edit - do NOT run full suite per subtask.
    </action>

    <loop for="each incomplete task in {{task_list}}">
      <output>**Spawning ECC TDD Guide for Task: {{current_task}}**

        Phase: RED-GREEN-REFACTOR cycle
      </output>

      <ecc-spawn agent="tdd-guide">
        <task-call>
          subagent_type: "everything-claude-code:tdd-guide"
          description: "TDD implementation for {{current_task}}"
          prompt: |
            Implement task using strict TDD methodology: {{current_task}}

            **Implementation Plan (from Planner):**
            {{implementation_plan}}

            **Testing Patterns:**
            {{project_testing_patterns}}

            ---

            ## MANDATORY: Documented Architecture Compliance

            **Architecture Source:** {{architecture_reference}}

            **You MUST follow the documented architectural patterns.**
            Creating files outside documented locations creates technical debt.

            **Expected File Paths (from story File Specification):**
            {{expected_file_paths}}

            **Documented File Structure Patterns:**
            {{file_location_acs}}

            **Documented Pattern Requirements:**
            {{pattern_acs}}

            **Anti-Patterns from Documentation (MUST NOT DO):**
            {{antipattern_acs}}

            ---

            **Requirements:**
            1. Write FAILING tests first (RED phase)
            2. Implement MINIMAL code to pass tests (GREEN phase)
            3. Refactor while keeping tests green (REFACTOR phase)
            4. Ensure 80%+ coverage for new code
            5. **Create files ONLY at locations specified in story File Specification**
            6. **Follow all patterns documented in {{architecture_reference}}**
            7. **Run tests per-edit - avoid full suite per subtask**
            8. **Do NOT run build per task - defer to Step 5 consolidated validation**
            9. **Do NOT edit the story file for subtask completion - report completed subtasks in your output, the orchestrator will batch-update**

            **Task Details:**
            {{current_task_details}}

            **Expected Output:**
            - Test files created/modified
            - Implementation files created/modified (AT SPECIFIED PATHS)
            - Coverage report
            - List of completed subtasks (for batch tracking, NOT written to story file)
        </task-call>
      </ecc-spawn>

      <action>Collect TDD output for {{current_task}}</action>

      <!-- ARCHITECTURE VALIDATION: Check file locations after each task -->
      <action>Identify new files created by TDD Guide</action>
      <action>Validate each new file against {{expected_file_paths}} and architectural ACs</action>

      <check if="file location violation detected">
        <output>**ARCHITECTURAL VIOLATION DETECTED**

          **Violation Type:** File Location Mismatch

          **Expected:** {{expected_path}}
          **Actual:** {{actual_path}}

          **Affected AC:** {{violated_ac}}

          This violates the story's architectural requirements.
        </output>

        <ask>How to handle?
          [F]ix - Move file to correct location and update imports
          [E]xception - Document exception (requires justification)
          [A]bort - Stop implementation until resolved</ask>

        <check if="user chooses F">
          <action>Move file from {{actual_path}} to {{expected_path}}</action>
          <action>Update all imports referencing the old path</action>
          <action>Re-run tests to ensure nothing broke</action>
          <output>File moved to correct location. Imports updated.</output>
        </check>

        <check if="user chooses E">
          <ask>Provide justification for exception:</ask>
          <action>Document exception in story Dev Notes:
            - Architectural exception for: {{actual_path}}
            - Expected: {{expected_path}}
            - Justification: {{user_justification}}
            - Date: {date}
          </action>
          <output>Exception documented. Will be flagged in code review.</output>
        </check>

        <check if="user chooses A">
          <action>Mark story as blocked</action>
          <output>Implementation paused. Resolve architectural issue before continuing.</output>
          <stop/>
        </check>
      </check>

      <!-- Handle build errors with Build Resolver -->
      <check if="build errors detected">
        <output>Build errors detected - spawning Build Resolver...</output>

        <ecc-spawn agent="build-resolver">
          <task-call>
            subagent_type: "everything-claude-code:build-error-resolver"
            description: "Fix build errors"
            prompt: |
              Fix the build/type errors with MINIMAL changes.

              **Errors:**
              {{build_errors}}

              **Rules:**
              - Fix ONLY what's needed to make build pass
              - Do NOT refactor unrelated code
              - Do NOT change architecture
              - Do NOT move files to different locations
              - Add type annotations where missing
              - Fix imports/exports
          </task-call>
        </ecc-spawn>
      </check>

      <!-- BATCHED PROGRESS: Track in memory, then single story file write per task -->
      <action>Add completed subtasks from TDD Guide output to {{progress_tracker}}.completed_subtasks</action>
      <action>Add {{current_task}} to {{progress_tracker}}.completed_tasks</action>
      <action>Add changed files to {{progress_tracker}}.files_changed</action>

      <!-- BATCH WRITE: Single story file edit for entire task -->
      <action>BATCH EDIT story file:
        - Mark all subtasks in {{progress_tracker}}.completed_subtasks for this task as [x]
        - Mark {{current_task}} as [x] complete
        - Update File List with {{progress_tracker}}.files_changed
      </action>
      <action>Clear {{progress_tracker}}.completed_subtasks for next task</action>

      <!-- MID-TASK SIZING CHECK -->
      <sizing-check tag="mid-task-size">
        <action>Update {{sizing_metrics}} from task output (in memory, no file reads):
          - Increment current_files with new files from this task
          - Add LOC from this task to current_loc
          - Increment completed_task_count
          - Decrement remaining_tasks
        </action>

        <check if="sizing_metrics.current_files > 8 OR sizing_metrics.current_loc > (500 * sizing_metrics.completed_task_count)">
          <output>**MID-IMPLEMENTATION SIZE ALERT**

            **Task Completed:** {{current_task}}

            **Current Metrics:**
            - Files modified: {{sizing_metrics.current_files}} (limit: 8)
            - Lines added: {{sizing_metrics.current_loc}}
            - Remaining tasks: {{sizing_metrics.remaining_tasks}}

            **Risk:** Story may be too large for single implementation cycle.
          </output>

          <ask>Continue with remaining tasks?
            [C]ontinue - Accept current trajectory
            [P]ause - Commit current work, create follow-up story for remaining tasks
            [S]plit - Split remaining tasks into new story now

            Choose [C], [P], or [S]:</ask>
        </check>
      </sizing-check>

      <output>**Task Complete:** {{current_task}}

        Files created (architecture validated):
        {{task_files_list}}
        Subtasks batched in single edit: {{batched_subtask_count}}
      </output>
    </loop>

    <output>**ECC TDD Guide Complete**

      Tasks implemented: {{completed_task_count}}
      Test coverage: {{coverage_percentage}}%
      Architecture violations fixed: {{violations_fixed_count}}
    </output>
  </step>

  <!-- STEP 5: Run Full Test Suite -->

  <step n="5" goal="Consolidated validation - build once, skip redundant type-checks" tag="validation">
    <critical>CONSOLIDATED VALIDATION: Single build covers type checking. No separate type-check.</critical>

    <!-- 1. Run full test suite -->
    <action>Run full test suite</action>

    <check if="tests fail">
      <output>Tests failing - spawning Build Resolver...</output>

      <ecc-spawn agent="build-resolver">
        <task-call>
          subagent_type: "everything-claude-code:build-error-resolver"
          description: "Fix test failures"
          prompt: |
            Fix the failing tests with minimal changes.

            **Test Failures:**
            {{test_failures}}

            Fix only what's needed to make tests pass.
        </task-call>
      </ecc-spawn>

      <action>Re-run tests after fixes</action>
    </check>

    <!-- 2. Run lint once -->
    <action>Run linting</action>

    <!-- 3. Single consolidated build (includes type checking) -->
    <action>Run build ONCE (includes type checking)</action>

    <check if="build fails">
      <output>Build failed - spawning Build Resolver...</output>

      <ecc-spawn agent="build-resolver">
        <task-call>
          subagent_type: "everything-claude-code:build-error-resolver"
          description: "Fix build/type errors"
          prompt: |
            Fix the build/type errors with MINIMAL changes.

            **Build Output:**
            {{build_errors}}

            **Rules:**
            - Fix ONLY what's needed to make build pass
            - Do NOT refactor unrelated code
            - Do NOT change architecture
        </task-call>
      </ecc-spawn>

      <action>Re-run build ONLY if changes were made</action>
    </check>

    <check if="build passes">
      <output>Build passed (includes type checking - no separate type-check needed)</output>
    </check>

    <output>**Consolidated Validation Complete**

      Tests: {{test_result}}
      Lint: {{lint_result}}
      Build: {{build_result}} (includes type checking)
    </output>
  </step>

  <!-- STEP 6: Parallel Pre-Completion Review -->

  <step n="6" goal="Parallel ECC review before marking complete" tag="ecc-parallel-review">
    <critical>ECC ORCHESTRATOR: Spawning PARALLEL review agents (SINGLE message, MULTIPLE Task calls)</critical>

    <parallel-execution-rule>
      HOW TO ACHIEVE TRUE PARALLELISM:

      You MUST issue BOTH Task tool invocations in your NEXT SINGLE RESPONSE.
    </parallel-execution-rule>

    <output>**Spawning Parallel Review Team...**

      Agents running in parallel:
      1. Code Reviewer - Quality and best practices
      2. Security Reviewer - Vulnerability analysis
    </output>

    <ecc-spawn-parallel>
      <task-call-1>
        subagent_type: "everything-claude-code:code-reviewer"
        description: "Code quality review"
        prompt: |
          Review the implementation for story: {{story_key}}

          **Files Changed:**
          {{file_list}}

          **Check for:**
          - Code quality and maintainability
          - Error handling
          - Performance issues
          - Test quality
          - Documentation

          Output: List of findings with severity (HIGH/MEDIUM/LOW)
      </task-call-1>

      <task-call-2>
        subagent_type: "everything-claude-code:security-reviewer"
        description: "Security review"
        prompt: |
          Security review for story: {{story_key}}

          **Files Changed:**
          {{file_list}}

          **Check for:**
          - OWASP Top 10 vulnerabilities
          - Hardcoded secrets
          - Input validation
          - Authentication/authorization issues

          Output: Security findings with severity and remediation
      </task-call-2>
    </ecc-spawn-parallel>

    <action>Collect outputs from both agents</action>
    <action>Merge findings by severity</action>

    <output>**Review Synthesis - Parallel Review Results**

      **Code Review Findings:**
      {{code_review_findings}}

      **Security Review Findings:**
      {{security_review_findings}}
    </output>

    <check if="HIGH severity issues found">
      <action>Fix HIGH severity issues before proceeding</action>
      <action>Re-run affected tests</action>
    </check>
  </step>

  <!-- STEP 7: Story Completion -->

  <step n="7" goal="Mark story complete and update status" tag="completion">
    <action>Verify ALL tasks marked [x] complete</action>
    <action>Verify ALL functional acceptance criteria satisfied</action>
    <action>Verify ALL architectural acceptance criteria satisfied (validated per-task in Step 4)</action>
    <action>Update story Status to "review"</action>

    <check if="{{sprint_status}} file exists">
      <action>Update sprint-status.yaml: {{story_key}} -> review</action>
    </check>

    <output>**Story Implementation Complete**

      Story: {{story_key}}
      Status: Ready for review
      Tasks completed: {{task_count}}
      Coverage: {{coverage_percentage}}%

      **ECC Agents Used:**
      - Planner: Implementation planning
      - TDD Guide: Test-first development
      - Build Resolver: Error fixing (if needed)
      - Code Reviewer: Quality review
      - Security Reviewer: Security analysis

      **Architectural Validation:**
      - File Location ACs: {{file_location_passed}}/{{file_location_total}}
      - Pattern ACs: {{pattern_passed}}/{{pattern_total}}
      - Anti-Pattern ACs: {{antipattern_passed}}/{{antipattern_total}}
    </output>
  </step>

  <!-- STEP 8: E2E Coverage Check & Next Steps -->

  <step n="8" goal="Detect E2E coverage gaps and provide next steps" tag="next-steps">

    <!-- 8a: Detect UI changes -->
    <action>Check if any files in {{progress_tracker}}.files_changed match UI component patterns:
      - "src/components/**/*.tsx" (excluding ui/ - those are shadcn primitives)
      - "src/hooks/*.ts" (hooks that drive UI behavior)
      - "src/stores/*.ts" (state that drives UI)
    </action>
    <action>Set {{has_ui_changes}} = true/false</action>
    <action>Set {{changed_ui_files}} = list of matching UI files</action>

    <!-- 8b: Check for existing E2E coverage -->
    <check if="{{has_ui_changes}}">
      <action>Search tests/e2e/*.spec.ts for data-testid values matching {{changed_ui_files}}:
        - For each changed .tsx component, extract data-testid attributes from source
        - Search existing E2E specs for those testids
        - Set {{covered_testids}} = testids found in E2E specs
        - Set {{uncovered_testids}} = testids NOT found in any E2E spec
      </action>
      <action>Set {{ui_missing_e2e}} = true if {{uncovered_testids}} is non-empty</action>

      <!-- 8c: Assess critical path importance -->
      <action>Evaluate if the UI changes are on a critical user path:
        - Check if story ACs reference core user flows (authentication, main canvas, toolbox browsing,
          component placement, connection wiring, YAML import/export)
        - Check if changed files are in the primary interaction chain
          (AppLayout, ToolboxPanel, Canvas, Inspector, Dashboard)
        - Set {{is_critical_path}} = true if any of the above match
        - Set {{critical_path_reason}} = brief explanation of why
      </action>
    </check>

    <!-- 8d: Present E2E recommendation to user -->
    <output>**Next Steps:**
      - Run `/ecc-code-review` for external review
      {{#if has_ui_changes}}
      {{#if ui_missing_e2e}}

      **E2E Coverage Gap Detected**
      UI components changed: {{changed_ui_files}}
      Missing E2E coverage for: {{uncovered_testids}}
      {{#if is_critical_path}}
      **Critical path:** {{critical_path_reason}}
      **Recommendation:** Run `/ecc-e2e` — these changes affect a core user flow.
      {{/if}}
      {{#if NOT is_critical_path}}
      **Recommendation:** Consider running `/ecc-e2e` for E2E coverage of new UI changes.
      {{/if}}
      {{/if}}
      {{#if NOT ui_missing_e2e}}
      Existing E2E specs cover the changed UI components.
      {{/if}}
      {{/if}}
      - Or proceed to deployment if approved
    </output>

    <check if="{{has_ui_changes}} AND {{ui_missing_e2e}} AND {{is_critical_path}}">
      <ask>E2E gap on critical path. How to proceed?
        [E] Run `/ecc-e2e` now to add E2E coverage
        [S] Skip — will add E2E later or not needed
        [N] Note in story Dev Notes for future reference

        Choose [E], [S], or [N]:</ask>

      <check if="user chooses E">
        <output>Run `/ecc-e2e {{story_key}}` to generate E2E coverage.</output>
      </check>
      <check if="user chooses N">
        <action>Add to story Dev Notes:
          - E2E Gap: {{uncovered_testids}} — deferred by user ({date})
          - Critical path: {{critical_path_reason}}
        </action>
        <output>E2E gap noted in story Dev Notes for future tracking.</output>
      </check>
    </check>
  </step>

</workflow>
