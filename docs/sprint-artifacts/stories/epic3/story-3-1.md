# Story: 3-1 YAML Import Pipeline

## Status: done
## Epic: Epic 3 — YAML Workflow & Content Library

## Overview

As a user, I want to import a YAML file to load a complete architecture onto the canvas, so that I can visualize and iterate on architectures generated by AI or saved from previous sessions.

This story creates the full YAML import pipeline: the architecture file Zod schema (with versioning), the import service (parse → validate → sanitize → hydrate → recalculate), the import UI (toolbar button + file picker + validation error display), and placeholder nodes for unknown components. It is the security boundary where all untrusted user data enters the application — validation, sanitization, and allowlisting happen here. Journey 1 (AI Round-Trip) starts working after this story.

## Functional Acceptance Criteria

**AC-1: Import Trigger**
**Given** I am on the main app view
**When** I click the Import button in the toolbar (or drag a .yaml/.yml file onto the canvas)
**Then** a file picker opens allowing me to select a YAML file
**And** the import flow does not use modals for core interaction (UX10) — uses inline panel or toast-style feedback

**AC-2: Successful Import**
**Given** I select a valid YAML file
**When** the file is parsed and validated
**Then** the architecture materializes on the canvas: components placed at saved positions, connections drawn, configuration variants set
**And** the import completes within 1 second for up to 20 components (NFR4)
**And** the recalculation engine runs on the imported architecture (metrics, heatmap, dashboard, tier all update)

**AC-3: Skeleton Hydration**
**Given** the imported YAML contains component IDs and config variant selections
**When** the system hydrates the skeleton from the component library
**Then** full component data (metrics, descriptions, pros/cons) is loaded from the library cache
**And** the YAML only needs to contain skeleton data: IDs, positions, connections, config selections, schema version (FR25)

**AC-4: Unknown Component Handling**
**Given** the imported YAML references a component ID not in the component library
**When** the hydration process encounters it
**Then** a placeholder node is displayed on the canvas at the saved position (AR10)
**And** the placeholder shows the unknown component ID and a "not found" indicator
**And** recognized components load normally alongside placeholders

**AC-5: Schema Validation**
**Given** the imported YAML has unexpected keys, missing required fields, or invalid structure
**When** validation runs against the Zod schema
**Then** the file is rejected with clear, specific error messages (FR27)
**And** errors are displayed inline near the import trigger with Zod error path details

**AC-6: File Size Limit**
**Given** the imported YAML file exceeds 1MB
**When** the file size check runs (before parsing)
**Then** the file is rejected with a "File too large (max 1MB)" error message (NFR7)

**AC-7: String Sanitization**
**Given** the imported YAML contains string fields (component names, descriptions, labels)
**When** they are hydrated into the architecture store
**Then** all user-provided strings are passed through `sanitizeDisplayString()` before rendering (NFR8)

**AC-8: URL Validation**
**Given** the imported YAML contains URL fields (docs links, icons)
**When** URLs are validated during import
**Then** only `https://` URLs are accepted; `javascript:`, `data:`, and other schemes are rejected (NFR9)

**AC-9: Schema Versioning**
**Given** the imported YAML has a `schema_version` header
**When** the version is checked
**Then** same-major/newer-minor versions import normally (new fields get defaults)
**And** older-major versions attempt migration if a migration function exists, otherwise reject with clear error
**And** newer-major versions are rejected with "created with a newer version of Archie" message (AR9)

**AC-10: MIME/Extension Validation**
**Given** the user selects a file via the file picker
**When** the file is checked before parsing
**Then** only `.yaml` and `.yml` extensions are accepted
**And** files with other extensions are rejected with a clear error

**AC-11: No Unsafe Code Execution**
**Given** YAML is processed during import
**When** parsing executes
**Then** only safe YAML loading is used (`js-yaml` `load()`) — no `eval()`, `new Function()`, or dynamic `import()` (NFR10)

**AC-12: Canvas Replacement**
**Given** there are existing components on the canvas
**When** I import a new YAML file
**Then** the current canvas is replaced with the imported architecture
**And** all previous computed state (metrics, heatmap, tier) is cleared and recalculated for the new architecture

## Architectural Acceptance Criteria (MANDATORY)

> These ACs are MANDATORY and will be validated during code review.

### File Location Requirements

- **AC-ARCH-LOC-1:** Architecture file Zod schema located at `src/schemas/architectureFileSchema.ts`
- **AC-ARCH-LOC-2:** YAML import service located at `src/services/yamlImporter.ts`
- **AC-ARCH-LOC-3:** Import dialog component located at `src/components/import-export/ImportDialog.tsx`
- **AC-ARCH-LOC-4:** Validation errors component located at `src/components/import-export/ValidationErrors.tsx`
- **AC-ARCH-LOC-5:** Placeholder node component located at `src/components/canvas/PlaceholderNode.tsx`
- **AC-ARCH-LOC-6:** Architecture store import action in `src/stores/architectureStore.ts`
- **AC-ARCH-LOC-7:** Toolbar import button in `src/components/layout/Toolbar.tsx`
- **AC-ARCH-LOC-8:** Schema unit tests at `tests/unit/schemas/architectureFileSchema.test.ts`
- **AC-ARCH-LOC-9:** Import service unit tests at `tests/unit/services/yamlImporter.test.ts`
- **AC-ARCH-LOC-10:** Type re-exports in `src/types/index.ts`

### Pattern Requirements

- **AC-ARCH-PATTERN-1:** `architectureFileSchema.ts` defines the Zod schema as the single source of truth for the YAML file format. TypeScript types are derived from the schema with `z.infer<>`. The schema uses `.strict()` to reject unknown keys (NFR6, AR5)
- **AC-ARCH-PATTERN-2:** The schema defines both a `ArchitectureFileSchema` (camelCase, for internal use) and an `ArchitectureFileYamlSchema` (snake_case with `.transform()` to camelCase) — matching the pattern in `componentSchema.ts` (AR21)
- **AC-ARCH-PATTERN-3:** `yamlImporter.ts` follows the import pipeline order defined in architecture.md: file size check → parse YAML string (`js-yaml load()`) → validate with Zod schema (`safeParse`) → sanitize strings → hydrate from component library → place unknowns as placeholders → trigger recalculation
- **AC-ARCH-PATTERN-4:** The import service reads component data from `componentLibrary.getComponent()` synchronously (O(1) Map cache) — no async Firestore calls during hydration (AR18)
- **AC-ARCH-PATTERN-5:** The import service returns a typed result (success with architecture data OR failure with error details) — the store action handles the result, the UI displays errors
- **AC-ARCH-PATTERN-6:** `PlaceholderNode.tsx` is registered as a custom React Flow node type alongside `ArchieNode` — consistent with the existing node type pattern (AR16)
- **AC-ARCH-PATTERN-7:** Import replaces the entire canvas state — calls `architectureStore` with the complete new nodes/edges arrays, then triggers full-graph recalculation for all nodes
- **AC-ARCH-PATTERN-8:** Schema version is `"1.0.0"` for MVP. The migration registry is an empty map (no migrations needed yet) but the structure is in place for future versions (AR9)
- **AC-ARCH-PATTERN-9:** Error boundary wraps the import UI components (ImportDialog, ValidationErrors) — import failures never crash the app

### Anti-Pattern Requirements (Must NOT Happen)

- **AC-ARCH-NO-1:** Import service MUST NOT use `eval()`, `new Function()`, or dynamic `import()` on YAML content (NFR10)
- **AC-ARCH-NO-2:** Import service MUST NOT use `js-yaml loadAll()` — only `load()` for single document (security)
- **AC-ARCH-NO-3:** Import service MUST NOT render YAML strings without sanitization — all strings pass through `sanitizeDisplayString()` (NFR8)
- **AC-ARCH-NO-4:** Import service MUST NOT accept `javascript:`, `data:`, or `vbscript:` URL schemes — only `https://` (NFR9)
- **AC-ARCH-NO-5:** Import UI MUST NOT use `dangerouslySetInnerHTML` for any imported content (NFR8)
- **AC-ARCH-NO-6:** Import MUST NOT leave Blob URLs un-revoked — if any are created during import, revoke after use
- **AC-ARCH-NO-7:** Import MUST NOT call Firestore directly — uses componentLibrary cache only (AR6, AR18)
- **AC-ARCH-NO-8:** YAML schema MUST NOT accept unknown keys — uses Zod `.strict()` mode (NFR6)

## File Specification

| File/Component | Exact Path | Pattern Reference | Status |
|----------------|------------|-------------------|--------|
| architectureFileSchema | `src/schemas/architectureFileSchema.ts` | Zod single source of truth (AR5) | NEW |
| yamlImporter | `src/services/yamlImporter.ts` | Service orchestration (AR18) | NEW |
| ImportDialog | `src/components/import-export/ImportDialog.tsx` | React component | NEW |
| ValidationErrors | `src/components/import-export/ValidationErrors.tsx` | React component | NEW |
| PlaceholderNode | `src/components/canvas/PlaceholderNode.tsx` | React Flow custom node (AR16) | NEW |
| architectureStore | `src/stores/architectureStore.ts` | Zustand store (AR15) | MODIFY |
| Toolbar | `src/components/layout/Toolbar.tsx` | Layout component | MODIFY |
| CanvasView | `src/components/canvas/CanvasView.tsx` | React Flow container | MODIFY |
| types/index | `src/types/index.ts` | Type re-exports | MODIFY |
| architectureFileSchema.test | `tests/unit/schemas/architectureFileSchema.test.ts` | Unit test (AR22) | NEW |
| yamlImporter.test | `tests/unit/services/yamlImporter.test.ts` | Unit test (AR22) | NEW |

## Tasks / Subtasks

### Task 1: Architecture File Zod Schema
- [ ] 1.1 Create `src/schemas/architectureFileSchema.ts` with `ArchitectureFileSchema` defining the YAML skeleton structure:
  - `schema_version: string` (semver, e.g., "1.0.0")
  - `library_version: string` (optional — metadata for component library version tracking)
  - `name: string` (optional — architecture name)
  - `nodes: Array<{ id, component_id, config_variant_id, position: { x, y } }>`
  - `edges: Array<{ id, source_node_id, target_node_id }>`
- [ ] 1.2 Create snake_case YAML input variant (`ArchitectureFileYamlSchema`) with `.transform()` to camelCase — matching `componentSchema.ts` pattern
- [ ] 1.3 Use `.strict()` on all schema objects to reject unexpected keys (NFR6)
- [ ] 1.4 Add `CURRENT_SCHEMA_VERSION = "1.0.0"` constant
- [ ] 1.5 Implement version comparison utility: `checkSchemaVersion(fileVersion, appVersion)` returning `"compatible" | "migrate" | "too-new" | "too-old"`
- [ ] 1.6 Create migration registry: `const MIGRATIONS: Record<string, (data: unknown) => unknown> = {}` (empty for v1, structure in place)
- [ ] 1.7 Export types: `ArchitectureFile`, `ArchitectureFileNode`, `ArchitectureFileEdge`
- [ ] 1.8 Re-export new types from `src/types/index.ts`
- [ ] 1.9 Write unit tests: valid schema parses, unknown keys rejected (.strict()), missing required fields rejected, snake_case transforms to camelCase, version comparison all cases (compatible, migrate, too-new, too-old), empty nodes/edges arrays valid, malformed position objects rejected

### Task 2: YAML Import Service
- [ ] 2.1 Create `src/services/yamlImporter.ts` with `importYaml(file: File): Promise<ImportResult>` where `ImportResult = { success: true, architecture: HydratedArchitecture } | { success: false, errors: ImportError[] }`
- [ ] 2.2 Step 1 — File validation: check `file.size <= MAX_FILE_SIZE` (1MB), check extension is `.yaml` or `.yml`
- [ ] 2.3 Step 2 — Parse: read file as text (`file.text()`), parse with `js-yaml load()` (safe by default in v4+)
- [ ] 2.4 Step 3 — Schema validation: `ArchitectureFileYamlSchema.safeParse(parsed)` — collect Zod errors with paths
- [ ] 2.5 Step 4 — Version check: call `checkSchemaVersion()`, apply migration if available, reject if incompatible
- [ ] 2.6 Step 5 — Sanitize strings: pass component names, descriptions, labels through `sanitizeDisplayString()` from `src/lib/sanitize.ts`
- [ ] 2.7 Step 6 — URL validation: check any URL fields are `https://` only, reject `javascript:`, `data:`, `vbscript:` schemes
- [ ] 2.8 Step 7 — Hydrate: for each node, look up `componentLibrary.getComponent(componentId)` (sync). If found, build `ArchieNode` with full data. If not found, mark as placeholder
- [ ] 2.9 Step 8 — Build edges: for each edge in YAML, create `ArchieEdge` with compatibility check via `checkCompatibility()` from existing engine
- [ ] 2.10 Step 9 — Return `HydratedArchitecture`: `{ nodes: ArchieNode[], edges: ArchieEdge[], placeholderIds: string[] }`
- [ ] 2.11 Define `ImportError` type: `{ code: string, message: string, path?: string }` for structured error reporting
- [ ] 2.12 Write unit tests: successful import (valid YAML → nodes/edges returned), file too large (rejected), invalid extension (rejected), malformed YAML (parse error), schema validation failure (Zod errors returned), unknown component ID (placeholder created), version mismatch (migration or rejection), sanitization applied to strings, URL validation rejects javascript: URIs

### Task 3: Import UI Components
- [ ] 3.1 Create `src/components/import-export/ImportDialog.tsx` with a hidden file input (`<input type="file" accept=".yaml,.yml">`) triggered by the toolbar button
- [ ] 3.2 Implement file drag-and-drop support: register drop handler on the canvas area, accept `.yaml`/`.yml` files
- [ ] 3.3 On file selection/drop: call `yamlImporter.importYaml(file)`, show loading state, then dispatch to store or show errors
- [ ] 3.4 Create `src/components/import-export/ValidationErrors.tsx` displaying structured import errors with Zod error paths
- [ ] 3.5 Show validation errors inline using toast notifications (Sonner) — no modal dialogs (UX10)
- [ ] 3.6 Add `data-testid` attributes: `import-button`, `import-file-input`, `import-drop-zone`, `validation-error-list`, `validation-error-item`
- [ ] 3.7 Wrap import flow with ErrorBoundary — import failures never crash the app
- [ ] 3.8 Add "Import" button to `src/components/layout/Toolbar.tsx` between the logo and the user section
- [ ] 3.9 Wire EmptyCanvasState "Import a YAML file" suggestion to trigger the file picker

### Task 4: Placeholder Node Component
- [ ] 4.1 Create `src/components/canvas/PlaceholderNode.tsx` as a custom React Flow node type
- [ ] 4.2 Display: unknown component ID, "Component not found" label, dashed border, muted colors
- [ ] 4.3 Register `placeholder` node type in `CanvasView.tsx` alongside existing `archie-component` type
- [ ] 4.4 Placeholder nodes are non-interactive (no config dropdown, no inspector detail) but can be selected and deleted
- [ ] 4.5 Add `data-testid="placeholder-node"` attribute

### Task 5: Store Integration
- [ ] 5.1 Add `loadArchitecture(nodes: ArchieNode[], edges: ArchieEdge[])` action to `architectureStore.ts`
- [ ] 5.2 `loadArchitecture` clears all existing state (nodes, edges, computedMetrics, previousMetrics, heatmapColors, edgeHeatmapColors, rippleActiveNodeIds, currentTier) and sets the new nodes/edges
- [ ] 5.3 `loadArchitecture` clears uiStore selection state (selectedNodeId, selectedEdgeId) — uses existing cross-store pattern
- [ ] 5.4 After loading, trigger full-graph recalculation for all imported nodes
- [ ] 5.5 Write unit tests: loadArchitecture replaces canvas, clears computed state, triggers recalculation

### Task 6: E2E Testing & data-testid Audit
- [ ] 6.1 Add `data-testid` attributes to all new interactive elements (import button, file input, validation errors, placeholder node)
- [ ] 6.2 Create `tests/e2e/import-export.spec.ts` with import scenarios: successful import with valid YAML, validation error display, oversized file rejection
- [ ] 6.3 Save screenshots at key import steps to `test-results/import-export/`
- [ ] 6.4 Use element.waitFor() for state transitions (not waitForTimeout)

### Task 7: Build Verification
- [ ] 7.1 Run `npx tsc --noEmit` — no type errors
- [ ] 7.2 Run `npm run test:quick` — all tests pass
- [ ] 7.3 Verify coverage meets thresholds (Lines 45%, Branches 30%, Functions 25%, Statements 40%)

## Dev Notes

### Architecture Guidance

**Import Pipeline (the complete flow):**
```
User clicks Import button / drops file on canvas
  → ImportDialog receives File object
  → yamlImporter.importYaml(file)
    → Step 1: file.size > MAX_FILE_SIZE? → reject
    → Step 2: extension check (.yaml/.yml) → reject if not
    → Step 3: file.text() → js-yaml load() → raw object
    → Step 4: ArchitectureFileYamlSchema.safeParse(raw) → reject if invalid
    → Step 5: checkSchemaVersion() → migrate or reject if incompatible
    → Step 6: sanitizeDisplayString() on all string fields
    → Step 7: URL validation (https:// only)
    → Step 8: hydrate nodes from componentLibrary (sync O(1))
    → Step 9: build edges with compatibility check
    → Return ImportResult (success or errors)
  → On success: architectureStore.loadArchitecture(nodes, edges)
    → Store clears all state, sets new nodes/edges
    → Store triggers full-graph recalculation
    → Canvas renders imported architecture
  → On failure: show ValidationErrors via toast
```

**Architecture File YAML Format (v1.0.0):**
```yaml
schema_version: "1.0.0"
name: "My Architecture"
nodes:
  - id: "node-uuid-1"
    component_id: "postgresql"
    config_variant_id: "single-node"
    position:
      x: 100
      y: 200
  - id: "node-uuid-2"
    component_id: "redis"
    config_variant_id: "standalone"
    position:
      x: 300
      y: 200
edges:
  - id: "edge-uuid-1"
    source_node_id: "node-uuid-1"
    target_node_id: "node-uuid-2"
```

**Hydration Pattern:**
```typescript
// For each YAML node:
const component = componentLibrary.getComponent(yamlNode.componentId)
if (!component) {
  // Create placeholder node
  return { ...baseNode, type: 'placeholder', data: { unknownComponentId: yamlNode.componentId } }
}
const variant = component.configVariants.find(v => v.id === yamlNode.configVariantId)
  ?? component.configVariants[0] // fallback to default variant
return {
  id: yamlNode.id, // preserve original ID from YAML
  type: NODE_TYPE_COMPONENT,
  position: { x: snapToGrid(yamlNode.position.x), y: snapToGrid(yamlNode.position.y) },
  data: {
    archieComponentId: component.id,
    activeConfigVariantId: variant.id,
    componentName: sanitizeDisplayString(component.name),
    componentCategory: component.category as ComponentCategoryId,
  },
  width: NODE_WIDTH,
}
```

### Technical Notes

**js-yaml Safety:** `js-yaml` v4+ `load()` is safe by default — it does not construct arbitrary JavaScript objects. Only `loadAll()` with custom schemas can be dangerous. Always use `load()`.

**Zod .strict() Mode:** Rejects objects with any keys not defined in the schema. This is the primary defense against YAML key injection (NFR6). Use on every nested object in the architecture file schema.

**File Input Pattern:** Use a hidden `<input type="file">` triggered by the toolbar button click. The canvas drag-and-drop uses the HTML5 Drag and Drop API with `onDrop`/`onDragOver` handlers on the canvas container.

**sanitizeDisplayString Coverage:** The existing function in `src/lib/sanitize.ts` already handles NFC normalization, ReDoS guard, dangerous tag stripping, HTML stripping, protocol URI stripping, and truncation. It was hardened in TD-1-4a and TD-1-4b. Epic 3 needs to call it on every user-provided string from YAML — component names are NOT user-provided (they come from the library), but if YAML includes a `name` field for the architecture itself, that IS user-provided.

**Canvas Replacement vs Merge:** Import REPLACES the canvas entirely. There is no merge/append mode in MVP. The `loadArchitecture` store action clears everything and sets fresh state. This is simpler and avoids ID collision issues.

**Full-Graph Recalculation:** After loading, trigger recalculation for ALL imported nodes (not just a single changed node). Use `recalculateArchitecture()` from the existing engine for initial load, or iterate and call `triggerRecalculation` per node. The former is more efficient.

### Cross-Cutting Dependencies

**DEPENDS ON (inbound — all satisfied by Epic 1 & 2):**
- Story 1-1: Firebase Auth (import requires authentication)
- Story 1-2: componentLibrary service (getComponent sync lookup for hydration)
- Story 1-3: architectureStore (setNodes/setEdges), ArchieNodeData interface, CanvasView
- Story 1-4: ArchieEdgeData, checkCompatibility engine function, addEdge pattern
- Story 2-1: recalculationService (triggerRecalculation for imported architecture)
- Story 2-2: heatmapCalculator (heatmap updates on import)
- Existing: sanitizeDisplayString (from TD-1-4a/TD-1-4b), MAX_FILE_SIZE constant

**CONSUMED BY (outbound):**
- Story 3-2 (Export): Uses architectureFileSchema for export format, validates exported YAML
- Story 3-3 (Examples): Blueprint loading uses the same hydration pipeline
- TD-3-1a (Import Robustness): Adversarial test coverage for this pipeline

### Hardening Notes (Built-in)

**Pattern 1 (Data Pipeline):** Schema uses .strict(), validation edge cases in test suite, snake_case→camelCase transform at boundary.
**Pattern 2 (Error Resilience):** ErrorBoundary wraps import UI, graceful degradation on import failure (toast errors, not blank screen).
**Pattern 3 (Input Sanitization):** sanitizeDisplayString() on all YAML strings, URL https-only validation, file size/extension checks.
**Pattern 4 (E2E Testing):** data-testid on all interactive elements, E2E spec with import scenarios.

### E2E Testing

Key E2E scenarios:
- Import valid YAML → canvas populates with components and connections
- Import invalid YAML → validation error toast displayed
- Import oversized file → rejection error displayed
- Import YAML with unknown component → placeholder node visible
- Import replaces existing canvas → previous components gone, new ones present

## Code Review

**Date:** 2026-02-15
**Verdict:** APPROVED 9/10
**Agents:** code-reviewer (sonnet), security-reviewer (sonnet), architect (opus), tdd-guide (haiku)
**Classification:** COMPLEX (7 tasks, 18 files, security+architecture sensitive)

### Findings Summary (9 findings)

| # | Finding | Severity | Agent | Action |
|---|---------|----------|-------|--------|
| 1 | URL fields need `https://`-only validation when added to schema | Medium | Security | Deferred → added AC-7 to TD-3-1a |
| 2 | `snapToGrid` duplicated in yamlImporter vs canvas | Low | Code | Skipped — only 1 line, DRY overkill |
| 3 | Placeholder uses `"compute"` as default category | Low | Code | Skipped — reasonable fallback |
| 4 | `NODE_TYPE_PLACEHOLDER` defined in yamlImporter, not constants | Low | Code | **FIXED** — moved to constants.ts |
| 5 | Success toast doesn't show architecture name | Low | Code | **FIXED** — added name label |
| 6 | Error messages expose internal paths via Zod | Low | Code | Skipped — helpful for users |
| 7 | `MIGRATIONS` mutation via `Object.assign` in test | Low | Code | Skipped — works fine |
| 8 | Missing sanitization test in yamlImporter tests | Low | TDD | Skipped — covered by sanitize.ts tests |
| 9 | No test for edges with non-existent node IDs | Low | TDD | **FIXED** — added test |

### E2E Gap

No E2E spec covers YAML import yet. Key scenarios documented in story but not automated. E2E import spec should be added as part of Epic 3 E2E pass.

### Invalid Findings Filtered (2)
- "loadArchitecture doesn't recalculate tier" — FALSE: `triggerRecalculation` calls `evaluateAndSetTier`
- "Missing dragover preventDefault" — FALSE: present at CanvasView.tsx:124-127

## ECC Analysis Summary
- Risk Level: HIGH (primary attack surface — untrusted file import)
- Complexity: High
- Sizing: LARGE (7 tasks, ~38 subtasks, ~11 files)
- Agents consulted: Planner, Architect, Security Reviewer
- Hardening: BUILT-IN (schema validation, sanitization, error boundary, E2E)
- Separate TD: TD-3-1a (adversarial test coverage)
- Key risks: YAML injection via unexpected keys (mitigated by .strict()), XSS via string fields (mitigated by sanitizeDisplayString), file size DoS (mitigated by MAX_FILE_SIZE check)
